/*
 * Copyright (c) Air Computing Inc., 2012.
 */

package com.aerofs.xray.server.core;

import com.aerofs.base.Loggers;
import org.slf4j.Logger;

import java.io.IOException;
import java.nio.channels.CancelledKeyException;
import java.nio.channels.ClosedChannelException;
import java.nio.channels.SelectableChannel;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.util.Iterator;

import static com.aerofs.xray.server.core.ZUtil.closeChannel;
import static com.aerofs.xray.server.core.ZUtil.istdesc;
import static com.aerofs.xray.server.core.ZUtil.rdydesc;
import static com.aerofs.xray.server.core.ZUtil.subInterest;
import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkState;
import static java.nio.channels.SelectionKey.OP_ACCEPT;
import static java.nio.channels.SelectionKey.OP_CONNECT;
import static java.nio.channels.SelectionKey.OP_READ;
import static java.nio.channels.SelectionKey.OP_WRITE;

/**
 * NOTES: - Reduce copying - Use Futures if possible - May not be able to use threads because we use
 * our own thread scheduling mechanisms - Close out all sockets if/when there are errors - How do I
 * generalize this _not_ to copy? - handlers have to know dispatcher - what are the implications of
 * having access to everyone's selection keys? - interesting: _idToKey is very zephyr-specific; how
 * do I generalize this to deal with threadpools? - should I use pb? - zephyr should have a
 * method/command for the controlling application to removeEndpoint the connection - callers of
 * message creation functions should handle BufferOverflowException - need to be able to send in the
 * channels on which I want to wait, etc. for testing - do all IoEventHandlers need a terminate
 * function?
 */
public class Dispatcher implements Runnable
{
    public void init()
            throws IOException
    {
        try {
            _sel = Selector.open();
            _inited = true;
        } catch (IOException e) {
            l.error("zd: sel: e on open:{}", e);
            closeSelector();
            throw e;
        }
    }

    @Override
    public final void run()
    {
        checkState(_inited, "zd: uninited");

        if (_started) return;
        _started = true;

        l.info("zd: starting");

        try {
            while (!_stop) {
                int ready;

                try {
                    ready = _sel.select();
                } catch (IOException e) {
                    l.error("zd: sel: fail select err:{}", e);
                    throw e;
                }

                if (_stop) return; // check, because you may have been woken up to stop

                l.trace("zd: handling ready keys:{}", ready);

                if (ready > 0) {
                    Iterator<SelectionKey> rkit = _sel.selectedKeys().iterator();
                    while (rkit.hasNext()) {
                        SelectionKey key = rkit.next();
                        rkit.remove();
                        handleKeyReady(key);
                    }
                }

                processNonNioEvents();
            }
        } catch (FatalIOEventHandlerException e) {
            l.error("zd: terminating: fioehex");
        } catch (IOException e) {
            l.error("zd: terminating: ioex");
        } finally {
            l.info("zd: terminating");
            closeSelector();
        }
    }

    public final void shutdown()
    {
        _stop = true;
        _sel.wakeup(); // wake up the selector so that it stops

        l.info("zd: received stop");
    }

    public final SelectionKey register(SelectableChannel c, IIOEventHandler ioe, int... ists)
            throws ClosedChannelException
    {
        if (_stop) {
            throw new ClosedChannelException();
        }

        int istmask;
        if (ists.length == 1 && ists[0] == 0) {
            istmask = 0;
        } else {
            istmask = ZUtil.getInterestMask(ists);
        }

        return c.register(_sel, istmask, ioe);
    }

    private void handleKeyReady(SelectionKey k)
            throws FatalIOEventHandlerException
    {
        // any assert on validity may be false, because a prior operation (for
        // example, attempting to write a response within the read) may have invalidated
        // the key
        // oh...I now understand why there was a check inside Hitchen's NIO code
        // for checking validity prior to a write

        // NOTE: all keys are deregistered prior to their handlers being called
        try {
            //
            // handle io events generated by the selector
            //

            l.trace("zd: key:{} ists:{} rdy:{} att:{}",
                    k, istdesc(k), rdydesc(k), k.attachment().toString());

            if (k.isValid() && k.isAcceptable()) {
                subInterest(k, OP_ACCEPT);
                IIOEventHandler ioe = assertAndGetAttachment(k);
                ioe.handleAcceptReady_(k);
            }

            if (k.isValid() && k.isConnectable()) {
                subInterest(k, OP_CONNECT);
                IIOEventHandler ioe = assertAndGetAttachment(k);
                ioe.handleConnectReady_(k);
            }

            if (k.isValid() && k.isReadable()) {
                subInterest(k, OP_READ);
                IIOEventHandler ioe = assertAndGetAttachment(k);
                ioe.handleReadReady_(k);
            }

            if (k.isValid() && k.isWritable()) {
                subInterest(k, OP_WRITE);
                IIOEventHandler ioe = assertAndGetAttachment(k);
                ioe.handleWriteReady_(k);
            }

            //
            // if cancellation occurred, inform the key attachment that their
            // associated key was cancelled
            //
            // NOTE: do not assume that key cancellations cannot occur at the
            // beginning of this block. since selectors can be closed from any
            // thread, their associated keys can be cancelled at any time
            //

            if (!k.isValid()) {
                IIOEventHandler ioe = assertAndGetAttachment(k);
                ioe.handleKeyCancelled_(k);
            }
        } catch (FatalIOEventHandlerException e) {
            l.error("zd: k:{}: fataled during handle", k);
            throw e;
        } catch (CancelledKeyException e) {
            l.error("zd: k:{}: fail handle due to cancelled key:", k, e);
            closeChannel(k.channel());
        } catch (IllegalStateException e) {
            l.error("zd: k:{}: fail handle with unexpected ise:", k, e);
            commitMessySuicide(e);
        } catch (IllegalArgumentException e) {
            l.error("zd: k:{}: fail handle with unexpected iae:", k, e);
            commitMessySuicide(e);
        } catch (Exception e) {
            l.error("zd: k:{}: fail handle err:", k, e);
            closeChannel(k.channel()); // implicitly closes keys for this channel
        }
    }

    private static void commitMessySuicide(Throwable cause)
    {
        l.error("zd: dying from self-inflicted wound:", cause);
        System.exit(183);
    }

    /**
     * override to process other events in the context of the NIO dispatcher thread
     */
    protected void processNonNioEvents()
    {
        // noop
    }

    private void closeSelector()
    {
        try {
            if (_sel != null) _sel.close();
            l.info("zd: sel: close");
        } catch (IOException e) {
            l.warn("zd: sel: fail close err:", e);
        }
    }

    private static IIOEventHandler assertAndGetAttachment(SelectionKey k)
    {
        IIOEventHandler ioe = (IIOEventHandler) k.attachment();
        checkArgument(ioe != null, "zd: k:" + k + ": null att");
        return ioe;
    }

    //
    // members
    //

    protected Selector _sel = null;

    private volatile boolean _inited = false;
    private volatile boolean _started = false;
    private volatile boolean _stop = false;

    protected static Logger l = Loggers.getLogger(Dispatcher.class);
}
