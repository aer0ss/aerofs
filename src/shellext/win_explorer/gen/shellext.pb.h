// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: shellext.proto

#ifndef PROTOBUF_shellext_2eproto__INCLUDED
#define PROTOBUF_shellext_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "path_status.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_shellext_2eproto();
void protobuf_AssignDesc_shellext_2eproto();
void protobuf_ShutdownFile_shellext_2eproto();

class ShellextCall;
class GreetingCall;
class CreateLinkCall;
class ShareFolderCall;
class SyncStatusCall;
class VersionHistoryCall;
class ConflictResolutionCall;
class GetPathStatusCall;
class ShellextNotification;
class RootAnchorNotification;
class PathStatusNotification;
class LinkSharingEnabled;

enum ShellextCall_Type {
  ShellextCall_Type_GREETING = 0,
  ShellextCall_Type_SHARE_FOLDER = 1,
  ShellextCall_Type_SYNC_STATUS = 2,
  ShellextCall_Type_VERSION_HISTORY = 3,
  ShellextCall_Type_CONFLICT_RESOLUTION = 5,
  ShellextCall_Type_CREATE_LINK = 6,
  ShellextCall_Type_GET_PATH_STATUS = 4
};
bool ShellextCall_Type_IsValid(int value);
const ShellextCall_Type ShellextCall_Type_Type_MIN = ShellextCall_Type_GREETING;
const ShellextCall_Type ShellextCall_Type_Type_MAX = ShellextCall_Type_CREATE_LINK;
const int ShellextCall_Type_Type_ARRAYSIZE = ShellextCall_Type_Type_MAX + 1;

enum ShellextNotification_Type {
  ShellextNotification_Type_ROOT_ANCHOR = 1,
  ShellextNotification_Type_PATH_STATUS = 2,
  ShellextNotification_Type_CLEAR_STATUS_CACHE = 3,
  ShellextNotification_Type_LINK_SHARING_ENABLED = 4
};
bool ShellextNotification_Type_IsValid(int value);
const ShellextNotification_Type ShellextNotification_Type_Type_MIN = ShellextNotification_Type_ROOT_ANCHOR;
const ShellextNotification_Type ShellextNotification_Type_Type_MAX = ShellextNotification_Type_LINK_SHARING_ENABLED;
const int ShellextNotification_Type_Type_ARRAYSIZE = ShellextNotification_Type_Type_MAX + 1;

// ===================================================================

class ShellextCall : public ::google::protobuf::MessageLite {
 public:
  ShellextCall();
  virtual ~ShellextCall();

  ShellextCall(const ShellextCall& from);

  inline ShellextCall& operator=(const ShellextCall& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ShellextCall& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShellextCall* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShellextCall* other);

  // implements Message ----------------------------------------------

  ShellextCall* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShellextCall& from);
  void MergeFrom(const ShellextCall& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ShellextCall_Type Type;
  static const Type GREETING = ShellextCall_Type_GREETING;
  static const Type SHARE_FOLDER = ShellextCall_Type_SHARE_FOLDER;
  static const Type SYNC_STATUS = ShellextCall_Type_SYNC_STATUS;
  static const Type VERSION_HISTORY = ShellextCall_Type_VERSION_HISTORY;
  static const Type CONFLICT_RESOLUTION = ShellextCall_Type_CONFLICT_RESOLUTION;
  static const Type CREATE_LINK = ShellextCall_Type_CREATE_LINK;
  static const Type GET_PATH_STATUS = ShellextCall_Type_GET_PATH_STATUS;
  static inline bool Type_IsValid(int value) {
    return ShellextCall_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ShellextCall_Type_Type_MIN;
  static const Type Type_MAX =
    ShellextCall_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ShellextCall_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .ShellextCall.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::ShellextCall_Type type() const;
  inline void set_type(::ShellextCall_Type value);

  // optional .GreetingCall greeting = 2;
  inline bool has_greeting() const;
  inline void clear_greeting();
  static const int kGreetingFieldNumber = 2;
  inline const ::GreetingCall& greeting() const;
  inline ::GreetingCall* mutable_greeting();
  inline ::GreetingCall* release_greeting();
  inline void set_allocated_greeting(::GreetingCall* greeting);

  // optional .ShareFolderCall share_folder = 3;
  inline bool has_share_folder() const;
  inline void clear_share_folder();
  static const int kShareFolderFieldNumber = 3;
  inline const ::ShareFolderCall& share_folder() const;
  inline ::ShareFolderCall* mutable_share_folder();
  inline ::ShareFolderCall* release_share_folder();
  inline void set_allocated_share_folder(::ShareFolderCall* share_folder);

  // optional .SyncStatusCall sync_status = 4;
  inline bool has_sync_status() const;
  inline void clear_sync_status();
  static const int kSyncStatusFieldNumber = 4;
  inline const ::SyncStatusCall& sync_status() const;
  inline ::SyncStatusCall* mutable_sync_status();
  inline ::SyncStatusCall* release_sync_status();
  inline void set_allocated_sync_status(::SyncStatusCall* sync_status);

  // optional .VersionHistoryCall version_history = 5;
  inline bool has_version_history() const;
  inline void clear_version_history();
  static const int kVersionHistoryFieldNumber = 5;
  inline const ::VersionHistoryCall& version_history() const;
  inline ::VersionHistoryCall* mutable_version_history();
  inline ::VersionHistoryCall* release_version_history();
  inline void set_allocated_version_history(::VersionHistoryCall* version_history);

  // optional .GetPathStatusCall get_path_status = 6;
  inline bool has_get_path_status() const;
  inline void clear_get_path_status();
  static const int kGetPathStatusFieldNumber = 6;
  inline const ::GetPathStatusCall& get_path_status() const;
  inline ::GetPathStatusCall* mutable_get_path_status();
  inline ::GetPathStatusCall* release_get_path_status();
  inline void set_allocated_get_path_status(::GetPathStatusCall* get_path_status);

  // optional .ConflictResolutionCall conflict_resolution = 7;
  inline bool has_conflict_resolution() const;
  inline void clear_conflict_resolution();
  static const int kConflictResolutionFieldNumber = 7;
  inline const ::ConflictResolutionCall& conflict_resolution() const;
  inline ::ConflictResolutionCall* mutable_conflict_resolution();
  inline ::ConflictResolutionCall* release_conflict_resolution();
  inline void set_allocated_conflict_resolution(::ConflictResolutionCall* conflict_resolution);

  // optional .CreateLinkCall create_link = 8;
  inline bool has_create_link() const;
  inline void clear_create_link();
  static const int kCreateLinkFieldNumber = 8;
  inline const ::CreateLinkCall& create_link() const;
  inline ::CreateLinkCall* mutable_create_link();
  inline ::CreateLinkCall* release_create_link();
  inline void set_allocated_create_link(::CreateLinkCall* create_link);

  // @@protoc_insertion_point(class_scope:ShellextCall)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_greeting();
  inline void clear_has_greeting();
  inline void set_has_share_folder();
  inline void clear_has_share_folder();
  inline void set_has_sync_status();
  inline void clear_has_sync_status();
  inline void set_has_version_history();
  inline void clear_has_version_history();
  inline void set_has_get_path_status();
  inline void clear_has_get_path_status();
  inline void set_has_conflict_resolution();
  inline void clear_has_conflict_resolution();
  inline void set_has_create_link();
  inline void clear_has_create_link();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::GreetingCall* greeting_;
  ::ShareFolderCall* share_folder_;
  ::SyncStatusCall* sync_status_;
  ::VersionHistoryCall* version_history_;
  ::GetPathStatusCall* get_path_status_;
  ::ConflictResolutionCall* conflict_resolution_;
  ::CreateLinkCall* create_link_;
  int type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_shellext_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_shellext_2eproto();
  #endif
  friend void protobuf_AssignDesc_shellext_2eproto();
  friend void protobuf_ShutdownFile_shellext_2eproto();

  void InitAsDefaultInstance();
  static ShellextCall* default_instance_;
};
// -------------------------------------------------------------------

class GreetingCall : public ::google::protobuf::MessageLite {
 public:
  GreetingCall();
  virtual ~GreetingCall();

  GreetingCall(const GreetingCall& from);

  inline GreetingCall& operator=(const GreetingCall& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GreetingCall& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GreetingCall* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GreetingCall* other);

  // implements Message ----------------------------------------------

  GreetingCall* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GreetingCall& from);
  void MergeFrom(const GreetingCall& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 protocol_version = 1;
  inline bool has_protocol_version() const;
  inline void clear_protocol_version();
  static const int kProtocolVersionFieldNumber = 1;
  inline ::google::protobuf::int32 protocol_version() const;
  inline void set_protocol_version(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GreetingCall)
 private:
  inline void set_has_protocol_version();
  inline void clear_has_protocol_version();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 protocol_version_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_shellext_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_shellext_2eproto();
  #endif
  friend void protobuf_AssignDesc_shellext_2eproto();
  friend void protobuf_ShutdownFile_shellext_2eproto();

  void InitAsDefaultInstance();
  static GreetingCall* default_instance_;
};
// -------------------------------------------------------------------

class CreateLinkCall : public ::google::protobuf::MessageLite {
 public:
  CreateLinkCall();
  virtual ~CreateLinkCall();

  CreateLinkCall(const CreateLinkCall& from);

  inline CreateLinkCall& operator=(const CreateLinkCall& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CreateLinkCall& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CreateLinkCall* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CreateLinkCall* other);

  // implements Message ----------------------------------------------

  CreateLinkCall* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CreateLinkCall& from);
  void MergeFrom(const CreateLinkCall& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:CreateLinkCall)
 private:
  inline void set_has_path();
  inline void clear_has_path();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* path_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_shellext_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_shellext_2eproto();
  #endif
  friend void protobuf_AssignDesc_shellext_2eproto();
  friend void protobuf_ShutdownFile_shellext_2eproto();

  void InitAsDefaultInstance();
  static CreateLinkCall* default_instance_;
};
// -------------------------------------------------------------------

class ShareFolderCall : public ::google::protobuf::MessageLite {
 public:
  ShareFolderCall();
  virtual ~ShareFolderCall();

  ShareFolderCall(const ShareFolderCall& from);

  inline ShareFolderCall& operator=(const ShareFolderCall& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ShareFolderCall& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShareFolderCall* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShareFolderCall* other);

  // implements Message ----------------------------------------------

  ShareFolderCall* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShareFolderCall& from);
  void MergeFrom(const ShareFolderCall& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:ShareFolderCall)
 private:
  inline void set_has_path();
  inline void clear_has_path();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* path_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_shellext_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_shellext_2eproto();
  #endif
  friend void protobuf_AssignDesc_shellext_2eproto();
  friend void protobuf_ShutdownFile_shellext_2eproto();

  void InitAsDefaultInstance();
  static ShareFolderCall* default_instance_;
};
// -------------------------------------------------------------------

class SyncStatusCall : public ::google::protobuf::MessageLite {
 public:
  SyncStatusCall();
  virtual ~SyncStatusCall();

  SyncStatusCall(const SyncStatusCall& from);

  inline SyncStatusCall& operator=(const SyncStatusCall& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SyncStatusCall& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SyncStatusCall* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SyncStatusCall* other);

  // implements Message ----------------------------------------------

  SyncStatusCall* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SyncStatusCall& from);
  void MergeFrom(const SyncStatusCall& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:SyncStatusCall)
 private:
  inline void set_has_path();
  inline void clear_has_path();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* path_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_shellext_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_shellext_2eproto();
  #endif
  friend void protobuf_AssignDesc_shellext_2eproto();
  friend void protobuf_ShutdownFile_shellext_2eproto();

  void InitAsDefaultInstance();
  static SyncStatusCall* default_instance_;
};
// -------------------------------------------------------------------

class VersionHistoryCall : public ::google::protobuf::MessageLite {
 public:
  VersionHistoryCall();
  virtual ~VersionHistoryCall();

  VersionHistoryCall(const VersionHistoryCall& from);

  inline VersionHistoryCall& operator=(const VersionHistoryCall& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const VersionHistoryCall& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const VersionHistoryCall* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(VersionHistoryCall* other);

  // implements Message ----------------------------------------------

  VersionHistoryCall* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const VersionHistoryCall& from);
  void MergeFrom(const VersionHistoryCall& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:VersionHistoryCall)
 private:
  inline void set_has_path();
  inline void clear_has_path();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* path_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_shellext_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_shellext_2eproto();
  #endif
  friend void protobuf_AssignDesc_shellext_2eproto();
  friend void protobuf_ShutdownFile_shellext_2eproto();

  void InitAsDefaultInstance();
  static VersionHistoryCall* default_instance_;
};
// -------------------------------------------------------------------

class ConflictResolutionCall : public ::google::protobuf::MessageLite {
 public:
  ConflictResolutionCall();
  virtual ~ConflictResolutionCall();

  ConflictResolutionCall(const ConflictResolutionCall& from);

  inline ConflictResolutionCall& operator=(const ConflictResolutionCall& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ConflictResolutionCall& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ConflictResolutionCall* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ConflictResolutionCall* other);

  // implements Message ----------------------------------------------

  ConflictResolutionCall* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ConflictResolutionCall& from);
  void MergeFrom(const ConflictResolutionCall& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:ConflictResolutionCall)
 private:
  inline void set_has_path();
  inline void clear_has_path();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* path_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_shellext_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_shellext_2eproto();
  #endif
  friend void protobuf_AssignDesc_shellext_2eproto();
  friend void protobuf_ShutdownFile_shellext_2eproto();

  void InitAsDefaultInstance();
  static ConflictResolutionCall* default_instance_;
};
// -------------------------------------------------------------------

class GetPathStatusCall : public ::google::protobuf::MessageLite {
 public:
  GetPathStatusCall();
  virtual ~GetPathStatusCall();

  GetPathStatusCall(const GetPathStatusCall& from);

  inline GetPathStatusCall& operator=(const GetPathStatusCall& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetPathStatusCall& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetPathStatusCall* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetPathStatusCall* other);

  // implements Message ----------------------------------------------

  GetPathStatusCall* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetPathStatusCall& from);
  void MergeFrom(const GetPathStatusCall& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:GetPathStatusCall)
 private:
  inline void set_has_path();
  inline void clear_has_path();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* path_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_shellext_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_shellext_2eproto();
  #endif
  friend void protobuf_AssignDesc_shellext_2eproto();
  friend void protobuf_ShutdownFile_shellext_2eproto();

  void InitAsDefaultInstance();
  static GetPathStatusCall* default_instance_;
};
// -------------------------------------------------------------------

class ShellextNotification : public ::google::protobuf::MessageLite {
 public:
  ShellextNotification();
  virtual ~ShellextNotification();

  ShellextNotification(const ShellextNotification& from);

  inline ShellextNotification& operator=(const ShellextNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ShellextNotification& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShellextNotification* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShellextNotification* other);

  // implements Message ----------------------------------------------

  ShellextNotification* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShellextNotification& from);
  void MergeFrom(const ShellextNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ShellextNotification_Type Type;
  static const Type ROOT_ANCHOR = ShellextNotification_Type_ROOT_ANCHOR;
  static const Type PATH_STATUS = ShellextNotification_Type_PATH_STATUS;
  static const Type CLEAR_STATUS_CACHE = ShellextNotification_Type_CLEAR_STATUS_CACHE;
  static const Type LINK_SHARING_ENABLED = ShellextNotification_Type_LINK_SHARING_ENABLED;
  static inline bool Type_IsValid(int value) {
    return ShellextNotification_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ShellextNotification_Type_Type_MIN;
  static const Type Type_MAX =
    ShellextNotification_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ShellextNotification_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .ShellextNotification.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::ShellextNotification_Type type() const;
  inline void set_type(::ShellextNotification_Type value);

  // optional .RootAnchorNotification root_anchor = 2;
  inline bool has_root_anchor() const;
  inline void clear_root_anchor();
  static const int kRootAnchorFieldNumber = 2;
  inline const ::RootAnchorNotification& root_anchor() const;
  inline ::RootAnchorNotification* mutable_root_anchor();
  inline ::RootAnchorNotification* release_root_anchor();
  inline void set_allocated_root_anchor(::RootAnchorNotification* root_anchor);

  // optional .PathStatusNotification path_status = 3;
  inline bool has_path_status() const;
  inline void clear_path_status();
  static const int kPathStatusFieldNumber = 3;
  inline const ::PathStatusNotification& path_status() const;
  inline ::PathStatusNotification* mutable_path_status();
  inline ::PathStatusNotification* release_path_status();
  inline void set_allocated_path_status(::PathStatusNotification* path_status);

  // optional .LinkSharingEnabled link_sharing_enabled = 4;
  inline bool has_link_sharing_enabled() const;
  inline void clear_link_sharing_enabled();
  static const int kLinkSharingEnabledFieldNumber = 4;
  inline const ::LinkSharingEnabled& link_sharing_enabled() const;
  inline ::LinkSharingEnabled* mutable_link_sharing_enabled();
  inline ::LinkSharingEnabled* release_link_sharing_enabled();
  inline void set_allocated_link_sharing_enabled(::LinkSharingEnabled* link_sharing_enabled);

  // @@protoc_insertion_point(class_scope:ShellextNotification)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_root_anchor();
  inline void clear_has_root_anchor();
  inline void set_has_path_status();
  inline void clear_has_path_status();
  inline void set_has_link_sharing_enabled();
  inline void clear_has_link_sharing_enabled();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::RootAnchorNotification* root_anchor_;
  ::PathStatusNotification* path_status_;
  ::LinkSharingEnabled* link_sharing_enabled_;
  int type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_shellext_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_shellext_2eproto();
  #endif
  friend void protobuf_AssignDesc_shellext_2eproto();
  friend void protobuf_ShutdownFile_shellext_2eproto();

  void InitAsDefaultInstance();
  static ShellextNotification* default_instance_;
};
// -------------------------------------------------------------------

class RootAnchorNotification : public ::google::protobuf::MessageLite {
 public:
  RootAnchorNotification();
  virtual ~RootAnchorNotification();

  RootAnchorNotification(const RootAnchorNotification& from);

  inline RootAnchorNotification& operator=(const RootAnchorNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RootAnchorNotification& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RootAnchorNotification* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RootAnchorNotification* other);

  // implements Message ----------------------------------------------

  RootAnchorNotification* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RootAnchorNotification& from);
  void MergeFrom(const RootAnchorNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional string user = 2;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 2;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // @@protoc_insertion_point(class_scope:RootAnchorNotification)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_user();
  inline void clear_has_user();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* path_;
  ::std::string* user_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_shellext_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_shellext_2eproto();
  #endif
  friend void protobuf_AssignDesc_shellext_2eproto();
  friend void protobuf_ShutdownFile_shellext_2eproto();

  void InitAsDefaultInstance();
  static RootAnchorNotification* default_instance_;
};
// -------------------------------------------------------------------

class PathStatusNotification : public ::google::protobuf::MessageLite {
 public:
  PathStatusNotification();
  virtual ~PathStatusNotification();

  PathStatusNotification(const PathStatusNotification& from);

  inline PathStatusNotification& operator=(const PathStatusNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PathStatusNotification& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PathStatusNotification* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PathStatusNotification* other);

  // implements Message ----------------------------------------------

  PathStatusNotification* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PathStatusNotification& from);
  void MergeFrom(const PathStatusNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // required .PBPathStatus status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline const ::PBPathStatus& status() const;
  inline ::PBPathStatus* mutable_status();
  inline ::PBPathStatus* release_status();
  inline void set_allocated_status(::PBPathStatus* status);

  // @@protoc_insertion_point(class_scope:PathStatusNotification)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_status();
  inline void clear_has_status();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* path_;
  ::PBPathStatus* status_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_shellext_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_shellext_2eproto();
  #endif
  friend void protobuf_AssignDesc_shellext_2eproto();
  friend void protobuf_ShutdownFile_shellext_2eproto();

  void InitAsDefaultInstance();
  static PathStatusNotification* default_instance_;
};
// -------------------------------------------------------------------

class LinkSharingEnabled : public ::google::protobuf::MessageLite {
 public:
  LinkSharingEnabled();
  virtual ~LinkSharingEnabled();

  LinkSharingEnabled(const LinkSharingEnabled& from);

  inline LinkSharingEnabled& operator=(const LinkSharingEnabled& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const LinkSharingEnabled& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LinkSharingEnabled* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LinkSharingEnabled* other);

  // implements Message ----------------------------------------------

  LinkSharingEnabled* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LinkSharingEnabled& from);
  void MergeFrom(const LinkSharingEnabled& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool is_link_sharing_enabled = 1;
  inline bool has_is_link_sharing_enabled() const;
  inline void clear_is_link_sharing_enabled();
  static const int kIsLinkSharingEnabledFieldNumber = 1;
  inline bool is_link_sharing_enabled() const;
  inline void set_is_link_sharing_enabled(bool value);

  // @@protoc_insertion_point(class_scope:LinkSharingEnabled)
 private:
  inline void set_has_is_link_sharing_enabled();
  inline void clear_has_is_link_sharing_enabled();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool is_link_sharing_enabled_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_shellext_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_shellext_2eproto();
  #endif
  friend void protobuf_AssignDesc_shellext_2eproto();
  friend void protobuf_ShutdownFile_shellext_2eproto();

  void InitAsDefaultInstance();
  static LinkSharingEnabled* default_instance_;
};
// ===================================================================


// ===================================================================

// ShellextCall

// required .ShellextCall.Type type = 1;
inline bool ShellextCall::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShellextCall::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShellextCall::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShellextCall::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::ShellextCall_Type ShellextCall::type() const {
  // @@protoc_insertion_point(field_get:ShellextCall.type)
  return static_cast< ::ShellextCall_Type >(type_);
}
inline void ShellextCall::set_type(::ShellextCall_Type value) {
  assert(::ShellextCall_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ShellextCall.type)
}

// optional .GreetingCall greeting = 2;
inline bool ShellextCall::has_greeting() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShellextCall::set_has_greeting() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShellextCall::clear_has_greeting() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShellextCall::clear_greeting() {
  if (greeting_ != NULL) greeting_->::GreetingCall::Clear();
  clear_has_greeting();
}
inline const ::GreetingCall& ShellextCall::greeting() const {
  // @@protoc_insertion_point(field_get:ShellextCall.greeting)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return greeting_ != NULL ? *greeting_ : *default_instance().greeting_;
#else
  return greeting_ != NULL ? *greeting_ : *default_instance_->greeting_;
#endif
}
inline ::GreetingCall* ShellextCall::mutable_greeting() {
  set_has_greeting();
  if (greeting_ == NULL) greeting_ = new ::GreetingCall;
  // @@protoc_insertion_point(field_mutable:ShellextCall.greeting)
  return greeting_;
}
inline ::GreetingCall* ShellextCall::release_greeting() {
  clear_has_greeting();
  ::GreetingCall* temp = greeting_;
  greeting_ = NULL;
  return temp;
}
inline void ShellextCall::set_allocated_greeting(::GreetingCall* greeting) {
  delete greeting_;
  greeting_ = greeting;
  if (greeting) {
    set_has_greeting();
  } else {
    clear_has_greeting();
  }
  // @@protoc_insertion_point(field_set_allocated:ShellextCall.greeting)
}

// optional .ShareFolderCall share_folder = 3;
inline bool ShellextCall::has_share_folder() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShellextCall::set_has_share_folder() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShellextCall::clear_has_share_folder() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShellextCall::clear_share_folder() {
  if (share_folder_ != NULL) share_folder_->::ShareFolderCall::Clear();
  clear_has_share_folder();
}
inline const ::ShareFolderCall& ShellextCall::share_folder() const {
  // @@protoc_insertion_point(field_get:ShellextCall.share_folder)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return share_folder_ != NULL ? *share_folder_ : *default_instance().share_folder_;
#else
  return share_folder_ != NULL ? *share_folder_ : *default_instance_->share_folder_;
#endif
}
inline ::ShareFolderCall* ShellextCall::mutable_share_folder() {
  set_has_share_folder();
  if (share_folder_ == NULL) share_folder_ = new ::ShareFolderCall;
  // @@protoc_insertion_point(field_mutable:ShellextCall.share_folder)
  return share_folder_;
}
inline ::ShareFolderCall* ShellextCall::release_share_folder() {
  clear_has_share_folder();
  ::ShareFolderCall* temp = share_folder_;
  share_folder_ = NULL;
  return temp;
}
inline void ShellextCall::set_allocated_share_folder(::ShareFolderCall* share_folder) {
  delete share_folder_;
  share_folder_ = share_folder;
  if (share_folder) {
    set_has_share_folder();
  } else {
    clear_has_share_folder();
  }
  // @@protoc_insertion_point(field_set_allocated:ShellextCall.share_folder)
}

// optional .SyncStatusCall sync_status = 4;
inline bool ShellextCall::has_sync_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShellextCall::set_has_sync_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShellextCall::clear_has_sync_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShellextCall::clear_sync_status() {
  if (sync_status_ != NULL) sync_status_->::SyncStatusCall::Clear();
  clear_has_sync_status();
}
inline const ::SyncStatusCall& ShellextCall::sync_status() const {
  // @@protoc_insertion_point(field_get:ShellextCall.sync_status)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sync_status_ != NULL ? *sync_status_ : *default_instance().sync_status_;
#else
  return sync_status_ != NULL ? *sync_status_ : *default_instance_->sync_status_;
#endif
}
inline ::SyncStatusCall* ShellextCall::mutable_sync_status() {
  set_has_sync_status();
  if (sync_status_ == NULL) sync_status_ = new ::SyncStatusCall;
  // @@protoc_insertion_point(field_mutable:ShellextCall.sync_status)
  return sync_status_;
}
inline ::SyncStatusCall* ShellextCall::release_sync_status() {
  clear_has_sync_status();
  ::SyncStatusCall* temp = sync_status_;
  sync_status_ = NULL;
  return temp;
}
inline void ShellextCall::set_allocated_sync_status(::SyncStatusCall* sync_status) {
  delete sync_status_;
  sync_status_ = sync_status;
  if (sync_status) {
    set_has_sync_status();
  } else {
    clear_has_sync_status();
  }
  // @@protoc_insertion_point(field_set_allocated:ShellextCall.sync_status)
}

// optional .VersionHistoryCall version_history = 5;
inline bool ShellextCall::has_version_history() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ShellextCall::set_has_version_history() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ShellextCall::clear_has_version_history() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ShellextCall::clear_version_history() {
  if (version_history_ != NULL) version_history_->::VersionHistoryCall::Clear();
  clear_has_version_history();
}
inline const ::VersionHistoryCall& ShellextCall::version_history() const {
  // @@protoc_insertion_point(field_get:ShellextCall.version_history)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return version_history_ != NULL ? *version_history_ : *default_instance().version_history_;
#else
  return version_history_ != NULL ? *version_history_ : *default_instance_->version_history_;
#endif
}
inline ::VersionHistoryCall* ShellextCall::mutable_version_history() {
  set_has_version_history();
  if (version_history_ == NULL) version_history_ = new ::VersionHistoryCall;
  // @@protoc_insertion_point(field_mutable:ShellextCall.version_history)
  return version_history_;
}
inline ::VersionHistoryCall* ShellextCall::release_version_history() {
  clear_has_version_history();
  ::VersionHistoryCall* temp = version_history_;
  version_history_ = NULL;
  return temp;
}
inline void ShellextCall::set_allocated_version_history(::VersionHistoryCall* version_history) {
  delete version_history_;
  version_history_ = version_history;
  if (version_history) {
    set_has_version_history();
  } else {
    clear_has_version_history();
  }
  // @@protoc_insertion_point(field_set_allocated:ShellextCall.version_history)
}

// optional .GetPathStatusCall get_path_status = 6;
inline bool ShellextCall::has_get_path_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ShellextCall::set_has_get_path_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ShellextCall::clear_has_get_path_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ShellextCall::clear_get_path_status() {
  if (get_path_status_ != NULL) get_path_status_->::GetPathStatusCall::Clear();
  clear_has_get_path_status();
}
inline const ::GetPathStatusCall& ShellextCall::get_path_status() const {
  // @@protoc_insertion_point(field_get:ShellextCall.get_path_status)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return get_path_status_ != NULL ? *get_path_status_ : *default_instance().get_path_status_;
#else
  return get_path_status_ != NULL ? *get_path_status_ : *default_instance_->get_path_status_;
#endif
}
inline ::GetPathStatusCall* ShellextCall::mutable_get_path_status() {
  set_has_get_path_status();
  if (get_path_status_ == NULL) get_path_status_ = new ::GetPathStatusCall;
  // @@protoc_insertion_point(field_mutable:ShellextCall.get_path_status)
  return get_path_status_;
}
inline ::GetPathStatusCall* ShellextCall::release_get_path_status() {
  clear_has_get_path_status();
  ::GetPathStatusCall* temp = get_path_status_;
  get_path_status_ = NULL;
  return temp;
}
inline void ShellextCall::set_allocated_get_path_status(::GetPathStatusCall* get_path_status) {
  delete get_path_status_;
  get_path_status_ = get_path_status;
  if (get_path_status) {
    set_has_get_path_status();
  } else {
    clear_has_get_path_status();
  }
  // @@protoc_insertion_point(field_set_allocated:ShellextCall.get_path_status)
}

// optional .ConflictResolutionCall conflict_resolution = 7;
inline bool ShellextCall::has_conflict_resolution() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ShellextCall::set_has_conflict_resolution() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ShellextCall::clear_has_conflict_resolution() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ShellextCall::clear_conflict_resolution() {
  if (conflict_resolution_ != NULL) conflict_resolution_->::ConflictResolutionCall::Clear();
  clear_has_conflict_resolution();
}
inline const ::ConflictResolutionCall& ShellextCall::conflict_resolution() const {
  // @@protoc_insertion_point(field_get:ShellextCall.conflict_resolution)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return conflict_resolution_ != NULL ? *conflict_resolution_ : *default_instance().conflict_resolution_;
#else
  return conflict_resolution_ != NULL ? *conflict_resolution_ : *default_instance_->conflict_resolution_;
#endif
}
inline ::ConflictResolutionCall* ShellextCall::mutable_conflict_resolution() {
  set_has_conflict_resolution();
  if (conflict_resolution_ == NULL) conflict_resolution_ = new ::ConflictResolutionCall;
  // @@protoc_insertion_point(field_mutable:ShellextCall.conflict_resolution)
  return conflict_resolution_;
}
inline ::ConflictResolutionCall* ShellextCall::release_conflict_resolution() {
  clear_has_conflict_resolution();
  ::ConflictResolutionCall* temp = conflict_resolution_;
  conflict_resolution_ = NULL;
  return temp;
}
inline void ShellextCall::set_allocated_conflict_resolution(::ConflictResolutionCall* conflict_resolution) {
  delete conflict_resolution_;
  conflict_resolution_ = conflict_resolution;
  if (conflict_resolution) {
    set_has_conflict_resolution();
  } else {
    clear_has_conflict_resolution();
  }
  // @@protoc_insertion_point(field_set_allocated:ShellextCall.conflict_resolution)
}

// optional .CreateLinkCall create_link = 8;
inline bool ShellextCall::has_create_link() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ShellextCall::set_has_create_link() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ShellextCall::clear_has_create_link() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ShellextCall::clear_create_link() {
  if (create_link_ != NULL) create_link_->::CreateLinkCall::Clear();
  clear_has_create_link();
}
inline const ::CreateLinkCall& ShellextCall::create_link() const {
  // @@protoc_insertion_point(field_get:ShellextCall.create_link)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return create_link_ != NULL ? *create_link_ : *default_instance().create_link_;
#else
  return create_link_ != NULL ? *create_link_ : *default_instance_->create_link_;
#endif
}
inline ::CreateLinkCall* ShellextCall::mutable_create_link() {
  set_has_create_link();
  if (create_link_ == NULL) create_link_ = new ::CreateLinkCall;
  // @@protoc_insertion_point(field_mutable:ShellextCall.create_link)
  return create_link_;
}
inline ::CreateLinkCall* ShellextCall::release_create_link() {
  clear_has_create_link();
  ::CreateLinkCall* temp = create_link_;
  create_link_ = NULL;
  return temp;
}
inline void ShellextCall::set_allocated_create_link(::CreateLinkCall* create_link) {
  delete create_link_;
  create_link_ = create_link;
  if (create_link) {
    set_has_create_link();
  } else {
    clear_has_create_link();
  }
  // @@protoc_insertion_point(field_set_allocated:ShellextCall.create_link)
}

// -------------------------------------------------------------------

// GreetingCall

// required int32 protocol_version = 1;
inline bool GreetingCall::has_protocol_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GreetingCall::set_has_protocol_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GreetingCall::clear_has_protocol_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GreetingCall::clear_protocol_version() {
  protocol_version_ = 0;
  clear_has_protocol_version();
}
inline ::google::protobuf::int32 GreetingCall::protocol_version() const {
  // @@protoc_insertion_point(field_get:GreetingCall.protocol_version)
  return protocol_version_;
}
inline void GreetingCall::set_protocol_version(::google::protobuf::int32 value) {
  set_has_protocol_version();
  protocol_version_ = value;
  // @@protoc_insertion_point(field_set:GreetingCall.protocol_version)
}

// -------------------------------------------------------------------

// CreateLinkCall

// required string path = 1;
inline bool CreateLinkCall::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateLinkCall::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateLinkCall::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateLinkCall::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& CreateLinkCall::path() const {
  // @@protoc_insertion_point(field_get:CreateLinkCall.path)
  return *path_;
}
inline void CreateLinkCall::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:CreateLinkCall.path)
}
inline void CreateLinkCall::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:CreateLinkCall.path)
}
inline void CreateLinkCall::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CreateLinkCall.path)
}
inline ::std::string* CreateLinkCall::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CreateLinkCall.path)
  return path_;
}
inline ::std::string* CreateLinkCall::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateLinkCall::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CreateLinkCall.path)
}

// -------------------------------------------------------------------

// ShareFolderCall

// required string path = 1;
inline bool ShareFolderCall::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShareFolderCall::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShareFolderCall::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShareFolderCall::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& ShareFolderCall::path() const {
  // @@protoc_insertion_point(field_get:ShareFolderCall.path)
  return *path_;
}
inline void ShareFolderCall::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:ShareFolderCall.path)
}
inline void ShareFolderCall::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:ShareFolderCall.path)
}
inline void ShareFolderCall::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ShareFolderCall.path)
}
inline ::std::string* ShareFolderCall::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ShareFolderCall.path)
  return path_;
}
inline ::std::string* ShareFolderCall::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ShareFolderCall::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ShareFolderCall.path)
}

// -------------------------------------------------------------------

// SyncStatusCall

// required string path = 1;
inline bool SyncStatusCall::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncStatusCall::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncStatusCall::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncStatusCall::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& SyncStatusCall::path() const {
  // @@protoc_insertion_point(field_get:SyncStatusCall.path)
  return *path_;
}
inline void SyncStatusCall::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:SyncStatusCall.path)
}
inline void SyncStatusCall::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:SyncStatusCall.path)
}
inline void SyncStatusCall::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SyncStatusCall.path)
}
inline ::std::string* SyncStatusCall::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:SyncStatusCall.path)
  return path_;
}
inline ::std::string* SyncStatusCall::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SyncStatusCall::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:SyncStatusCall.path)
}

// -------------------------------------------------------------------

// VersionHistoryCall

// required string path = 1;
inline bool VersionHistoryCall::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VersionHistoryCall::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VersionHistoryCall::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VersionHistoryCall::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& VersionHistoryCall::path() const {
  // @@protoc_insertion_point(field_get:VersionHistoryCall.path)
  return *path_;
}
inline void VersionHistoryCall::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:VersionHistoryCall.path)
}
inline void VersionHistoryCall::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:VersionHistoryCall.path)
}
inline void VersionHistoryCall::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:VersionHistoryCall.path)
}
inline ::std::string* VersionHistoryCall::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:VersionHistoryCall.path)
  return path_;
}
inline ::std::string* VersionHistoryCall::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VersionHistoryCall::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:VersionHistoryCall.path)
}

// -------------------------------------------------------------------

// ConflictResolutionCall

// required string path = 1;
inline bool ConflictResolutionCall::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConflictResolutionCall::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConflictResolutionCall::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConflictResolutionCall::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& ConflictResolutionCall::path() const {
  // @@protoc_insertion_point(field_get:ConflictResolutionCall.path)
  return *path_;
}
inline void ConflictResolutionCall::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:ConflictResolutionCall.path)
}
inline void ConflictResolutionCall::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:ConflictResolutionCall.path)
}
inline void ConflictResolutionCall::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ConflictResolutionCall.path)
}
inline ::std::string* ConflictResolutionCall::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ConflictResolutionCall.path)
  return path_;
}
inline ::std::string* ConflictResolutionCall::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ConflictResolutionCall::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ConflictResolutionCall.path)
}

// -------------------------------------------------------------------

// GetPathStatusCall

// required string path = 1;
inline bool GetPathStatusCall::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetPathStatusCall::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetPathStatusCall::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetPathStatusCall::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& GetPathStatusCall::path() const {
  // @@protoc_insertion_point(field_get:GetPathStatusCall.path)
  return *path_;
}
inline void GetPathStatusCall::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:GetPathStatusCall.path)
}
inline void GetPathStatusCall::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:GetPathStatusCall.path)
}
inline void GetPathStatusCall::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GetPathStatusCall.path)
}
inline ::std::string* GetPathStatusCall::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GetPathStatusCall.path)
  return path_;
}
inline ::std::string* GetPathStatusCall::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetPathStatusCall::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GetPathStatusCall.path)
}

// -------------------------------------------------------------------

// ShellextNotification

// required .ShellextNotification.Type type = 1;
inline bool ShellextNotification::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShellextNotification::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShellextNotification::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShellextNotification::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::ShellextNotification_Type ShellextNotification::type() const {
  // @@protoc_insertion_point(field_get:ShellextNotification.type)
  return static_cast< ::ShellextNotification_Type >(type_);
}
inline void ShellextNotification::set_type(::ShellextNotification_Type value) {
  assert(::ShellextNotification_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ShellextNotification.type)
}

// optional .RootAnchorNotification root_anchor = 2;
inline bool ShellextNotification::has_root_anchor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShellextNotification::set_has_root_anchor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShellextNotification::clear_has_root_anchor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShellextNotification::clear_root_anchor() {
  if (root_anchor_ != NULL) root_anchor_->::RootAnchorNotification::Clear();
  clear_has_root_anchor();
}
inline const ::RootAnchorNotification& ShellextNotification::root_anchor() const {
  // @@protoc_insertion_point(field_get:ShellextNotification.root_anchor)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return root_anchor_ != NULL ? *root_anchor_ : *default_instance().root_anchor_;
#else
  return root_anchor_ != NULL ? *root_anchor_ : *default_instance_->root_anchor_;
#endif
}
inline ::RootAnchorNotification* ShellextNotification::mutable_root_anchor() {
  set_has_root_anchor();
  if (root_anchor_ == NULL) root_anchor_ = new ::RootAnchorNotification;
  // @@protoc_insertion_point(field_mutable:ShellextNotification.root_anchor)
  return root_anchor_;
}
inline ::RootAnchorNotification* ShellextNotification::release_root_anchor() {
  clear_has_root_anchor();
  ::RootAnchorNotification* temp = root_anchor_;
  root_anchor_ = NULL;
  return temp;
}
inline void ShellextNotification::set_allocated_root_anchor(::RootAnchorNotification* root_anchor) {
  delete root_anchor_;
  root_anchor_ = root_anchor;
  if (root_anchor) {
    set_has_root_anchor();
  } else {
    clear_has_root_anchor();
  }
  // @@protoc_insertion_point(field_set_allocated:ShellextNotification.root_anchor)
}

// optional .PathStatusNotification path_status = 3;
inline bool ShellextNotification::has_path_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShellextNotification::set_has_path_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShellextNotification::clear_has_path_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShellextNotification::clear_path_status() {
  if (path_status_ != NULL) path_status_->::PathStatusNotification::Clear();
  clear_has_path_status();
}
inline const ::PathStatusNotification& ShellextNotification::path_status() const {
  // @@protoc_insertion_point(field_get:ShellextNotification.path_status)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return path_status_ != NULL ? *path_status_ : *default_instance().path_status_;
#else
  return path_status_ != NULL ? *path_status_ : *default_instance_->path_status_;
#endif
}
inline ::PathStatusNotification* ShellextNotification::mutable_path_status() {
  set_has_path_status();
  if (path_status_ == NULL) path_status_ = new ::PathStatusNotification;
  // @@protoc_insertion_point(field_mutable:ShellextNotification.path_status)
  return path_status_;
}
inline ::PathStatusNotification* ShellextNotification::release_path_status() {
  clear_has_path_status();
  ::PathStatusNotification* temp = path_status_;
  path_status_ = NULL;
  return temp;
}
inline void ShellextNotification::set_allocated_path_status(::PathStatusNotification* path_status) {
  delete path_status_;
  path_status_ = path_status;
  if (path_status) {
    set_has_path_status();
  } else {
    clear_has_path_status();
  }
  // @@protoc_insertion_point(field_set_allocated:ShellextNotification.path_status)
}

// optional .LinkSharingEnabled link_sharing_enabled = 4;
inline bool ShellextNotification::has_link_sharing_enabled() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShellextNotification::set_has_link_sharing_enabled() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShellextNotification::clear_has_link_sharing_enabled() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShellextNotification::clear_link_sharing_enabled() {
  if (link_sharing_enabled_ != NULL) link_sharing_enabled_->::LinkSharingEnabled::Clear();
  clear_has_link_sharing_enabled();
}
inline const ::LinkSharingEnabled& ShellextNotification::link_sharing_enabled() const {
  // @@protoc_insertion_point(field_get:ShellextNotification.link_sharing_enabled)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return link_sharing_enabled_ != NULL ? *link_sharing_enabled_ : *default_instance().link_sharing_enabled_;
#else
  return link_sharing_enabled_ != NULL ? *link_sharing_enabled_ : *default_instance_->link_sharing_enabled_;
#endif
}
inline ::LinkSharingEnabled* ShellextNotification::mutable_link_sharing_enabled() {
  set_has_link_sharing_enabled();
  if (link_sharing_enabled_ == NULL) link_sharing_enabled_ = new ::LinkSharingEnabled;
  // @@protoc_insertion_point(field_mutable:ShellextNotification.link_sharing_enabled)
  return link_sharing_enabled_;
}
inline ::LinkSharingEnabled* ShellextNotification::release_link_sharing_enabled() {
  clear_has_link_sharing_enabled();
  ::LinkSharingEnabled* temp = link_sharing_enabled_;
  link_sharing_enabled_ = NULL;
  return temp;
}
inline void ShellextNotification::set_allocated_link_sharing_enabled(::LinkSharingEnabled* link_sharing_enabled) {
  delete link_sharing_enabled_;
  link_sharing_enabled_ = link_sharing_enabled;
  if (link_sharing_enabled) {
    set_has_link_sharing_enabled();
  } else {
    clear_has_link_sharing_enabled();
  }
  // @@protoc_insertion_point(field_set_allocated:ShellextNotification.link_sharing_enabled)
}

// -------------------------------------------------------------------

// RootAnchorNotification

// required string path = 1;
inline bool RootAnchorNotification::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RootAnchorNotification::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RootAnchorNotification::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RootAnchorNotification::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& RootAnchorNotification::path() const {
  // @@protoc_insertion_point(field_get:RootAnchorNotification.path)
  return *path_;
}
inline void RootAnchorNotification::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:RootAnchorNotification.path)
}
inline void RootAnchorNotification::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:RootAnchorNotification.path)
}
inline void RootAnchorNotification::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RootAnchorNotification.path)
}
inline ::std::string* RootAnchorNotification::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RootAnchorNotification.path)
  return path_;
}
inline ::std::string* RootAnchorNotification::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RootAnchorNotification::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RootAnchorNotification.path)
}

// optional string user = 2;
inline bool RootAnchorNotification::has_user() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RootAnchorNotification::set_has_user() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RootAnchorNotification::clear_has_user() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RootAnchorNotification::clear_user() {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& RootAnchorNotification::user() const {
  // @@protoc_insertion_point(field_get:RootAnchorNotification.user)
  return *user_;
}
inline void RootAnchorNotification::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set:RootAnchorNotification.user)
}
inline void RootAnchorNotification::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set_char:RootAnchorNotification.user)
}
inline void RootAnchorNotification::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RootAnchorNotification.user)
}
inline ::std::string* RootAnchorNotification::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RootAnchorNotification.user)
  return user_;
}
inline ::std::string* RootAnchorNotification::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RootAnchorNotification::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RootAnchorNotification.user)
}

// -------------------------------------------------------------------

// PathStatusNotification

// required string path = 1;
inline bool PathStatusNotification::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PathStatusNotification::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PathStatusNotification::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PathStatusNotification::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& PathStatusNotification::path() const {
  // @@protoc_insertion_point(field_get:PathStatusNotification.path)
  return *path_;
}
inline void PathStatusNotification::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:PathStatusNotification.path)
}
inline void PathStatusNotification::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:PathStatusNotification.path)
}
inline void PathStatusNotification::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PathStatusNotification.path)
}
inline ::std::string* PathStatusNotification::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PathStatusNotification.path)
  return path_;
}
inline ::std::string* PathStatusNotification::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PathStatusNotification::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PathStatusNotification.path)
}

// required .PBPathStatus status = 2;
inline bool PathStatusNotification::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PathStatusNotification::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PathStatusNotification::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PathStatusNotification::clear_status() {
  if (status_ != NULL) status_->::PBPathStatus::Clear();
  clear_has_status();
}
inline const ::PBPathStatus& PathStatusNotification::status() const {
  // @@protoc_insertion_point(field_get:PathStatusNotification.status)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return status_ != NULL ? *status_ : *default_instance().status_;
#else
  return status_ != NULL ? *status_ : *default_instance_->status_;
#endif
}
inline ::PBPathStatus* PathStatusNotification::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::PBPathStatus;
  // @@protoc_insertion_point(field_mutable:PathStatusNotification.status)
  return status_;
}
inline ::PBPathStatus* PathStatusNotification::release_status() {
  clear_has_status();
  ::PBPathStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void PathStatusNotification::set_allocated_status(::PBPathStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
  // @@protoc_insertion_point(field_set_allocated:PathStatusNotification.status)
}

// -------------------------------------------------------------------

// LinkSharingEnabled

// required bool is_link_sharing_enabled = 1;
inline bool LinkSharingEnabled::has_is_link_sharing_enabled() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LinkSharingEnabled::set_has_is_link_sharing_enabled() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LinkSharingEnabled::clear_has_is_link_sharing_enabled() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LinkSharingEnabled::clear_is_link_sharing_enabled() {
  is_link_sharing_enabled_ = false;
  clear_has_is_link_sharing_enabled();
}
inline bool LinkSharingEnabled::is_link_sharing_enabled() const {
  // @@protoc_insertion_point(field_get:LinkSharingEnabled.is_link_sharing_enabled)
  return is_link_sharing_enabled_;
}
inline void LinkSharingEnabled::set_is_link_sharing_enabled(bool value) {
  set_has_is_link_sharing_enabled();
  is_link_sharing_enabled_ = value;
  // @@protoc_insertion_point(field_set:LinkSharingEnabled.is_link_sharing_enabled)
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_shellext_2eproto__INCLUDED
