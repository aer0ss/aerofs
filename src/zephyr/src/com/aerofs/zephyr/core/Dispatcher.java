/*
 * Copyright (c) Air Computing Inc., 2012.
 */

package com.aerofs.zephyr.core;

import com.aerofs.lib.Util;
import org.apache.log4j.Logger;

import java.io.IOException;
import java.nio.channels.ClosedChannelException;
import java.nio.channels.SelectableChannel;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.util.Iterator;

import static com.aerofs.zephyr.core.ZUtil.closeChannel;
import static com.aerofs.zephyr.core.ZUtil.istdesc;
import static com.aerofs.zephyr.core.ZUtil.rdydesc;
import static com.aerofs.zephyr.core.ZUtil.subInterest;

/**
 * NOTES: - Reduce copying - Use Futures if possible - May not be able to use threads because we use
 * our own thread scheduling mechanisms - Close out all sockets if/when there are errors - How do I
 * generalize this _not_ to copy? - handlers have to know dispatcher - what are the implications of
 * having access to everyone's selection keys? - interesting: _idToKey is very zephyr-specific; how
 * do I generalize this to deal with threadpools? - should I use pb? - zephyr should have a
 * method/command for the controlling application to removeEndpoint the connection - callers of
 * message creation functions should handle BufferOverflowException - need to be able to send in the
 * channels on which I want to wait, etc. for testing - do all IoEventHandlers need a terminate
 * function?
 */
public class Dispatcher implements Runnable
{
    public void init_()
            throws IOException
    {
        try {
            _sel = Selector.open();
            _inited = true;
        } catch (IOException e) {
            l.fatal("zd: sel: e on open:" + e);
            closeSelector();
            throw e;
        }
    }

    @Override
    public final void run()
    {
        assert _inited : ("zd: uninited");

        if (_started) return;
        _started = true;

        l.info("zd: starting");

        try {
            while (!_stop) {
                int ready;

                try {
                    ready = _sel.select();
                } catch (IOException e) {
                    l.fatal("zd: sel: e on select:" + e);
                    throw e;
                }

                if (_stop) return; // check, because you may have been woken up to stop

                // FIXME: is the order of operations (NIO vs. non-NIO) important?

                l.debug("zd: handling ready keys:" + ready);

                if (ready > 0) {
                    Iterator<SelectionKey> rkit = _sel.selectedKeys().iterator();
                    while (rkit.hasNext()) {
                        SelectionKey key = rkit.next();
                        rkit.remove();
                        handleKeyReady(key);
                    }
                }

                processNonNioEvents();
            }
        } catch (FatalIOEventHandlerException e) {
            l.fatal("zd: terminating: fioehex");
        } catch (IOException e) {
            l.fatal("zd: terminating: ioex");
        } finally {
            l.info("zd: terminating");
            closeSelector();
        }
    }

    public final void stop()
    {
        _stop = true;
        _sel.wakeup(); // wake up the selector so that it stops

        l.info("zd: received stop");
    }

    public final SelectionKey register(SelectableChannel c, IIOEventHandler ioe, int... ists)
            throws ClosedChannelException
    {
        int istmask = ZUtil.getInterestMask(ists);
        return c.register(_sel, istmask, ioe);
    }

    private void handleKeyReady(SelectionKey k)
            throws FatalIOEventHandlerException
    {
        // any assert on validity may be false, because a prior operation (for
        // example, attempting to write a response within the read) may have invalidated
        // the key
        // oh...I now understand why there was a check inside Hitchen's NIO code
        // for checking validity prior to a write

        // NOTE: all keys are deregistered prior to their handlers being called
        try {
            //
            // handle io events generated by the selector
            //

            l.debug("zd: key:" + k + " ists:" + istdesc(k) + " rdy:" + rdydesc(k) + " att:" +
                    k.attachment().toString());

            if (k.isValid() && k.isAcceptable()) {
                subInterest(k, SelectionKey.OP_ACCEPT);
                IIOEventHandler ioe = assertAndGetAttachment(k);
                ioe.handleAcceptReady_(k);
            }

            if (k.isValid() && k.isConnectable()) {
                subInterest(k, SelectionKey.OP_CONNECT);
                IIOEventHandler ioe = assertAndGetAttachment(k);
                ioe.handleConnectReady_(k);
            }

            if (k.isValid() && k.isReadable()) {
                subInterest(k, SelectionKey.OP_READ);
                IIOEventHandler ioe = assertAndGetAttachment(k);
                ioe.handleReadReady_(k);
            }

            if (k.isValid() && k.isWritable()) {
                subInterest(k, SelectionKey.OP_WRITE);
                IIOEventHandler ioe = assertAndGetAttachment(k);
                ioe.handleWriteReady_(k);
            }

            //
            // if cancellation occurred, inform the key attachment that their
            // associated key was cancelled
            //
            // NOTE: do not assume that key cancellations cannot occur at the
            // beginning of this block. since selectors can be closed from any
            // thread, their associated keys can be cancelled at any time
            //

            if (!k.isValid()) {
                IIOEventHandler ioe = assertAndGetAttachment(k);
                ioe.handleKeyCancelled_(k);
            }
        } catch (FatalIOEventHandlerException e) {
            l.fatal("zd: k:" + k + ": fataled during handle");
            throw e;
        } catch (Exception e) {
            l.error("zd: k:" + k + ": unexpected err during handle:" + e);
            e.printStackTrace();
            closeChannel(k.channel()); // implicitly closes keys for this channel
        }
    }

    /**
     * override to process other events in the context of the NIO dispatcher thread
     */
    protected void processNonNioEvents()
    {
        // noop
    }

    private void closeSelector()
    {
        try {
            if (_sel != null) _sel.close();
            l.debug("zd: sel: close");
        } catch (IOException e) {
            l.warn("zd: sel: e on close:" + e);
        }
    }

    private static IIOEventHandler assertAndGetAttachment(SelectionKey k)
    {
        IIOEventHandler ioe = (IIOEventHandler) k.attachment();
        assert ioe != null : ("zd: k:" + k + ": null att");
        return ioe;
    }

    //
    // members
    //

    protected Selector _sel = null;

    private volatile boolean _inited = false;
    private volatile boolean _started = false;
    private volatile boolean _stop = false;

    protected static Logger l = Util.l(Dispatcher.class);
}
