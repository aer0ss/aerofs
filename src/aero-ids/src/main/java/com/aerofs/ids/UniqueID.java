package com.aerofs.ids;

import java.io.StringWriter;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.UUID;

import com.google.common.io.BaseEncoding;

import javax.annotation.Nonnull;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkState;

// globally unique ids.
//
// templatizing this class is not that easy because of static member ZERO here
//
public class UniqueID implements Comparable<UniqueID>, IBFKey
{
    private final byte[] _bs;

    private static final BaseEncoding HEX = BaseEncoding.base16().lowerCase();

    public static final int LENGTH = 16;

    /**
     * UniqueID obtained from generate() are UUID version 4 as specified by RFC 4122
     *
     * To distinguish different subtypes of unique ids we sometimes change the value of the version
     * nibble (4 most significant bits of the 7th byte of the id).
     * The following constants help manipulating the 4 bits in question.
     */
    public static final int VERSION_BYTE = 6;
    public static final int VERSION_MASK = 0xf0;
    public static final int VERSION_SHIFT = 4;

    public static int getVersionNibble(byte[] bs)
    {
        assert bs.length == LENGTH;
        return (bs[VERSION_BYTE] & VERSION_MASK) >> VERSION_SHIFT;
    }

    public static void setVersionNibble(byte[] bs, int value)
    {
        assert bs.length == LENGTH;
        assert value >= 0 && value < 16;
        bs[VERSION_BYTE] = (byte)((bs[VERSION_BYTE] & ~VERSION_MASK) | (value << VERSION_SHIFT));
    }

    protected int getVersionNibble()
    {
        return getVersionNibble(_bs);
    }

    public static final UniqueID ZERO = new UniqueID(new byte[LENGTH]);

    // compareTo is signed...
    public static final UniqueID LOWEST = new UniqueID(new byte[] {
            Byte.MIN_VALUE, Byte.MIN_VALUE, Byte.MIN_VALUE, Byte.MIN_VALUE,
            Byte.MIN_VALUE, Byte.MIN_VALUE, Byte.MIN_VALUE, Byte.MIN_VALUE,
            Byte.MIN_VALUE, Byte.MIN_VALUE, Byte.MIN_VALUE, Byte.MIN_VALUE,
            Byte.MIN_VALUE, Byte.MIN_VALUE, Byte.MIN_VALUE, Byte.MIN_VALUE,
    });

    private static byte[] hexDecodeID(String str, int start, int end) throws ExInvalidID
    {
        byte[] bs;
        try {
            bs = HEX.decode(str.substring(start, end));
        } catch (IllegalArgumentException e) { throw new ExInvalidID(e); }
        if (bs.length != LENGTH) throw new ExInvalidID();
        return bs;
    }

    public static UniqueID generate()
    {
        UUID uuid = UUID.randomUUID();

        long v = uuid.getLeastSignificantBits();
        byte [] bs = new byte[LENGTH];
        for (int i = 0; i < 8; i++) {
            bs[LENGTH - 1 - i] = (byte)(v >>> (i * 8));
        }

        v = uuid.getMostSignificantBits();
        for (int i = 0; i < 8; i++) {
            bs[LENGTH - 8 - 1 - i] = (byte)(v >>> (i * 8));
        }

        /**
         * The output of this code should be a version 4 UUID as specified by RFC 4122
         *
         * version 4 UUID as hex string: xxxxxxxxxxxxMxxxNxxxxxxxxxxxxxxx
         * invariant 1: M = 4
         * invariant 2: N in {8, 9, a, b}
         *
         * We rely on some of the 6 fixed bits specified by said RFC to distinguish various subtypes
         * of unique ids so we assert that they are set as expected.
         */
        checkState(getVersionNibble(bs) == 4);
        checkState((bs[VERSION_BYTE + 2] & 0xc0) == 0x80);
        return new UniqueID(bs);
    }

    public UniqueID(UniqueID id)
    {
        this(id._bs);
    }

    /**
     *  Convert a string representation of a UniqueID, generated by UniqueID.toStringFormal, to a
     *  UniqueID.
     */
    public UniqueID(String str) throws ExInvalidID
    {
        this(str, 0, str.length());
    }

    /**
     *  Convert a string representation of a UniqueID, generated by UniqueID.toStringFormal, to a
     *  UniqueID. {@code start} and {@code end} specifies the start and end point of the substring
     *  to be parse in {@code str}.
     */
    public UniqueID(String str, int start, int end) throws ExInvalidID
    {
        this(hexDecodeID(str, start, end));
    }

    /**
     * Wrap the given byte array (NB: it is NOT copied)
     */
    public UniqueID(byte[] bs)
    {
        checkArgument(bs.length == LENGTH);
        _bs = bs;
    }

    @Override
    public String toString()
    {
        return toStringImpl('<', 3, '>');
    }

    protected String toStringImpl(char pre, int nbytes, char post)
    {
        StringWriter w = new StringWriter(2 + nbytes * 2);
        w.write(pre);
        w.write(HEX.encode(_bs, 0, nbytes));
        w.write(post);
        return w.toString();
    }

    public String toStringFormal()
    {
        return HEX.encode(_bs, 0, LENGTH);
    }

    public static UniqueID fromStringFormal(String hex) throws ExInvalidID
    {
        return new UniqueID(hex, 0, hex.length());
    }

    @Override
    public ByteBuffer getReadOnlyByteBuffer()
    {
        return ByteBuffer.wrap(_bs).asReadOnlyBuffer();
    }

    /**
     * IMPORTANT: Do not modify the returned byte array directly but work on a copy instead.
     */
    public byte[] getBytes()
    {
        return _bs;
    }

    @Override
    public boolean equals(Object o)
    {
        return this == o
                || (o != null && o instanceof UniqueID && Arrays.equals(_bs, ((UniqueID)o)._bs));
    }

    @Override
    public int hashCode()
    {
        // UUIDs are pseudo-random numbers so selecting any 32 bits gives as good a hash function
        // as pretty much any non-cryptographically secure byte array hash
        // NB: for this to be true we should not select bits from the version nibble
        return getReadOnlyByteBuffer().getInt(0);
    }

    @Override
    public int compareTo(@Nonnull UniqueID id)
    {
        final byte [] bs0 = _bs;
        final byte [] bs1 = id._bs;
        checkArgument(bs0.length == LENGTH && bs1.length == LENGTH);

        for (int i = LENGTH - 1; i >= 0; i--) {
            int diff = bs0[i] - bs1[i];
            if (diff != 0) return diff;
        }
        return 0;
    }
}
