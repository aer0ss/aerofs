package ritual;
option java_package = "com.aerofs.proto";
option optimize_for = LITE_RUNTIME; // remove reflection

import "common.proto";
import "files.proto";
import "path_status.proto";

service RitualService {

    // Sets the message type used in case of errors
    rpc __error__(Void) returns(PBException);

    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Object management (abstracting away storage backend)

    // Return the attribute of a given file or folder.
    // Throw NOT_FOUND if the object doesn't exist
    rpc GetObjectAttributes(GetObjectAttributesCall) returns(GetObjectAttributesReply);

    // Return the list of children names as long with their attributes for a given parent folder.
    // Throw NOT_FOUND if the parent path doesn't exist
    // Throw NOT_DIR if the parent path is not a folder
    rpc GetChildrenAttributes(GetChildrenAttributesCall) returns(GetChildrenAttributesReply);

    rpc CreateObject(CreateObjectCall) returns(Void);
    rpc DeleteObject(DeleteObjectCall) returns(Void);
    rpc MoveObject(MoveObjectCall) returns(Void);

    // import the content of a local file (useful for S3 and other non-transparent backends)
    rpc ImportFile(ImportFileCall) returns(Void);

    // Export a file to a local path
    rpc ExportFile(ExportFileCall) returns(ExportFileReply);


    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Sharing

    // Create a new "external" shared folder and link it to a location on the filesystem
    // NB: will throw when called on a client that does not use LINKED storage
    rpc LinkRoot(LinkRootCall) returns(LinkRootReply);

    // Link a pending root to a physical location in the filesystem
    // NB: will throw when called on a client that does not use LINKED storage
    rpc LinkPendingRoot(LinkPendingRootCall) returns(Void);

    // List accessible shared folders that have yet to be linked to a physical path
    rpc ListPendingRoots(Void) returns(ListPendingRootsReply);

    // Share a specified folder, and optionally specify the list of users and their roles to be
    // added the the shared folder. The user that calls this method is always added as an owner of
    // the shared folder. If the folder is already shared, the method only adds the users specified
    // in the list. Roles of these users will be overwritten if they already exist.
    //
    rpc ShareFolder(ShareFolderCall) returns(Void);

    // Unshare a shared folder and remove all the users from the folder. Nop if the folder is
    // already unshared.
    rpc UnshareFolder(UnshareFolderCall) returns(Void);

    rpc ListSharedFolders(Void) returns(ListSharedFoldersReply);

    rpc ListSharedFolderInvitations(Void) returns(ListSharedFolderInvitationsReply);

    // Join an existing remote shared folder from this device.
    // Throw ALREADY_EXIST if the specified path already exists.
    rpc JoinSharedFolder(JoinSharedFolderCall) returns(Void);

    rpc LeaveSharedFolder(LeaveSharedFolderCall) returns(Void);


    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Expulsion (aka Selective Sync)

    // Excluding a folder deletes the folder and its content from the local system and stops
    // receiving updates from other peers for this folder. Note that excluding a folder is a local
    // operation and does not affect other peers. This method is a nop if the folder is already
    // excluded.
    rpc ExcludeFolder(ExcludeFolderCall) returns(Void);

    // Undo folder exclusion. This method is a nop if the folder is already included.
    rpc IncludeFolder(IncludeFolderCall) returns(Void);

    // Return a list of excluded folders
    rpc ListExcludedFolders(Void) returns(ListExcludedFoldersReply);


    ///////////////////////////////////////////////////////////////////////////////////////////////
    // ACL

    // Get the list of users and their roles for a shared folder. The local user is always included
    // in the list.
    rpc GetACL(GetACLCall) returns(GetACLReply);

    // Set users and their roles for a shared folder.
    // Throw NOT_SHARED if called on a unshared folder
    rpc UpdateACL(UpdateACLCall) returns(Void);

    // Delete users from a shared folder.
    // Throw NOT_SHARED if called on a unshared folder
    rpc DeleteACL(DeleteACLCall) returns(Void);


    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Syncing control

    // Pause syncing activities, no matter how many times ResumeSyncing has been called before.
    rpc PauseSyncing(Void) returns(Void);

    // Resume syncing activities, no matter how many times PauseSyncing has been called before.
    rpc ResumeSyncing(Void) returns(Void);


    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Activity / Status informations

    // Get the list of recent activities. This method may block for an extended period of time when
    // fetching information from remote servers.
    rpc GetActivities(GetActivitiesCall) returns(GetActivitiesReply);

    // Get detailed sync status for a file
    rpc GetSyncStatus(GetSyncStatusCall) returns(GetSyncStatusReply);

    // Get status summary (shellext-ready) for a list of files
    rpc GetPathStatus(GetPathStatusCall) returns(GetPathStatusReply);


    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Revision History

    rpc ListRevChildren(ListRevChildrenCall) returns(ListRevChildrenReply);

    rpc ListRevHistory(ListRevHistoryCall) returns(ListRevHistoryReply);

    rpc ExportRevision(ExportRevisionCall) returns(ExportRevisionReply);

    rpc DeleteRevision(DeleteRevisionCall) returns(Void);


    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Conflict Resolution

    rpc ListConflicts(Void) returns(ListConflictsReply);

    rpc ExportConflict(ExportConflictCall) returns(ExportConflictReply);

    rpc DeleteConflict(DeleteConflictCall) returns(Void);


    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Commands

    rpc InvalidateDeviceNameCache(Void) returns(Void);

    rpc InvalidateUserNameCache(Void) returns(Void);


    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Misc

    // Test if the daemon is responsive
    rpc Heartbeat(Void) returns(Void);

    // Moves AeroFS folder to a new location
    rpc Relocate(RelocateCall) returns(Void);

    rpc ReloadConfig(Void) returns(Void);

    // Shutdown the Daemon process. It is used by AeroFS GUI and CLI when quitting.
    rpc Shutdown(Void) returns(Void);

    rpc CreateSeedFile(CreateSeedFileCall) returns(CreateSeedFileReply);


    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Public/Private separation line
    // Above: public API, considered fit for an eventual public release
    // Below: private API, for internal use only or otherwise unfit for public release (e.g. WIP)
    //
    // TODO: Split logically-related calls into separate services?
    // TODO: Move the private API to a separate proto file
    ///////////////////////////////////////////////////////////////////////////////////////////////


    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Misc internal methods

    rpc TransportPing(TransportPingCall) returns(TransportPingReply);
    rpc TransportFlood(TransportFloodCall) returns(Void);
    rpc TransportFloodQuery(TransportFloodQueryCall) returns(TransportFloodQueryReply);

    // Dump daemon statistics (for internal use only)
    rpc DumpStats(DumpStatsCall) returns(DumpStatsReply);


    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Methods for debugging purposes only.

    // Log stack traces of all the threads. See LOG_THREADS in cmd.proto for detail.
    rpc LogThreads(Void) returns(Void);


    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Methods for testing purposes only.

    // Return SOID of the object. Throw NOT_FOUND if the object doesn't exists
    rpc TestGetObjectIdentifier(TestGetObjectIdentifierCall) returns(TestGetObjectIdentifierReply);

    // Stop the linker. No-op if the linker is paused.
    rpc TestPauseLinker(Void) returns(Void);

    // Start the linker. No-op if the linker is running.
    rpc TestResumeLinker(Void) returns(Void);

    // Send a defect log to SV
    rpc TestLogSendDefect(Void) returns(Void);

    // Multiuser systems only: join a root store
    rpc TestMultiuserJoinRootStore(TestMultiuserJoinRootStoreCall) returns(Void);
}

message GetObjectAttributesCall {
    required string user = 1;
    required PBPath path = 2;
}

message GetObjectAttributesReply {
    required PBObjectAttributes object_attributes = 1;
}

message GetChildrenAttributesCall {
    required string user = 1;
    required PBPath path = 2;
}

message GetChildrenAttributesReply {
    repeated string children_name = 1;
    repeated PBObjectAttributes children_attributes = 2;
}

message PBObjectAttributes {
    enum Type {
        FILE = 0;
        FOLDER = 1;
        SHARED_FOLDER = 2;
    }
    required Type type = 1;

    // An object has one or more branches iff it is a file and it has been downloaded locally.
    repeated PBBranch branch = 2;

    required bool excluded = 3;
}

/**
 * Each Branch object describes the attributes of a branch of a file. Files that
 * haven't been downloaded have zero branches. Otherwise, they must have
 * as least a master branch.
 */
message PBBranch {
    // the KIndex of the branch this content attribute refers to. The KIndex of
    // master branches is always KIndex.MASTER. The value of the field can be
    // converted to a {@link com.aci.aerofs.lib.id.KIndex} object by using
    // <code>new KIndex(kidx)</code>
    required uint32 kidx = 1;

    // content length. see ContentAttr.length() for details
    required uint64 length = 2;

    // last modification of the conflict file
    required uint64 mtime = 3;
}

message CreateObjectCall {
    required PBPath path = 1;
    required bool dir = 2;
}

message DeleteObjectCall {
    required PBPath path = 1;
}

message MoveObjectCall {
    required PBPath pathFrom = 1;
    required PBPath pathTo = 2;
}

message DumpStatsCall {
    required PBDumpStat template = 1;
}

message DumpStatsReply {
    required PBDumpStat stats = 1;
}

message GetExcludedFoldersCall {
    required string user = 1;
    required PBPath path = 2;
}

message GetExcludedFoldersReply {
    // name of excluded folders
    repeated string name = 1;
}

message LinkRootCall {
    required string path = 1;
}

message LinkRootReply {
    required bytes sid = 1;
}

message LinkPendingRootCall {
    required string path = 1;
    required bytes sid = 2;
}

message ListPendingRootsReply {
    message PendingRoot {
        required bytes sid = 1;
        required string name = 2;
    }

    repeated PendingRoot root = 1;
}

message ShareFolderCall {
    required PBPath path = 1;
    repeated PBSubjectRolePair subject_role = 2;
    required string note = 3;
}

message UnshareFolderCall {
    required string user = 1;
    required PBPath path = 2;
}

message ListSharedFolderInvitationsReply {
    repeated PBFolderInvitation invitation = 1;
}

message JoinSharedFolderCall {
    required bytes id = 1;
}

message LeaveSharedFolderCall {
    required PBPath path = 1;
}

message ListSharedFoldersReply {
    message SharedFolder {
        required PBPath path = 1;
        required string name = 2;
    }

    repeated SharedFolder shared_folder = 1;
}

message ExcludeFolderCall {
    required PBPath path = 1;
}

message IncludeFolderCall {
    required PBPath path = 1;
}

message ListExcludedFoldersReply {
    repeated PBPath path = 1;
}

message ImportFileCall {
    required PBPath destination = 1;
    required string source = 2;
}

message ExportFileCall {
    required PBPath source = 1;
}

message ExportFileReply {
    // The daemon exports the file to a temporary file on the local filesystem. This field
    // specifies the path to the temporary file.
    // This is necessary to avoid privilege escalation through the daemon.
    required string dest = 1;
}

message ListConflictsReply {
    message ConflictedPath {
        required PBPath path = 1;
        required int32 branch_count = 2;
    }

    // list of path with conflict branches
    repeated ConflictedPath conflict = 1;
}

message ExportConflictCall {
    required PBPath path = 1;
    required int32 kidx = 2;
}

message ExportConflictReply {
    // The daemon exports the file to a temporary file on the local filesystem. This field
    // specifies the path to the temporary file.
    // This is necessary to avoid privilege escalation through the daemon.
    required string dest = 1;
}

message DeleteConflictCall {
    required PBPath path = 1;
    required int32 kidx = 2;
}

message GetACLCall {
    required string user = 1;
    required PBPath path = 2;
}

message GetACLReply {
    repeated PBSubjectRolePair subject_role = 1;
}

message UpdateACLCall {
    required string user = 1;
    required PBPath path = 2;
    required string subject = 3;
    required PBRole role = 4;
}

message DeleteACLCall {
    required string user = 1;
    required PBPath path = 2;
    required string subject = 3;
}

message RelocateCall {
    required string absolute_path = 1;
    optional bytes store_id = 2;
}

message GetActivitiesCall {
    // Whether to return messages in brief
    required bool brief = 1;

    // maximum number of activities to be returned for one page. see page_token for detail.
    required uint32 max_results = 2;

    // assuming the client can't display all the activities in a single page, this field specifies
    // which page to return. when absent, the first page will be returned.
    optional uint64 page_token = 3;
}

message GetActivitiesReply {

    enum ActivityType {
        CREATION = 0x1;
        MODIFICATION = 0x2;
        MOVEMENT = 0x4;
        DELETION = 0x8;
    }

    message PBActivity {
        // one or more ActivityTypes combined with OR
        required uint32 type = 1;

        // the timestamp of the activity
        required uint64 time = 2;

        required string message = 3;

        // the current path of the file being affected. absent if the activity is not file
        // operations or the file has been deleted.
        optional PBPath path = 4;
    }

    repeated PBActivity activity = 1;

    // Whether some device detail can't be retrieved from the server due to Internet connectivity
    // problems. Inaccurate information will be shown (e.g. "unknown devices") in the returned
    // messages.
    required bool has_unresolved_devices = 2;

    // The page token used by GetActivitiesCall to retrieve the next result page. Absent if the
    // current page is the last one.
    optional uint64 page_token = 3;
}

message ListRevChildrenCall {
    required PBPath path = 1;
}

message ListRevChildrenReply {
    repeated PBRevChild child = 1;
}

message ListRevHistoryCall {
    required PBPath path = 1;
}

message ListRevHistoryReply {
    repeated PBRevision revision = 1;
}

message ExportRevisionCall {
    required PBPath path = 1;
    required bytes index = 2;
}

message ExportRevisionReply {
    // The daemon exports the file to a temporary file on the local filesystem. This field
    // specifies the path to the temporary file.
    // This is necessary to avoid privilege escalation through the daemon.
    required string dest = 1;
}

message DeleteRevisionCall {
    required PBPath path = 1;

    // if an index is supplied, delete a specific revision of the given file
    // if no index is supplied, delete all revisions under the given directory
    optional bytes index = 2;
}

message GetSyncStatusCall {
    required PBPath path = 1;
}

message GetSyncStatusReply {
    // no sync status should be shown to the user when the server is know to be down
    required bool is_server_up = 1;
    repeated PBSyncStatus status = 2;
}

message GetPathStatusCall {
    repeated PBPath path = 1;
}

message GetPathStatusReply {
    repeated PBPathStatus status = 2;
}

message CreateSeedFileCall {
    required bytes store_id = 1;
}

message CreateSeedFileReply {
    required string path = 1;
}


message TransportPingCall {
    // see IEOTransportPing for details
    required bytes device_id = 1;
    required uint32 seq_prev = 2;
    required uint32 seq_next = 3;
    required bool force_next = 4;
    required bool ignore_offline = 5;
}

message TransportPingReply {
    optional uint64 rtt = 1;
}

message TransportFloodCall {
    required bytes device_id = 1;
    required bool send = 2;
    required uint32 seq_start = 3;
    required uint32 seq_end = 4;
    required uint64 duration = 5;
    optional string sname = 6;      // required if !send
}

message TransportFloodQueryCall {
    required bytes device_id = 1;
    required uint32 seq = 2;
}

message TransportFloodQueryReply {
    // time == TRANSPORT_DIAGNOSIS_STATE_PENDING if pending
    required uint64 time = 1;
    required uint64 bytes = 2;
}

// Describes one child of a folder in the history tree
message PBRevChild {
    required string name = 1;
    required bool is_dir = 2;
}

// Describes one revision of a file
message PBRevision {
    required bytes index = 1;
    required uint64 mtime = 2;
    required uint64 length = 3;
}

message PBSyncStatus {
    enum Status {
        IN_SYNC = 0;            // same version
        IN_PROGRESS = 2;        // different versions, syncing not started yet
        OFFLINE = 3;            // different versions, remote device unreachable
    }

    required Status status = 1;
    required string user_name = 2;
    optional string device_name = 3;    // only present for devices of the current user
}

////////
// Messages for testing purposes only

message TestGetObjectIdentifierCall {
    required PBPath path = 1;
}

message TestGetObjectIdentifierReply {
    required int32 sidx = 1;
    required bytes oid = 2;
}

message TestMultiuserJoinRootStoreCall {
    // The user to which the root store belongs
    required string user = 1;
}
