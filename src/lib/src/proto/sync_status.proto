package syncstat;
option java_package = "com.aerofs.proto";
option optimize_for = LITE_RUNTIME; // remove reflection

import "common.proto";

service SyncStatusService {
    // Sets the message type used when errors occur.
    rpc __error__(Void) returns(PBException);

    // Sign in to the SyncStat server.
    //
    // Throws:
    //   ExBadCredential if the username/password combination is incorrect, certificate sign in
    //                   failed, or if the device does not belong to the calling user.
    //   ExNotFound if the given device does not exist.
    //   ExFormatError if the cookie DID is malformed.
    rpc SignIn(SyncSignInCall) returns(SyncSignInReply);

    // Set the version hash for a given DID and OID.
    //
    // Throws:
    //   ExNoPerm if the user has not yet signed in.
    //   ExFormatError if the cookie DID is malformed.
    //   ExBadArgs if the length of the repeated fields are not equal.
    //   ExNoResource if the verkehr publish fails.
    rpc SetVersionHash(SetVersionHashCall) returns(Void);

    // Tell the server the current epoch the client has received, so that the server can clean older
    // entries.
    //
    // Throws:
    //   ExNoPerm if the user has not yet signed in.
    //   ExFormatError if the cookie DID is malformed.
    rpc AckServerEpoch(AckServerEpochCall) returns(Void);

    // Given the client's current version hash epoch number, this call returns the new version
    // hash epoch corresponding to the device in question and a list of updated OID sync statuses.
    //
    // Throws:
    //   ExNoPerm if the user has not yet signed in.
    //   ExFormatError if the cookie DID is malformed.
    //   ExBadArgs if you have called get syncstatus with the same epoch too many consecutive times.
    rpc GetSyncStatus(GetSyncStatusCall) returns(GetSyncStatusReply);
}

message SyncSignInCall {
    required string user_id = 1;
    required bytes did = 2;
}

message SyncSignInReply {
    required uint64 client_epoch = 1;
}

message SetVersionHashCall {
    required bytes sid = 1;
    repeated bytes oid = 2;
    repeated bytes vh = 3;

    // Stored server side and only used to handle unclean redis shutdowns and crashes.
    required uint64 client_epoch = 4;
}

message AckServerEpochCall {
    required uint64 server_epoch = 1;
}

message GetSyncStatusCall {
    // Sync status epoch number.
    required uint64 server_epoch = 1;
}

message GetSyncStatusReply {
    // Message that represents the sync status for a given device (which, when associated with
    // an OID/SID pair, encapsulates the full state of the given object).
    message DeviceSyncStatus {
        required bytes did = 1;
        required bool is_synced = 2;
    }

    message DevicesSyncStatus {
        required bytes sid = 1;
        required bytes oid = 2;
        repeated DeviceSyncStatus devices = 3;
    }

    // There is a certain maximum number of oid sync statuses that the server will send at once to
    // avoid protobuf messages that are too large. If the boolean more is set to true, the client
    // should request the sync status again, using the newly updated epoch sent down in the previous
    // message.

    required uint64 server_epoch = 1;
    required bool more = 2;
    repeated DevicesSyncStatus sync_statuses = 3;
}
