option java_package = "com.aerofs.proto";
option optimize_for = LITE_RUNTIME; // remove reflection

import "common.proto";

service SyncStatRedisService {
    // Sets the message type used when errors occur.
    rpc __error__(Void) returns(PBException);

    /**
     * Sign in to the SyncStat server.
     *
     * Throws:
     *   ExBadCredential if the username/password combination is incorrect.
     *   ExNoPerm if the given device does not belong to the calling user.
     *   ExNotFound if the given device does not exist.
     *   ExFormatError if the cookie DID is malformed.
     */
    rpc SignIn(SyncSignInCall) returns(SignInReply);

    /**
     * Set the version hash for a given DID and OID.
     *
     * Throws:
     *   ExNoPerm if the user has not yet signed in.
     *   ExFormatError if the cookie DID is malformed.
     */
    rpc SetVersionHash(SetVersionHashCall) returns(Void);

    /**
     * Tell the server the current epoch the client has received, so that the server can clean older
     * entries.
     *
     * Throws:
     *   ExNoPerm if the user has not yet signed in.
     *   ExFormatError if the cookie DID is malformed.
     */
    rpc AckServerEpoch(AckServerEpochCall) returns(Void);

    /**
     * Given the client's current version hash epoch number, this call returns the new version
     * hash epoch corresponding to the device in question and a list of updated OID sync statuses.
     *
     * Throws:
     *   ExNoPerm if the user has not yet signed in.
     *   ExFormatError if the cookie DID is malformed.
     */
    rpc GetSyncStatus(GetSyncStatusCall) returns(GetSyncStatusReply);
}

message SyncSignInCall {
    required string user_id = 1;
    required bytes credentials = 2;
    required bytes did = 3;
}

message SignInReply {
    required uint64 client_epoch = 1;
}

message SetVersionHashCall {
    required bytes sid = 1;
    repeated bytes oid = 2;
    repeated bytes vh = 3;

    // Stored server side and only used to handle unclean redis shutdowns and crashes.
    required uint64 client_epoch = 4;
}

message AckServerEpochCall {
    required uint64 server_epoch = 1;
}

message GetSyncStatusCall {
    // Sync status epoch number.
    required uint64 server_epoch = 1;
}

message GetSyncStatusReply {

    // Message that represents the sync status for a given device (which, when associated with
    // an OID/SID pair, encapsulates the full state of the given object).
    message DeviceSyncStatus {
        required bytes did = 1;
        required bool is_synced = 2;
    }

    message SyncStatus {
        required bytes sid = 1;
        required bytes oid = 2;
        repeated DeviceSyncStatus devices = 3;
    }

    // There is a certain maximum number of oid sync statuses that the server will send at once to
    // avoid protobuf messages that are too large. If the boolean more is set to true, the client
    // should request the sync status again, using the newly updated epoch sent down in the previous
    // message.

    required uint64 server_epoch = 1;
    required bool more = 2;
    repeated SyncStatus sync_statuses = 3;
}
