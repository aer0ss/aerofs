/*
 * Created by Allen A. George, Air Computing Inc.
 * Copyright (c) Air Computing Inc., 2011.
 */

package com.aerofs.daemon.transport.lib;

import com.aerofs.base.id.DID;
import com.aerofs.daemon.event.net.EOTpSubsequentPulse;
import com.aerofs.daemon.event.net.IPulseEvent;
import com.aerofs.daemon.transport.ExDeviceUnavailable;
import com.aerofs.lib.sched.IScheduler;
import org.slf4j.Logger;

import static com.aerofs.daemon.lib.DaemonParam.Pulse.INIT_PULSE_TIMEOUT;
import static com.aerofs.daemon.lib.DaemonParam.Pulse.MAX_PULSE_TIMEOUT;
import static com.aerofs.daemon.transport.lib.PulseManager.AddPulseResult;
import static com.aerofs.daemon.transport.lib.PulseManager.PulseToken;
import static com.aerofs.daemon.transport.lib.PulseManager.newCheckPulse;
import static com.aerofs.proto.Transport.PBTPHeader;

/**
 * Common transport-independent utility functions and interfaces for pulse handlers
 */
public class PulseHandlerUtil
{
    //
    // utility methods
    //

    /**
     * Creates a {@link MakePulseResult} that contains:
     * <ol>
     *     <li>{@link PBTPHeader} of type <code>TRANSPORT_CHECK_PULSE_CALL</code>
     *     with a pulse-id generated by the transport's <code>PulseManager</code></li>
     *     <li>a pulse sequence id</li>
     * </ol>
     * @param l {@link Logger} to log messages to
     * @param pm {@link PulseManager} the transport uses to assign pulse ids and generate messages
     * @param did {@link DID} of the remote peer to whom the pulse is being sent
     * @param prevtok {@link PulseToken} representing this sequence of pulsing attempts
     * (null to represent the start of a new pulse sequence)
     * @return a {@link MakePulseResult} consisting of a properly-generated
     * <code>TRANSPORT_CHECK_PULSE_CALL</code> with the generated pulse id and
     * a valid <code>PulseToken</code>. Returns null if <code>prevtok</code> is
     * not null and no pulse id entry exists in the <code>PulseManager</code>, or
     * the <code>prevtok</code> has been invalidated by a new pulse sequence to
     * this remote peer
     */
    public static MakePulseResult makepulse_(Logger l, PulseManager pm, DID did, PulseToken prevtok)
    {
        AddPulseResult pinf = pm.addInProgressPulse(did, prevtok);
        if (pinf == null) return null;

        l.debug("d:{} msgid:{} tok:{}", did, pinf.msgid(), pinf.tok());
        return new MakePulseResult(pinf.tok(), newCheckPulse(pinf.msgid()));
    }

    /**
     * Schedules an <code>IPulseEvent</code> to be run by the transport after a given
     * <code>timeout</code>
     *
     * @param l {@link Logger} to log messages to
     * @param sched {@link IScheduler} used by the transport to schedule events to itself
     * @param ev {@link IPulseEvent} to schedule
     * @param timeout time after which the event should be scheduled
     */
    public static void schedule_(Logger l, IScheduler sched, IPulseEvent ev, long timeout)
    {
        l.trace("d:{} attempt pulse sched", ev.did());
        sched.schedule(ev, timeout);
        l.trace("d:{} pulse sched:+{}", ev.did(), timeout);
    }

    /**
     * Creates a new {@link com.aerofs.daemon.event.net.EOTpSubsequentPulse} event to represent future pulses
     * for this <code>DID</code>, and schedules this new event to be triggered by
     * the transport at <code>INIT_PULSE_TIMEOUT</code>
     *
     * @param l {@link Logger} to log messages to
     * @param sched {@link IScheduler} used by the transport to schedule events to itself
     * @param did {@link DID} of the remote peer for whom the pulse is being rescheduled
     * @param tok {@link PulseToken} with which to create the <code>EOTpSubsequentPulse</code>;
     * this means that this <code>EOTpSubsequentPulse</code> event is part of a given
     * pulse sequence
     */
    public static void doEOStartPulseSchedule(Logger l, IScheduler sched, DID did, PulseToken tok)
    {
        assert  tok != null : ("cannot create EOTpSubsequentPulse will null PulseToken");

        EOTpSubsequentPulse resev = new EOTpSubsequentPulse(did, tok, INIT_PULSE_TIMEOUT, MAX_PULSE_TIMEOUT);
        PulseHandlerUtil.schedule_(l, sched, resev, INIT_PULSE_TIMEOUT);
    }

    /**
     * All {@link com.aerofs.daemon.event.net.EOTpSubsequentPulse} events have to be handled in the same way:
     * <ol>
     *      <li>Check if a pulse is still outstanding - if it isn't then the device
     *          either went offline, or we received a response</li>
     *      <li>Check if it's time to kill a (potentially) dead connection</li>
     * </ol>
     * Depending on which of the above occurs we either 1) stop handling pulses, or
     * 2) kill the connection and send a new pulse via a new connection to the peer.
     * This is a convenience method that wraps all of this logic, which is common
     * between the two transports.
     *
     * @param l transport-specific logger
     * @param unicast {@link IUnicastInternal} for which the pulse was generated
     * @param pm {@link PulseManager} the transport uses to assign pulse ids and generate messages
     * @param ev EOTpSubsequentPulse event that triggered the transport's pulse event handler
     * @param maxfails maximum number of pulse failures after which the
     * connection should be killed
     * @return true if the pulse handler should continue and another pulse should
     * be sent; false otherwise
     */
    public static boolean doEOSubsequentPulsePrePulseChecks(Logger l, IUnicastInternal unicast, PulseManager pm, EOTpSubsequentPulse ev, int maxfails)
    {
        DID did = ev.did();

        // stop pulses if no in-progress pulse entry was found (i.e. a reply came)

        if (pm.getInProgressPulse(did) == null) {
            l.info("d:{} in-progress pulse not found; term hd", did);
            return false;
        }

        // kill the connection and restart pulsing

        if (!ev.killed_() && (ev.tries_() >= maxfails)) {
            l.info("d:{} fails > maxfails ({} >= {}) kill conn and resched ev", did, ev.tries_(), maxfails);
            unicast.disconnect(did, new ExDeviceUnavailable("pulse timed out"));
            ev.markkilled_();
        }

        return true;
    }

    //
    // types
    //

    /**
     * FIXME: Find a way to remove this!
     *
     * Holder class for the result of a <code>makepulse_</code> call
     */
    public static class MakePulseResult
    {
        MakePulseResult(PulseToken tok, PBTPHeader hdr)
        {
            assert tok != null && hdr != null : ("invalid params");

            this.tok = tok;
            this.hdr = hdr;
        }

        public PulseToken tok()
        {
            return tok;
        }

        public PBTPHeader hdr()
        {
            return hdr;
        }

        private final PulseToken tok;
        private final PBTPHeader hdr;
    }

}
