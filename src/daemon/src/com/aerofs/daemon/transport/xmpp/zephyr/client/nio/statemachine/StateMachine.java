/**
 * Created by Allen A. George, Air Computing Inc.
 * Copyright (c) Air Computing Inc., 2011.
 */

package com.aerofs.daemon.transport.xmpp.zephyr.client.nio.statemachine;

import java.util.Map;
import java.util.Set;

import static com.aerofs.daemon.transport.xmpp.zephyr.client.nio.statemachine.CoreEvent.HALT;
import static com.aerofs.daemon.transport.xmpp.zephyr.client.nio.statemachine.CoreEvent.PARK;

/**
 * State machine execution code
 * @param <T> {@link IStateContext} object used to hold system-state
 */
public class StateMachine<T extends IStateContext>
{
    /**
     * Constructor
     * @param spec state machine specification described by an {@link StateMachineSpec}
     */
    public StateMachine(StateMachineSpec<T> spec)
    {
        _spec = spec;
    }

    /**
     * Run the state machine until the event queue is empty or it receives a
     * {@link CoreEvent} from an {@link IState}
     *
     * @param ctx {@link IStateContext} object to be passed to each {@link IState}
     * to be used in processing
     * @return either {@link HALT} (state machine terminated abnormally for this context
     * and has to be shut down) or {@link PARK} (state machine needs to wait for an external
     * event for this context)
     * @throws ExInvalidTransition if the state machine has to process an event
     * for which there is no valid transition
     *
     * FIXME: I'm somewhat not a fan of this...this has to be run manually and the caller has to decide what to do on PARK
     */
    public CoreEvent run_(T ctx) throws ExInvalidTransition
    {
        IState<T> state;
        StateMachineEvent ev = null;
        try {
            while (true) {
                ev = nextev_(ctx);

                assert ev != HALT : ("nextev_ return bad ev:" + ev);
                if (ev == PARK) break;

                while (true) { // run until the state machine requires external input
                    state = currstate_(ctx);

                    ev = process_(state, ev, ctx);
                    if (coreev_(ev)) break;

                    transition_(ev, ctx);
                }

                // if we get here then the state machine took an external input and transitioned
                // as much as it could. the last state processed could have returned either PARK
                // or HALT. if it returned PARK, return to the top and get the next external input
                // to process; if it returned HALT, shut down.

                if (ev == HALT) break;
            }
        } catch (ExInvalidTransition e) {
            ctx.logger_().error("no trans: T: (" + ev + ") " + ctx.curr_() + "->???");
            throw e;
        }

        return (CoreEvent) ev;
    }

    /**
     * @param ev {@code StateMachineEvent} to check
     * @return true if the event is one of {@link PARK} or {@link HALT}
     */
    private boolean coreev_(StateMachineEvent ev)
    {
        return ev == PARK || ev == HALT;
    }

    /**
     * Convenience method to return the properly type-casted that the state machine is in
     *
     * @param ctx {@link IStateContext} object in which the current state is stored
     * @return {@link IState} that the state machine is in
     */
    @SuppressWarnings("unchecked")
    private IState<T> currstate_(T ctx)
    {
        return (IState<T>) ctx.curr_();
    }

    /**
     * Returns the next event that can be processed in this state
     *
     * @param ctx context object from which the current state is retrieved
     * @return a valid implementor of {@code IStateEvent} or {@code CoreEvent}
     */
    private StateMachineEvent nextev_(T ctx)
    {
        StateMachineEvent ev = null;
        IState<T> curr = currstate_(ctx);
        Set<IStateEventType> defer = _spec.defer_(curr);

        while (ev == null) {
            ev = ctx.dequeue_(defer);

            if (ev == null) {
                ev = PARK;
                break;
            }

            assert !coreev_(ev) : ("core ev in ctx eq ev:" + ev); // no explicit PARK/HALT
            assert !defer.contains(ev.type()) : ("dequeue returned deferred ev:" + ev);
        }

        return ev;
    }

    /**
     * Actually performs the transition lookup given the current {@link IState}
     * the {@link IStateContext} object is in, and the {@link IStateEvent} that occurred
     *
     * @param ev  event generated by the previous state
     * @param ctx context object from which the current state is retrieved
     * @throws ExInvalidTransition if there is no valid transition given the
     * combination of current state and generated event
     */
    private void transition_(StateMachineEvent ev, T ctx)
        throws ExInvalidTransition
    {
        IState<T> prev = currstate_(ctx);

        Map<IStateEventType, IState<T>> transmap = _spec.transitions_(prev);
        assert transmap != null && !transmap.isEmpty() : ("no transitions:" + transmap + " for state:" + prev);

        if (!transmap.containsKey(ev.type())) throw new ExInvalidTransition(prev, ev);

        IState<T> next = transmap.get(ev.type());
        ctx.next_(next);

        ctx.logger_().debug(ctx + ": T: (" + ev + ") " + prev + "->" + next);
    }

    /**
     * Run the processing function for the current {@link IState}
     *
     * @param state {@code IState} state to execute
     * @param inev {@code IStateEvent} that triggered this state's execution
     * @param ctx {@link IStateContext} object in which the current transient state is stored
     * @return the event generated as a result of executing this state
     */
    private StateMachineEvent process_(IState<T> state, StateMachineEvent inev, T ctx)
    {
        StateMachineEvent retev = state.process_(inev, ctx);

        ctx.logger_().debug(ctx + ": R: (" + retev + ") " + ctx.curr_());

        return retev;
    }

    /**
     * immutable state machine specification into which all events are fed and
     * from which transitions are computed
     */
    private final StateMachineSpec<T> _spec;
}
