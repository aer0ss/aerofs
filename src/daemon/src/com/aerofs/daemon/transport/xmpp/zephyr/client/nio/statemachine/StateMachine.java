/**
 * Created by Allen A. George, Air Computing Inc.
 * Copyright (c) Air Computing Inc., 2011.
 */

package com.aerofs.daemon.transport.xmpp.zephyr.client.nio.statemachine;

import java.util.Map;

import static com.aerofs.daemon.transport.xmpp.zephyr.client.nio.statemachine.CoreEvent.HALT;
import static com.aerofs.daemon.transport.xmpp.zephyr.client.nio.statemachine.CoreEvent.PARK;

/**
 * State machine execution code
 * @param <T>
 */
public class StateMachine<T extends IStateContext>
{
    /**
     * Constructor
     * @param transitions transition map to be used by this state machine
     */
    public StateMachine(Map<IState<T>, Map<IStateEvent, IState<T>>> transitions)
    {
        _transitions = transitions;
    }

    /**
     * Run the state machine until the event queue is empty or it receives a
     * {@link CoreEvent} from an {@link IState}
     *
     * @param ctx {@link IStateContext} object to be passed to each {@link IState}
     * to be used in processing
     * @return either HALT (state machine terminated abnormally for this context
     * and has to be shut down) or PARK (state machine needs to wait for an external
     * event for this context)
     * @throws ExInvalidTransition if the state machine has to process an event
     * for which there is no valid transition
     *
     * FIXME: I'm somewhat not a fan of this...this has to be run manually and the caller has to decide what to do on PARK
     */
    public CoreEvent run_(T ctx) throws ExInvalidTransition
    {
        IState<T> next = null;
        IStateEvent ev = null;
        try {
            while (true) { // run until the event queue is exhausted
                ev = ctx.dequeue_();

                if (ev != null) assert ev != PARK : ("PARK in ctx eq"); // no explicit PARKs

                if (ev == null) ev = PARK;
                if (ev == PARK || ev == HALT) break;

                next = transition_(ev, ctx);
                ev = next.process_(ctx);
                ctx.logger_().debug(ctx + ": R: (" + ev + ") " + ctx.curr_());
                if (ev != PARK) ctx.enqueueEvent_(ev);
            }
        } catch (ExInvalidTransition e) {
            ctx.logger_().error(
                "no trans: T: (" + ev + ") " + ctx.curr_() + "->???");
            throw e;
        }

        return (CoreEvent) ev;
    }

    /**
     * Actually performs the transition lookup given the current {@link IState}
     * the {@link IStateContext} object is in, and the {@link IStateEvent} it
     * generated
     *
     * @param ev  event generated by the previous state
     * @param ctx context object from which the current state is retrieved
     * @return the next state to which to transition
     * @throws ExInvalidTransition if there is no valid transition given the
     * combination of current state and generated event
     */
    private IState<T> transition_(IStateEvent ev, T ctx)
        throws ExInvalidTransition
    {
        IState<?> prev = ctx.curr_();

        Map<IStateEvent, IState<T>> transmap = _transitions.get(prev);
        assert transmap != null : ("no transitions for state:" + prev);

        if (!transmap.containsKey(ev)) throw new ExInvalidTransition(prev, ev);

        IState<T> next = transmap.get(ev);
        ctx.next_(next);

        ctx.logger_().debug(ctx + ": T: (" + ev + ") " + prev + "->" + next);

        return next;
    }

    /** transition map for this state machine */
    private final Map<IState<T>, Map<IStateEvent, IState<T>>> _transitions;
}
