package com.aerofs.base.id;

import java.util.Arrays;
import java.util.UUID;

import com.aerofs.base.BaseUtil;
import com.aerofs.base.bf.IBFKey;
import com.aerofs.base.ex.ExFormatError;
import com.google.protobuf.ByteString;

// globally unique ids.
//
// templatizing this class is not that easy because of static member ZERO here
//
public class UniqueID implements Comparable<UniqueID>, IBFKey
{
    public static final int LENGTH = 16;

    /**
     * UniqueID obtained from generate() are UUID version 4 as specified by RFC 4122
     *
     * To distinguish different subtypes of unique ids we sometimes change the value of the version
     * nibble (4 most significant bits of the 7th byte of the id).
     * The following constants help manipulating the 4 bits in question.
     */
    public static final int VERSION_BYTE = 6;
    public static final int VERSION_MASK = 0xf0;
    public static final int VERSION_SHIFT = 4;

    public static int getVersionNibble(byte[] bs)
    {
        assert bs.length == LENGTH;
        return (bs[VERSION_BYTE] & VERSION_MASK) >> VERSION_SHIFT;
    }

    public static void setVersionNibble(byte[] bs, int value)
    {
        assert bs.length == LENGTH;
        assert value >= 0 && value < 16;
        bs[VERSION_BYTE] &= ~VERSION_MASK;
        bs[VERSION_BYTE] |= value << VERSION_SHIFT;
    }

    public static final UniqueID ZERO = new UniqueID(new byte[LENGTH]);

    private final byte[] _bs;

    private Integer _hash;
    private ByteString _bstr;
    private String _str;

    public static UniqueID generate()
    {
        UUID uuid = UUID.randomUUID();

        long v = uuid.getLeastSignificantBits();
        byte [] bs = new byte[LENGTH];
        for (int i = 0; i < 8; i++) {
            bs[LENGTH - 1 - i] = (byte)(v >>> (i * 8));
        }

        v = uuid.getMostSignificantBits();
        for (int i = 0; i < 8; i++) {
            bs[LENGTH - 8 - 1 - i] = (byte)(v >>> (i * 8));
        }

        /**
         * The output of this code should be a version 4 UUID as specified by RFC 4122
         *
         * version 4 UUID as hex string: xxxxxxxxxxxxMxxxNxxxxxxxxxxxxxxx
         * invariant 1: M = 4
         * invariant 2: N in {8, 9, a, b}
         *
         * We rely on some of the 6 fixed bits specified by said RFC to distinguish various subtypes
         * of unique ids so we assert that they are set as expected.
         */
        assert getVersionNibble(bs) == 4 : BaseUtil.hexEncode(bs);
        assert (bs[VERSION_BYTE + 2] & 0xc0) == 0x80 : BaseUtil.hexEncode(bs);

        return new UniqueID(bs);
    }

    /**
     *  Convert a string representation of a UniqueID, generated by UniqueID.toStringFormal, to a
     *  UniqueID.
     */
    public UniqueID(String str) throws ExFormatError
    {
        this(str, 0, str.length());
    }

    /**
     *  Convert a string representation of a UniqueID, generated by UniqueID.toStringFormal, to a
     *  UniqueID. {@code start} and {@code end} specifies the start and end point of the substring
     *  to be parse in {@code str}.
     */
    public UniqueID(String str, int start, int end) throws ExFormatError
    {
        byte[] bs = BaseUtil.hexDecode(str, start, end);
        if (bs.length != LENGTH) throw new ExFormatError("wrong length");
        _bs = bs;
    }

    public UniqueID(byte[] bs)
    {
        assert bs.length == LENGTH;
        _bs = bs;
    }

    public UniqueID(ByteString bstr)
    {
        this(bstr.toByteArray());
        _bstr = bstr;
    }

    protected UniqueID(UniqueID id)
    {
        this(id.getBytes());
    }

    @Override
    public String toString()
    {
        if (_str == null) {
            StringBuilder sb = new StringBuilder();

            sb.append('<');
            for (int i = 0; i < 3; i++) {
                sb.append(String.format("%1$02x", _bs[i]));
            }
            sb.append('>');

            _str = sb.toString();
        }

        return _str;
    }

    public String toStringFormal()
    {
        return BaseUtil.hexEncode(_bs);
    }

    @Override
    public byte[] getBytes()
    {
        return _bs;
    }

    @Override
    public boolean equals(Object o)
    {
        return this == o || (o != null && Arrays.equals(_bs, ((UniqueID) o)._bs));
    }

    // hashCode and compareTo start backwards from the last byte of the byte array,
    // as DID names at the beginning.
    @Override
    public int hashCode()
    {
        if (_hash == null) _hash = Arrays.hashCode(_bs);
        return _hash;
    }

    @Override
    public int compareTo(UniqueID id)
    {
        byte [] bs0 = getBytes();
        byte [] bs1 = id.getBytes();
        assert bs0.length == LENGTH && bs1.length == LENGTH;

        for (int i = LENGTH - 1; i >= 0; i--) {
            int diff = bs0[i] - bs1[i];
            if (diff != 0) return diff;
        }
        return 0;
    }

    public ByteString toPB()
    {
        if (_bstr == null) _bstr = ByteString.copyFrom(_bs);
        return _bstr;
    }
}
