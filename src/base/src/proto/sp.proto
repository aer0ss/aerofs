package sp;
option java_package = "com.aerofs.proto";
option optimize_for = LITE_RUNTIME; // remove reflection

import "common.proto";
import "cmd.proto";

/**
 * NOTE: When modifying the service declaration below, if you are not appending your new RPC
 * calls at the end of the declaration make sure to increment the SP_PROTOCOL_VERSION parameter
 * in C.java and the sp.version parameter in development.ini and production.ini (in src/web/)
 * and syncdet_test/lib/param.py
 */

service SPService {

    // Sets the message type used in case of errors
    rpc __error__(Void) returns(PBException);

    /**
     * Request to sign up a user and enable business plan. The method sends an email to the user
     * with a sign-up link. After the user signs up, the user is directed to the payment page.
     *
     * No-op if the user exists. Do not throw ExAlreadyExist to avoid leaking email information to
     * attackers.
     *
     * Required Auth Level: none
     */
    rpc RequestToSignUpWithBusinessPlan(RequestToSignUpWithBusinessPlanCall) returns(Void);

    /**
     * Sign up a user using a signup code.
     *
     * No-op if the user already exists and the password matches the existing user's password.
     * This is needed for the business users to retry signing up using the link in their email.
     * That link points to the user signup page with business signup as the followup page.
     *
     * Required Auth Level: none
     *
     * Throws:
     *   ExAlreadyExist if the email address is unavailable
     *   ExNotFound if the targeted signup code was not found
     *   ExBadCredential if the user exists and the password doesn't match the existing user
     */
    rpc SignUpWithCode(SignUpWithCodeCall) returns(Void);

    /**
     * Sign into the SP server. Return the authorization level of the caller.
     *
     * Required Auth Level: none
     *
     * Throws:
     *   ExBadCredential if username/password combination is incorrect, or in the case of the team
     *                   server, if they have not signed in successfully using mutual
     *                   authentication.
     */
    rpc SignIn(SignInCall) returns(Void);

    /**
     * Finds the email address associated with an signup code.
     *
     * Required Auth Level: none
     *
     * Throws:
     *   ExNotFound if the signup code wasn't found
     */
    rpc ResolveSignUpCode(ResolveSignUpCodeCall)
            returns (ResolveSignUpCodeReply);

    /**
     * Send a verification code to the user's email address. This function will be called
     * automatically when a user signs-up, but we may need to call again if the user
     * can't find the email (spam filter, etc...)
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExAlreadyExist if the user has already been verified
     */
     rpc SendEmailVerification(Void) returns(Void);

    /**
     * Checks an email verification code, and mark the email address as verified
     *
     * Required Auth Level: none (protected by the randomness of the verification code)
     *
     * Throws:
     *   ExNotFound if the verification code wasn't found
     *   ExAlreadyExist if the user has already been verified
     */
     rpc VerifyEmail(VerifyEmailCall) returns(Void);

    /**
     * Signs out of SP
     *
     * Required Auth Level: user
     */
    rpc SignOut(Void) returns (Void);

    /**
     * Creates a certificate for the specified device which is bound to the calling user. Creates
     * an entry in the device table to save registration information.
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExBadArgs   if the cname does not match the required format (hashed concatenation of user
     *               email, did).
     *   ExDeviceIDAlreadyExist if the device ID already exists
     */
    rpc RegisterDevice(RegisterDeviceCall) returns (RegisterDeviceReply);

    /**
     * Invite a person to become an AeroFS user. The will be entered into the default organization
     * The person will receive an email instructing him/her to download AeroFS. The email will also
     * contain a sign-up code to be used in the SignUpWithCode call. The user is silently
     * ignored if she is already an AeroFS user.
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExBadArgs if the caller does not specify one or more invitees.
     *   ExEmailSendingFailed if we were unable to send the invitation email.
     *   ExNoPerm if the user has used up their invitation quota.
     */
    rpc InviteToSignUp(InviteToSignUpCall) returns(Void);

    /**
     * Invite a person to become a member of the caller's organization. An email will be sent to the
     * requested user. When the user clicks on the link the admin panel will accept the organization
     * invite by calling the below rpc (AcceptOrganizationInvitation). At that point the user will
     * be moved in the new organization.
     *
     * Throws:
     *   ExAlreadyExist if the email address is already a member of that organization.
     *   ExAlreadyInvited if the user has already been invited to the organization but has not yet
     *                    accepted the invitation.
     *   ExNoPerm if the caller is not an organization admin.
     *   ExEmailSendingFailed if we were unable to send the email.
     */
     rpc InviteToOrganization(InviteToOrganizationCall) returns(InviteToOrganizationReply);

    /**
     * Accept an organization invitation and move the caller into that organization. Makes
     * appropriate ACL updates to allow for team server sync.
     *
     * This call will also delete the pending organization invitation, since it has already been
     * acted upon.
     *
     * Throws:
     *   ExNotFound if the user does not have a pending invitation for the specified organization.
     *   ExAlreadyExist if the user is already a member of the target organization.
     */
    rpc AcceptOrganizationInvitation(AcceptOrganizationInvitationCall) returns(Void);

   /**
     * Shares a folder with another user.
     *
     * If the user doesn't exist yet, this method will automatically call InviteToSignUp
     * If the invitee email address is outside the organization's allowed domain, he
     * will be invited to the default organization. If the user is authorized to share
     * with the invitee, they will be sent an email notification.
     *
     * Only the sharer is added to the ACL for the newly created store. Invitees will be added
     * later, when they join the folder.
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExNoPerm if the sharee is (or would be created) in a different organization *and*
     *            sharing outside the organization isn't allowed for either the sharer or sharee
     *   ExNoPerm if the sharer isn't authorized to modify ACLs for the given SID
     *   TODO change the exception type below
     *   ExNoPerm if the caller's email address needs to be verified first.
     */
    rpc ShareFolder(ShareFolderCall) returns(Void);

    /**
     * Add the user to a shared folder (provided he/she was invited).
     *
     * NB: pushes ACL update to clients
     *
     * Calling this function with a valid shared folder code will set the user's email address
     * as verified.
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExNotFound if the shared folder code wasn't found
     *   ExNoPerm if the user was not invited to the shared folder
     */
    rpc JoinSharedFolder(JoinSharedFolderCall) returns(Void);

    /**
     * Ignore an invite to a shared folder.
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExNotFound if the shared folder does not exist.
     *   ExNoPerm if the user has not been invited to this shared folder.
     *   ExAlreadyExist if the user is already a member of this shared folder.
     */
    rpc IgnoreSharedFolderInvitation(IgnoreSharedFolderCall) returns(Void);

    /**
     * Remove the user from a shared folder (provided he/she was a member).
     *
     * NB: pushes ACL update to clients
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExNotFound if the shared folder wasn't found.
     *   ExNoPerm if the user was not invited to the shared folder.
     */
    rpc LeaveSharedFolder(LeaveSharedFolderCall) returns(Void);

    /**
     * Returns a list of pending shared folder invitations for the user
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExNoPerm if there is at least one pending invitaton and the user email address
     *            hasn't be verified.
     */
    rpc ListPendingFolderInvitations(Void) returns(ListPendingFolderInvitationsReply);

    /**
     * Sends an email to the user.
     *
     * Required Auth Level: user
     */
    rpc EmailUser(EmailUserCall) returns (Void);

    /**
     * WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE: remove this method
     */
    rpc Noop(Void) returns (GetHeartInvitesQuotaReply);

    /**
     * Get the user's preferences (name, device name, etc)
     *
     * Required Auth Level: user
     */
    rpc GetUserPreferences(GetUserPreferencesCall) returns (GetUserPreferencesReply);

    /**
     * Set a given user's preferences (name, device name, etc). Optional fields that aren't present
     * won't be changed. The session user must be either the given user or the admin of the user's
     * organization.
     *
     * Required Auth Level: user or admin (see above)
     */
    rpc SetUserPreferences(SetUserPreferencesCall) returns (Void);

    /**
     * Get the list of users in the system
     * Used by the admin panel
     *
     * Required Auth Level: admin
     *
     * Throws:
     *   ExNoPerm if the user does not have admin privileges
     */
    rpc ListUsers(ListUsersCall) returns(ListUsersReply);

    /**
     * Get the list of users with the desired authentication level in the system
     * Used by the admin panel
     *
     * Required Auth Level: admin
     *
     * Throws:
     *   ExNoPerm if the user does not have admin privileges
     */
    rpc ListUsersAuth(ListUsersAuthCall) returns(ListUsersReply);

    /**
     * Sends an email to a user with instructions to reset his password. The user
     * will be sent an email containing a link with a reset password token. The link
     * will take the user to a form when they can set a new password.
     * The reset_password token and the new password will be used in the ResetPassword
     * call.
     *
     * Required Auth Level: none
     *
     * Throws:
     *   Nothing... No feedback makes brute force attacks useless
     *
     */
    rpc SendPasswordResetEmail(SendPasswordResetEmailCall) returns(Void);

    /**
     * Reset a user's password. The user will already have received a reset_password token
     * via email.
     *
     * Required Auth Level: none
     *
     *
     * Throws:
     *   ExNotFound if the provided token has no associated user account
     */
    rpc ResetPassword(ResetPasswordCall) returns(Void);

    /**
     * Changes a users password.  The old password is replaced with the new password.
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExNoPerm   if the authorization requirements are not met
     *              if the old password is not correct
     *
     */
    rpc ChangePassword(ChangePasswordCall) returns(Void);

    /**
     * Set the user's authorization level for SP services
     *
     * Required Auth Level: admin
     * throws:
     *   ExNotFound if the provided user email has no AeroFS account set up.
     *   ExNoPerm   if the authorization requirements are not met,
     *              if the new authorization level exceeds that of the caller,
     *              if the caller does not belong to the same organization as the user email
     */
    rpc SetAuthorizationLevel(SetAuthorizationLevelCall) returns(Void);

    /**
     * WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE: remove this.
     */
    rpc Noop3(Void) returns(Void);

    /////////
    // these are internal API calls only (meant to be called by the daemon only)
    // Required Auth Level: user for all of them

    rpc GetACL(GetACLCall) returns (GetACLReply);
    rpc UpdateACL(UpdateACLCall) returns (Void);
    rpc DeleteACL(DeleteACLCall) returns (Void);

    /**
     * Get the certificate revocations relevant to a specific user, based on the certificate
     * revocation list epoch number.
     *
     * Required Auth Level: user
     */
    rpc GetUserCRL(GetUserCRLCall) returns(GetUserCRLReply);

    /**
     * Get global (full, non-user specific) certificate revocation list.
     */
    rpc GetCRL(Void) returns(GetCRLReply);

    /**
     * Revoke the certificate of a specific device and optionally erase AeroFS files from the
     * device. This will trigger a verkehr notification for the CRL.
     *
     * Q. Why is this needed? Isn't it sufficient to manage users only by the ACL system?
     * A. Consider the case where a user quits AeroFS and we revoke all privileges via ACLs. Their
     * certs will still be valid but it won't matter due to the fact that they lack ACLs.
     * But then consider that the user could re-join aerofs with the same email address, then these
     * certs will be valid again, which would be bad.
     *
     * The session user must be the owner of the specified device, or the admin of the organization
     * the device owner belongs to.
     *
     * Required Auth Level: user or admin (see above)
     *
     * Throws:
     *   ExNoPerm   if the user does not have enough privilege (see above)
     *   ExNotFound if the user is trying to unlink a device that does not exist.
     */
    rpc UnlinkDevice(UnlinkDeviceCall) returns(Void);

    // WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE: remove this.
    rpc Noop4(Void) returns(Void);

    // WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE: remove this.
    rpc Noop5(Void) returns(Void);

    // WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE: remove this.
    rpc Noop6(Void) returns(Void);

    /**
     * Get information about a device ID.
     *
     * Required Auth Level: user
     */
    rpc GetDeviceInfo(GetDeviceInfoCall) returns(GetDeviceInfoReply);

    /**
     * Get list of folders being shared by users in organization. See also: ListUserSharedFolders
     *
     * Required Auth Level: admin
     */
    rpc ListOrganizationSharedFolders(ListOrganizationSharedFoldersCall)
            returns(ListOrganizationSharedFoldersReply);

    /**
     * Gets a list of organizations the user has been invited to, excluding their current
     * organization and the default organization.
     *
     * Required Auth Level: user
     */
    rpc GetOrganizationInvitations(Void) returns (GetOrganizationInvitationsReply);

    /**
     * Get the user's organization's preferences (organization name).
     *
     * Required Auth Level: user
     */
    rpc GetOrgPreferences(Void) returns (GetOrgPreferencesReply);

    /**
     * Set the user's organization's preferences (organization name).
     *
     * Required Auth Level: admin
     *
     * Throws:
     *   ExNoPerm if the user calling this does not have admin privileges
     */
    rpc SetOrgPreferences(SetOrgPreferencesCall) returns (Void);

    /**
     * Unsubscribe a user from email reminders based on the unsubscribe token id
     *
     * Required Auth Level: none
     */
    rpc UnsubscribeEmail(SetUnsubscribeEmailCall) returns (GetUnsubscribeEmailReply);

    /**
     * Return the auth level of the current user
     *
     * Required Auth Level: none
     */
    rpc GetAuthorizationLevel(Void) returns (GetAuthorizationLevelReply);

    /**
     * Return the Team Server user id of the current organization
     *
     * Required Auth Level: admin
     */
    rpc GetTeamServerUserID(Void) returns (GetTeamServerUserIDReply);

    /**
     * Certify a Team Server's device and save the device information on SP. It is different from
     * RegisterDevice in that the this call allows the user to register the device under a user
     * ID different from his own ID. This call is needed only for setting up the team server.
     *
     * Required Auth Level: Admin
     *
     * Throws:
     *   ExDeviceIDAlreadyExist if the device ID already exists
     */
    rpc RegisterTeamServerDevice(RegisterDeviceCall) returns (RegisterDeviceReply);

    /*
     * Fetch shared folder names
     *
     * Required Auth Level: user, ACL on all shared folders in request
     */
     rpc GetSharedFolderNames(GetSharedFolderNamesCall) returns(GetSharedFolderNamesReply);

    /**
     * WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE move this under AcceptOrganizationInvite
     *
     * Ignore an invitation to a specific organization. This call deletes the entry in the
     * organization invitation table so that when the user views the pending organization invites
     * page in the admin panel, that organization will no longer appear in the list.
     *
     * This method returns the user counts as well as Stripe customer id of the specific
     * organization, so the Python Web server may update Stripe subscription plan for that org.
     * TODO (WW) This design smells badly. Alternatively we can use a separate method to retrieve
     * the number but it would bring up several security issues. The fundamental problem is that the
     * Web server shouldn't have handled Stripe calls. Either SP or a service that SP depends on
     * should do the job.
     *
     * Throws:
     *   ExNotFound if the user does not have a pending invitation for the specified organization.
     */
    rpc DeleteOrganizationInvitation(DeleteOrganizationInvitationCall) returns(
            DeleteOrganizationInvitationReply);

    /**
     * Extend the tomcat session. Does not throw, since we are guaranteed by tomcat that the session
     * will exist in the tracker.
     *
     * Required Auth Level: user
     */
    rpc ExtendSession(Void) returns(Void);

    /**
     * WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE: move this under GetDeviceInfo.
     *
     * List all the devices belonging to a specified user. If the specified user is not the
     * current user, the current user must be the admin of the organization the specified user
     * belongs to.
     *
     * Required Auth Level: user or admin (see above)
     */
    rpc ListUserDevices(ListUserDevicesCall) returns(ListUserDevicesReply);

    /**
     * Retrieve the Stripe Customer ID associated with the organization that the current
     * AeroFS user is a member of.
     *
     * Required Auth Level: admin
     */
    rpc GetStripeCustomerID(Void) returns(GetStripeCustomerIDReply);

    /**
     * WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE: move this under ListOrganizationSharedFolders
     *
     * Get list of folders being shared by a specified user. If the specified user is not the
     * current user, the current user must be the admin of the organization the specified user
     * belongs to.
     *
     * See also: ListOrganizationSharedFolders
     *
     * Required Auth Level: user or admin (see above)
     *
     * Throws:
     *   ExNoPerm       if the user calling this does not have enough privileges (see above)
     */
    rpc ListUserSharedFolders(ListUserSharedFoldersCall) returns(ListUserSharedFoldersReply);

    /**
     * List all the users who have been invited to the current user's organization.
     *
     * Required Auth Level: admin
     */
     rpc ListOrganizationInvitedUsers(Void) returns(ListOrganizationInvitedUsersReply);

    /**
     * Get the head of the command queue for a given device.
     *
     * Required Auth Level: none
     *
     * Throws:
     *   ExNotFound: if the specified device does not exist or does not belong to you.
     */
    rpc GetCommandQueueHead(GetCommandQueueHeadCall) returns(GetCommandQueueHeadReply);

    /**
     * Acknowledge the command at the head of the command queue for a given device. If the client
     * is unable to process the command they should specify error = true and the command will be
     * retried later.
     *
     * To reduce the number of messages transferred this call also returns the new head of this
     * device's command queue.
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExNotFound: if the specified device does not exist or does not belong to you.
     */
    rpc AckCommandQueueHead(AckCommandQueueHeadCall) returns(AckCommandQueueHeadReply);

     /**
      * Delete organization invitation for a given user.
      *
      * Required Auth Level: admin
      */
     rpc DeleteOrganizationInvitationForUser(DeleteOrganizationInvitationForUserCall) returns(
            DeleteOrganizationInvitationForUserReply);

     /**
      * Used only by a DaemonPostUpdateTask to set OS information for existing devices
      *
      * Required Auth Level: user
      */
     rpc SetDeviceOSFamilyAndName(SetDeviceOSFamilyAndNameCall) returns(Void);
}

message SetDeviceOSFamilyAndNameCall {
    required bytes device_id = 1;
    required string os_family = 2;
    required string os_name = 3;
}

message DeleteOrganizationInvitationForUserCall {
    required string user_id = 1;
}

message DeleteOrganizationInvitationForUserReply {
    // See InviteToOrganizationReply
    required PBStripeSubscriptionData stripe_subscription_data = 1;
}

// The data structure holds all the information that describes Stripe subscription of an
// organization. The Web server uses it to perform Stripe transactions. Ideally, all Stripe
// transactions should be done inside SP and this data structure should not be needed.
message PBStripeSubscriptionData {
    // Stripe customer ID of the organization. Absent if the organization doesn't have the ID.
    optional string stripe_customer_id = 1;
    // Total user count (members + remaining invited users) of the organization. It dictates the
    // organization's subscription plan.
    required uint32 user_count = 2;
}

message ListOrganizationInvitedUsersReply {
    repeated string user_id = 1;
}

message GetStripeCustomerIDReply {
    // The field is absent if the organization doesn't have a Customer ID.
    optional string stripe_customer_id = 1;
}

message SignUpWithCodeCall {
    required string signup_code = 1;
    required bytes credentials = 3; // hashed credentials (some combo of password, etc.)
    // TOOD (WW) use PBFullName
    required string first_name = 4;
    required string last_name = 5;
}

message SignInCall {
    required string user_id = 1;
    optional bytes credentials = 2;
}

message ResolveSignUpCodeCall {
    required string code = 1;
}

message ResolveSignUpCodeReply {
    required string email_address = 1;
}

message VerifyBatchSignUpCodeCall {
    required string bsc = 1;
}

message InviteToSignUpCall {
    repeated string email_addresses = 1;
}

message RequestToSignUpWithBusinessPlanCall {
    required string email_address = 1;
}

message InviteToOrganizationCall {
    required string email_address = 1;
}

message InviteToOrganizationReply {
    // Return subscription data so the Web server doesn't have to make another three SP calls
    // (get customer id, get current member count, and get invited users count) to update the
    // subscription. See PBStripeSubscriptionData for more info.
    required PBStripeSubscriptionData stripe_subscription_data = 1;
}

message AcceptOrganizationInvitationCall {
    required int32 organization_id = 1;
}

message ShareFolderCall {
    // name of the folder being shared
    required string folder_name = 3;

    required bytes share_id = 2;

    // SubjectRolePair of the person with whom we want to share
    // The client (desktop/admin panel/...) is responsible for choosing the default role of
    // invited users. This has better transactional properties than inviting then changing
    // the roles of invited users in a subsequent call.
    // TODO: repeated field now to ease transition. Switch to single subject_role after
    repeated PBSubjectRolePair subject_role = 1;

    // Message to the person
    optional string note = 4;
}

message JoinSharedFolderCall {
    required bytes shared_id = 1;
}

message IgnoreSharedFolderCall {
    required bytes shared_id = 1;
}

message LeaveSharedFolderCall {
    required bytes shared_id = 1;
}

message ListPendingFolderInvitationsReply {
    repeated PBFolderInvitation invitation = 1;
}

message EmailUserCall {
    required string subject = 1;
    required string body = 2;
}

// WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE: remove it
message GetHeartInvitesQuotaReply {
    required uint32 count = 1;
}

message GetUserPreferencesCall {
    required bytes device_id = 1;
}

message GetUserPreferencesReply {
    // TOOD (WW) use PBFullName
    required string first_name = 1;
    required string last_name = 2;
    required string device_name = 3;
}

message SetUserPreferencesCall {

    // WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE make it required and adjust field numbers.
    // This field isoptional for backward compatibility.
    optional string user_id = 5;

    // TOOD (WW) use PBFullName
    optional string first_name = 2;
    optional string last_name = 4;

    // If set, it doesn't change the device id, but it allows setting the device name (below).
    optional bytes device_id = 1;

    // Valid iff device_id is present.
    optional string device_name = 3;
}

message GetACLCall {
    required uint64 epoch = 1;
}

message GetACLReply {
    message PBStoreACL {
        required bytes store_id = 1;
        repeated PBSubjectRolePair subject_role = 2;
    }

    repeated PBStoreACL store_acl = 1;
    required uint64 epoch = 2;
}

message UpdateACLCall {
    required bytes store_id = 1;
    repeated PBSubjectRolePair subject_role = 2;
}

message DeleteACLCall {
    required bytes store_id = 1;
    repeated string subject_list = 2;
}

message VerifyEmailCall {
    required string verification_code = 1;
}

message GetTeamServerUserIDReply {
    required string id = 1;
}

message RegisterDeviceCall {
    required bytes device_id = 1;

    // The Certification Signing Request generated by the client
    required bytes csr = 2;

    // WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE recertify code has been removed
    optional bool recertify_do_not_use = 3;

    // The following optional fields are for backward compatibility
    // WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE change them to required

    // Can be 'Windows', 'Mac OS X', 'Linux', 'Android', 'iOS'. See OSUtil.OSFamily.toString().
    // These strings are displayed to end users (DeviceRegistrationEmailer.java) and are used to
    // determine the icons (devices.mako).
    optional string os_family = 4;

    // Detailed OS names, e.g. 'Windows XP SP 1'
    optional string os_name = 5;

    optional string device_name = 6;
}

message RegisterDeviceReply {
    // The certificate issued by AeroFS CA
    required string cert = 1;
}

message ListUsersCall {
    // Return only users whose name match this string. Empty string matches all users.
    optional string search = 1;

    // Maximum number of users returned on one page.
    // The SP server should enforce a reasonable upper bound for this parameter (like 1000).
    required uint32 max_results = 2;

    // Offset to start retrieving the results.
    required uint32 offset = 3;
}

message ListUsersReply {
    // A subset of the users. There will be at most 'max_results' users.
    repeated PBUser users = 1;

    // Total number of users in the database.
    required uint32 total_count = 2;

    // Total number of users in the database that match the 'search' parameter.
    required uint32 filtered_count = 3;
}

message ListUsersAuthCall {
    // TODO (WW) remove search, auth_level, max_result, and offset
    // Return only admins whose name match this string. Empty string matches all admins.
    optional string search = 1;

    // Authentication level of the users that we want to fetch.
    required PBAuthorizationLevel auth_level = 2;

    // Maximum number of admins returned on one page.
    required uint32 max_results = 3;

    // Offet to start retrieving the results.
    required uint32 offset = 4;
}

message GetAuthorizationLevelReply {
    required PBAuthorizationLevel level = 1;
}

message PBUser {
    // N.B. the user_email is assumed to be the user's unique ID on the SP Database
    required string user_email = 1;
    // TOOD (WW) use PBFullName
    required string first_name = 2;
    required string last_name = 3;
}

message SetAuthorizationLevelCall {
    required string user_email = 1;
    required PBAuthorizationLevel auth_level = 2;
}

enum PBAuthorizationLevel {
    USER       = 0;
    ADMIN      = 1;
}

message SendPasswordResetEmailCall {
    required string user_email = 1;
}

message ResetPasswordCall {
    // Token to be included in email
    required string password_reset_token = 1;
    required bytes new_credentials = 2;
}

message ChangePasswordCall {
    required bytes old_credentials = 1;
    required bytes new_credentials = 2;
}

message GetUserCRLCall {
    required uint64 crl_epoch = 1;
}

message GetUserCRLReply {
    required uint64 crl_epoch = 1;
    repeated uint64 serial = 2;
}

message GetCRLReply {
    repeated uint64 serial = 1;
}

message UnlinkDeviceCall {
    required bytes device_id = 1;
    required bool erase = 2;
}

message GetDeviceInfoCall {
    repeated bytes device_id = 1;
}

message GetDeviceInfoReply {

    // See also GetUserDevicesReply.PBDevice
    message PBDeviceInfo {
        // These fields are absent if:
        // 1) the device ID is not found, or
        // 2) the caller is not sharing any folder with the device owner.
        optional PBUser owner = 1;
        optional string device_name = 2;
    }

    repeated PBDeviceInfo device_info = 1;
}

message ListOrganizationSharedFoldersCall {
    // Maximum number of folders returned.
    required uint32 max_results = 1;

    // Offset into results
    required uint32 offset = 2;
}

message ListOrganizationSharedFoldersReply {
    repeated PBSharedFolder shared_folder = 1;

    // Total number of shared folders in the database
    required uint32 total_count = 2;
}

message ListUserSharedFoldersCall {
    required string user_id = 1;
}

message ListUserSharedFoldersReply {
    repeated PBSharedFolder shared_folder = 1;
}

message PBSharedFolder {

    message PBUserAndRole {
        // Since only the Web UI uses this method, we include the full name for pretty display.
        required PBUser user = 1;
        required PBRole role = 2;
    }

    required bytes store_id = 1;
    required string name = 2;
    repeated PBUserAndRole user_and_role = 3;
}

message GetOrganizationInvitationsReply {
    message OrganizationInvitation {
        required string inviter = 1;
        required string organization_name = 2;
        required int32 organization_id = 3;
    }

    // Organizations the user has been invited to. Excludes the current organization and the default
    // organization.
    repeated OrganizationInvitation organization_invitations = 2;
}

// WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE. convert them to required fields
message GetOrgPreferencesReply {
    required string organization_name = 1;
    optional string organization_contact_phone = 2;
}

message SetOrgPreferencesCall {
    optional string org_name = 1;
    optional string organization_contact_phone = 2;
}

message SetUnsubscribeEmailCall {
    required string unsubscribe_token = 1;
}

message GetUnsubscribeEmailReply {
    required string email_id = 1;
}

message GetSharedFolderNamesCall {
    repeated bytes shared_id = 1;
}

message GetSharedFolderNamesReply {
    repeated string folder_name = 1;
}

// WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE: move this under AcceptOrganizationInvitationCall.
message DeleteOrganizationInvitationCall {
    required int32 organization_id = 1;
}

message DeleteOrganizationInvitationReply {
    // As the deletion causes the organization to lose one user, the Web server needs to adjust
    // the organization's subscription plan. However, because the current user doesn't belong to the
    // organization, the Web server doesn't have the permission to retrieve the organization's
    // subscription data which is necessary for the adjustment. Therefore, we return the
    // data in this reply.
    //
    // This design is not great. Ideally, SP should perform all Stripe transactions internally
    // without the Web server's involvement. See PBStripeSubscriptionData for more information.
    required PBStripeSubscriptionData stripe_subscription_data = 1;
}

// WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE: move this under the GetDeviceInfo messages.
message ListUserDevicesCall {
    required string user_id = 1;
}

// WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE: move this under the GetDeviceInfo messages.
message ListUserDevicesReply {

    // See also GetDeviceInfoReply.PBDeviceInfo
    message PBDevice {
        required bytes device_id = 1;
        required string device_name = 2;
        required string os_family = 3;
        required string os_name = 4;
    }

    repeated PBDevice device = 1;
}

message PBFullName {
    required string first_name = 1;
    required string last_name = 2;
}

message GetCommandQueueHeadCall {
    required bytes device_id = 1;
}

message GetCommandQueueHeadReply {
    optional Command command = 1;
    required int64 queue_size = 2;
}

message AckCommandQueueHeadCall {
    required bytes device_id = 1;
    required uint64 epoch = 2;
    required bool error = 3;
}

message AckCommandQueueHeadReply {
    // This command is the command now at the head of the queue. Included in the ack reply to
    // reduce the number of round trips when doing a full syncronization.
    optional Command command = 1;
    required int64 queue_size = 2;
}
