package sp;
option java_package = "com.aerofs.proto";
option optimize_for = LITE_RUNTIME; // remove reflection

import "common.proto";
import "cmd.proto";

/**
 * NOTE: When modifying the service declaration below, if you are not appending your new RPC
 * calls at the end of the declaration make sure to increment the SP_PROTOCOL_VERSION parameter
 * in C.java and the sp.version parameter in development.ini and production.ini (in src/web/)
 * and syncdet_test/lib/param.py
 */

service SPService {

    // Sets the message type used in case of errors
    rpc __error__(Void) returns(PBException);

    /**
     * Similar to InviteToSignUp except that no inviter is included in the email sent to the user.
     *
     * Required Auth Level: none
     *
     * Throws: ExEmptyEmailAddress is the email address is empty
     */
    rpc RequestToSignUp(RequestToSignUpCall) returns(Void);

    /**
     * Sign up a user using a signup code.
     *
     * No-op if the user already exists and the password matches the existing user's password.
     * This is needed for the business users to retry signing up using the link in their email.
     * That link points to the user signup page with business signup as the followup page.
     *
     * Required Auth Level: none
     *
     * Throws:
     *   ExNotFound if the targeted signup code was not found
     *   ExBadCredential if the user exists and the password doesn't match the existing user
     */
    rpc SignUpWithCode(SignUpWithCodeCall) returns(SignUpWithCodeReply);

    /**
     * Sign into the SP server. Return the authorization level of the caller.
     *
     * Required Auth Level: none
     *
     * Throws:
     *   ExEmptyEmailAddress if the user id is empty
     *   ExBadCredential if username/password combination is incorrect, or in the case of the team
     *                   server, if they have not signed in successfully using mutual
     *                   authentication.
     */
    rpc SignIn(SignInCall) returns(Void);

    /**
     * Finds the email address associated with an signup code.
     *
     * Required Auth Level: none
     *
     * Throws:
     *   ExNotFound if the signup code wasn't found
     */
    rpc ResolveSignUpCode(ResolveSignUpCodeCall)
            returns (ResolveSignUpCodeReply);

    /**
     * Send a verification code to the user's email address. This function will be called
     * automatically when a user signs-up, but we may need to call again if the user
     * can't find the email (spam filter, etc...)
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExAlreadyExist if the user has already been verified
     */
     rpc SendEmailVerification(Void) returns(Void);

    /**
     * Checks an email verification code, and mark the email address as verified
     *
     * Required Auth Level: none (protected by the randomness of the verification code)
     *
     * Throws:
     *   ExNotFound if the verification code wasn't found
     *   ExAlreadyExist if the user has already been verified
     */
     rpc VerifyEmail(VerifyEmailCall) returns(Void);

    /**
     * Signs out of SP
     *
     * Required Auth Level: user
     */
    rpc SignOut(Void) returns (Void);

    /**
     * Creates a certificate for the specified device which is bound to the calling user. Creates
     * an entry in the device table to save registration information.
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExBadArgs   if the cname does not match the required format (hashed concatenation of user
     *               email, did).
     *   ExDeviceIDAlreadyExist if the device ID already exists
     */
    rpc RegisterDevice(RegisterDeviceCall) returns (RegisterDeviceReply);

    /**
     * Send the specified user a signup invitation email. The request is silently ignored if the
     * user is already an AeroFS user.
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExBadArgs if the caller does not specify one or more invitees.
     *   ExEmptyEmailAddress if the user id is empty
     *   ExEmailSendingFailed if we were unable to send the invitation email.
     *   ExNoPerm if the user has used up their invitation quota.
     *   ExEmailNotVerified if the user's email hasn't been verified
     */
    rpc InviteToSignUp(InviteToSignUpCall) returns(Void);

    /**
     * Invite a person to become a member of the caller's organization. An email will be sent to the
     * requested user. When the user clicks on the link the admin panel will accept the organization
     * invite by calling the below rpc (AcceptOrganizationInvitation). At that point the user will
     * be moved in the new organization.
     *
     * Required Auth Level: admin
     *
     * Throws:
     *   ExEmptyEmailAddress if the user id is empty
     *   ExAlreadyExist if the email address is already a member of that organization.
     *   ExAlreadyInvited if the user has already been invited to the organization but has not yet
     *                  accepted the invitation.
     *   ExEmailSendingFailed if we were unable to send the email.
     *   ExNoStripeCustomerID if payment is required but the current team doesn't have a Stripe
     *                  customer ID.
     *   ExEmailNotVerified if the user's email hasn't been verified
     */
     rpc InviteToOrganization(InviteToOrganizationCall) returns(InviteToOrganizationReply);

    /**
     * Accept an organization invitation and move the caller into that organization. Makes
     * appropriate ACL updates to allow for team server sync.
     *
     * This call will also delete the pending organization invitation, since it has already been
     * acted upon.
     *
     * Throws:
     *   ExNotFound if the user does not have a pending invitation for the specified organization.
     *   ExBadArgs if the user is already a member of the target organization.
     *   ExNoAdminForNonEmptyTeam if the team would have no admins but non-admin members.
     *   ExEmailNotVerified if the user's email hasn't been verified
     */
    rpc AcceptOrganizationInvitation(AcceptOrganizationInvitationCall)
            returns(AcceptOrganizationInvitationReply);

    /**
     * Shares a folder with another user.
     *
     * If the user doesn't exist yet, this method calls InviteToSignUp.
     *
     * See docs/design/sharing_and_migration.txt for high-level design.
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExNoPerm if the sharer isn't authorized to modify ACLs for the given SID
     *   ExAlreadyExists if the user is already a member of the folder
     *   ExCannotInviteSelf if the sharer appears in the list of sharees
     *   ExInviteeListEmpty if the list of invitees is empty AND the external flag is false
     *   ExNoStripeCustomerID if payment is required but the current team doesn't have a Stripe
     *                  customer ID.
     *   ExEmailNotVerified if the user's email hasn't been verified
     */
    rpc ShareFolder(ShareFolderCall) returns(Void);

    /**
     * Add the user to a shared folder (provided he/she was invited).
     *
     * NB: pushes ACL update to clients
     *
     * Calling this function with a valid shared folder code will set the user's email address
     * as verified.
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExNotFound if the shared folder code wasn't found
     *   ExNoPerm if the user was not invited to the shared folder
     *   ExEmailNotVerified if the user's email hasn't been verified
     */
    rpc JoinSharedFolder(JoinSharedFolderCall) returns(Void);

    /**
     * Ignore an invite to a shared folder.
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExNotFound if the shared folder does not exist.
     *   ExNoPerm if the user has not been invited to this shared folder.
     *   ExAlreadyExist if the user is already a member of this shared folder.
     */
    rpc IgnoreSharedFolderInvitation(IgnoreSharedFolderCall) returns(Void);

    /**
     * Remove the user from a shared folder (provided he/she was a member).
     *
     * NB: pushes ACL update to clients
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExNotFound if the shared folder wasn't found.
     *   ExNoPerm if the user was not invited to the shared folder.
     */
    rpc LeaveSharedFolder(LeaveSharedFolderCall) returns(Void);

    /**
     * Returns a list of pending shared folder invitations for the user
     *
     * Required Auth Level: user
     */
    rpc ListPendingFolderInvitations(Void) returns(ListPendingFolderInvitationsReply);

    /**
     * Sends an email to the user.
     *
     * Required Auth Level: user
     */
    rpc EmailUser(EmailUserCall) returns (Void);

    /**
     * WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE: remove this method
     */
    rpc Noop(Void) returns (GetHeartInvitesQuotaReply);

    /**
     * Get the user's preferences (name, device name, etc)
     *
     * Required Auth Level: user
     */
    rpc GetUserPreferences(GetUserPreferencesCall) returns (GetUserPreferencesReply);

    /**
     * Set a given user's preferences (name, device name, etc). Optional fields that aren't present
     * won't be changed. The session user must be either the given user or the admin of the user's
     * organization.
     *
     * Required Auth Level: user or admin (see above)
     */
    rpc SetUserPreferences(SetUserPreferencesCall) returns (Void);

    /**
     * List members of the current organization
     *
     * Required Auth Level: admin
     *
     * Throws:
     *   ExNoPerm if the user does not have admin privileges
     */
    rpc ListOrganizationMembers(ListOrganizationMembersCall) returns(ListOrganizationMembersReply);

    // WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE remove it
    rpc noop7(Void) returns(Void);

    /**
     * Sends an email to a user with instructions to reset his password. The user
     * will be sent an email containing a link with a reset password token. The link
     * will take the user to a form when they can set a new password.
     * The reset_password token and the new password will be used in the ResetPassword
     * call.
     *
     * Required Auth Level: none
     *
     * Throws:
     *   Nothing... No feedback makes brute force attacks useless
     */
    rpc SendPasswordResetEmail(SendPasswordResetEmailCall) returns(Void);

    /**
     * Reset a user's password. The user will already have received a reset_password token
     * via email.
     *
     * Required Auth Level: none
     *
     *
     * Throws:
     *   ExNotFound if the provided token has no associated user account
     */
    rpc ResetPassword(ResetPasswordCall) returns(Void);

    /**
     * Changes a users password.  The old password is replaced with the new password.
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExNoPerm   if the authorization requirements are not met
     *              if the old password is not correct
     */
    rpc ChangePassword(ChangePasswordCall) returns(Void);

    /**
     * Set the user's authorization level for SP services
     *
     * Required Auth Level: admin
     * throws:
     *   ExNotFound if the provided user email has no AeroFS account set up.
     *   ExNoPerm   if the authorization requirements are not met,
     *              if the new authorization level exceeds that of the caller,
     *              if the caller does not belong to the same organization as the user email
     */
    rpc SetAuthorizationLevel(SetAuthorizationLevelCall) returns(Void);

    /**
     * WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE: remove this.
     */
    rpc Noop3(Void) returns(Void);

    /////////
    // these are internal API calls only (meant to be called by the daemon only)
    // Required Auth Level: user for all of them

    /**
     * Retrieve ACL entries for the user, excluding those flagged as "external"
     *
     * NB: for backward compatibility with old clients, this corresponds to the old GetACL rpc
     *
     * Required Auth Level: user
     */
    rpc GetACLExcludeExternal(GetACLCall) returns (GetACLReply);

    // WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE remove these and move the new UpdateACL/DeleteACL calls to here
    rpc UpdateACLDeprecated(UpdateACLDeprecatedCall) returns (Void);
    rpc DeleteACLDEprecated(DeleteACLDeprecatedCall) returns (Void);

    /**
     * Get the certificate revocations relevant to a specific user, based on the certificate
     * revocation list epoch number.
     *
     * Required Auth Level: user
     */
    rpc GetUserCRL(GetUserCRLCall) returns(GetUserCRLReply);

    /**
     * Get global (full, non-user specific) certificate revocation list.
     */
    rpc GetCRL(Void) returns(GetCRLReply);

    /**
     * Revoke the certificate of a specific device and optionally erase AeroFS files from the
     * device. This will trigger a verkehr notification for the CRL.
     *
     * Q. Why is this needed? Isn't it sufficient to manage users only by the ACL system?
     * A. Consider the case where a user quits AeroFS and we revoke all privileges via ACLs. Their
     * certs will still be valid but it won't matter due to the fact that they lack ACLs.
     * But then consider that the user could re-join aerofs with the same email address, then these
     * certs will be valid again, which would be bad.
     *
     * The session user must be the owner of the specified device, or the admin of the organization
     * the device owner belongs to.
     *
     * Required Auth Level: user or admin (see above)
     *
     * Throws:
     *   ExNoPerm   if the user does not have enough privilege (see above)
     *   ExNotFound if the user is trying to unlink a device that does not exist.
     */
    rpc UnlinkDevice(UnlinkDeviceCall) returns(Void);

    // WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE: remove this.
    rpc Noop4(Void) returns(Void);

    // WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE: remove this.
    rpc Noop5(Void) returns(Void);

    // WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE: remove this.
    rpc Noop6(Void) returns(Void);

    /**
     * Get information about a device ID.
     *
     * Required Auth Level: user
     */
    rpc GetDeviceInfo(GetDeviceInfoCall) returns(GetDeviceInfoReply);

    /**
     * Get list of folders being shared by users in organization. See also: ListUserSharedFolders
     *
     * Required Auth Level: admin
     */
    rpc ListOrganizationSharedFolders(ListOrganizationSharedFoldersCall)
            returns(ListOrganizationSharedFoldersReply);

    /**
     * Gets a list of organizations the user has been invited to, excluding their current
     * organization.
     *
     * Required Auth Level: user
     */
    rpc GetOrganizationInvitations(Void) returns (GetOrganizationInvitationsReply);

    /**
     * Get the user's organization's preferences (organization name).
     *
     * Required Auth Level: user
     */
    rpc GetOrgPreferences(Void) returns (GetOrgPreferencesReply);

    /**
     * Set the user's organization's preferences (organization name).
     *
     * Required Auth Level: admin
     *
     * Throws:
     *   ExNoPerm if the user calling this does not have admin privileges
     */
    rpc SetOrgPreferences(SetOrgPreferencesCall) returns (Void);

    /**
     * Unsubscribe a user from email reminders based on the unsubscribe token id
     *
     * Required Auth Level: none
     */
    rpc UnsubscribeEmail(SetUnsubscribeEmailCall) returns (GetUnsubscribeEmailReply);

    /**
     * Return the auth level of the current user
     *
     * Required Auth Level: none
     */
    rpc GetAuthorizationLevel(Void) returns (GetAuthorizationLevelReply);

    /**
     * Return the Team Server user id of the current organization
     *
     * Required Auth Level: admin
     */
    rpc GetTeamServerUserID(Void) returns (GetTeamServerUserIDReply);

    /**
     * Certify a Team Server's device and save the device information on SP. It is different from
     * RegisterDevice in that the this call allows the user to register the device under a user
     * ID different from his own ID. This call is needed only for setting up the team server.
     *
     * Required Auth Level: Admin
     *
     * Throws:
     *   ExDeviceIDAlreadyExist if the device ID already exists
     *   ExEmailNotVerified if the user's email hasn't been verified. We do it to avoid
     *   security complications on Team Servers, such as inviting users from the Team Server
     *   desktop app.
     */
    rpc RegisterTeamServerDevice(RegisterDeviceCall) returns (RegisterDeviceReply);

    /*
     * Fetch shared folder names
     *
     * Required Auth Level: user, ACL on all shared folders in request
     */
     rpc GetSharedFolderNames(GetSharedFolderNamesCall) returns(GetSharedFolderNamesReply);

    /**
     * WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE move this under AcceptOrganizationInvite
     *
     * Ignore an invitation to a specific organization. This call deletes the entry in the
     * organization invitation table so that when the user views the pending organization invites
     * page in the admin panel, that organization will no longer appear in the list.
     *
     * This method returns the user counts as well as Stripe customer id of the specific
     * organization, so the Python Web server may update Stripe subscription plan for that org.
     * TODO (WW) This design smells badly. Alternatively we can use a separate method to retrieve
     * the number but it would bring up several security issues. The fundamental problem is that the
     * Web server shouldn't have handled Stripe calls. Either SP or a service that SP depends on
     * should do the job.
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExNotFound if the user does not have a pending invitation for the specified organization.
     */
    rpc DeleteOrganizationInvitation(DeleteOrganizationInvitationCall) returns(
            DeleteOrganizationInvitationReply);

    /**
     * Extend the tomcat session. Does not throw, since we are guaranteed by tomcat that the session
     * will exist in the tracker.
     *
     * Required Auth Level: user
     */
    rpc ExtendSession(Void) returns(Void);

    /**
     * WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE: move this under GetDeviceInfo.
     *
     * List all the devices belonging to a specified user. If the specified user is not the
     * current user, the current user must be the admin of the organization the specified user
     * belongs to.
     *
     * Required Auth Level: user or admin (see above)
     *
     * Throws: ExEmptyEmailAddress if the user id is empty
     */
    rpc ListUserDevices(ListUserDevicesCall) returns(ListUserDevicesReply);

    /**
     * Retrieve Stripe data of the current organization.
     *
     * Required Auth Level: admin
     */
    rpc GetStripeData(Void) returns(GetStripeDataReply);

    /**
     * WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE: move this under ListOrganizationSharedFolders
     *
     * Get list of folders being shared by a specified user. If the specified user is not the
     * current user, the current user must be the admin of the organization the specified user
     * belongs to.
     *
     * See also: ListOrganizationSharedFolders
     *
     * Required Auth Level: user or admin (see above)
     *
     * Throws:
     *   ExNoPerm       if the user calling this does not have enough privileges (see above)
     */
    rpc ListUserSharedFolders(ListUserSharedFoldersCall) returns(ListUserSharedFoldersReply);

    /**
     * List all the users who have been invited to the current user's organization.
     *
     * Required Auth Level: admin
     */
     rpc ListOrganizationInvitedUsers(Void) returns(ListOrganizationInvitedUsersReply);

    /**
     * Get the head of the command queue for a given device.
     *
     * Required Auth Level: none
     *
     * Throws:
     *   ExNotFound: if the specified device does not exist.
     */
    rpc GetCommandQueueHead(GetCommandQueueHeadCall) returns(GetCommandQueueHeadReply);

    /**
     * Acknowledge the command at the head of the command queue for a given device. If the client
     * is unable to process the command they should specify error = true and the command will be
     * retried later.
     *
     * To reduce the number of messages transferred this call also returns the new head of this
     * device's command queue.
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExNotFound: if the specified device does not exist or does not belong to you.
     */
    rpc AckCommandQueueHead(AckCommandQueueHeadCall) returns(AckCommandQueueHeadReply);

     /**
      * Delete organization invitation for a given user.
      *
      * Required Auth Level: admin
      *
      * Throws: ExEmptyEmailAddress if the user id is empty
      */
     rpc DeleteOrganizationInvitationForUser(DeleteOrganizationInvitationForUserCall) returns(
            DeleteOrganizationInvitationForUserReply);

     /**
      * Used only by a DaemonPostUpdateTask to set OS information for existing devices
      *
      * Required Auth Level: user
      */
     rpc SetDeviceOSFamilyAndName(SetDeviceOSFamilyAndNameCall) returns(Void);

     /**
      * Set the Stripe customer ID of the current organization
      *
      * Required Auth Level: admin
      */
     rpc SetStripeCustomerID(SetStripeCustomerIDCall) returns(Void);

     // WAIT_FOR_SP_PROCOTOL_VERSION_CHANGE move them to in place of UpdateACL/DeleteACL_Deprecated
     /**
      * Update the ACL for an existing member of a shared folder
      *
      * Required Auth Level: user
      *
      * Throws: ExNotFound if the user is not a member of the specified folder
      */
     rpc UpdateACL(UpdateACLCall) returns (Void);

     // WAIT_FOR_SP_PROCOTOL_VERSION_CHANGE move them to in place of UpdateACL/DeleteACL_Deprecated
     /**
      * Delete the ACL for an existing member or an pending user of a shared folder
      *
      * Required Auth Level: user
      *
      * Throws: ExNotFound if the user is not a member or pending user of the specified folder
      */
     rpc DeleteACL(DeleteACLCall) returns (Void);

     /**
      * Delete the Stripe customer ID of the current organization
      *
      * Required Auth Level: admin
      */
     rpc DeleteStripeCustomerID(Void) returns (Void);

    /**
     * Retrieve ACL entries for the user, including those flagged as "external"
     *
     * Required Auth Level: user
     */
    rpc GetACL(GetACLCall) returns(GetACLReply);

     // WAIT_FOR_SP_PROCOTOL_VERSION_CHANGE move this after AcceptOrganizationInvitation
     /**
      * Remove a user from the caller's organization. The user will be moved to a new empty
      * organization, and will be seen as an external collaborator on any shared folders that he
      * may have with the previous organization.
      *
      * Required Auth Level: admin
      *
      * Throws: ExNoPerm if the current user isn't an admin of the target user, or if an admin tries
      *         to remove itself from the organization
      */
    rpc RemoveUserFromOrganization(RemoveUserFromOrganizationCall)
            returns(RemoveUserFromOrganizationReply);

    /**
     * Issue a new certificate to the requesting user/did.
     *
     * Required Auth Level: user
     * Throws: ExNotFound if the specified device id is not known to be owned by that user.
     */
    rpc RecertifyDevice(RecertifyDeviceCall) returns (RecertifyDeviceReply);

    /**
     * Issue a new team server (organization) certificate for the requesting user/did.
     * Requires
     *
     * Required Auth Level: admin
     * Throws: ExNoPerm if the current user isn't an admin of her organization
     *         ExNotFound if the specified device does not exist for the given organization. Note
     *              that this is necessary, otherwise, we would allow email-unverified users to
     *              certify Team Servers, bypassing RegisterTeamServerDevice(). The latter method
     *              throws if the requesting user's email is not verified.
     */
    rpc RecertifyTeamServerDevice(RecertifyDeviceCall) returns (RecertifyDeviceReply);

    /**
     * Get User's Organization ID
     *
     * Required Auth Level: user
     */
    rpc GetOrganizationID(Void) returns(GetOrganizationIDReply);

    // WAIT_FOR_SP_PROCOTOL_VERSION_CHANGE move this to before SignUpWithCode
    /**
     * Sign up a user without using a signup code.
     *
     * No-op if the user already exists and the password matches the existing user's password.
     *
     * Required Auth Level: none
     *
     * Throws:
     *   ExBadCredential if the user exists and the password doesn't match the existing user
     */
    rpc SignUp(SignUpCall) returns(SignUpReply);
}

message SetStripeCustomerIDCall {
    required string stripe_customer_id = 1;
}

message SetDeviceOSFamilyAndNameCall {
    required bytes device_id = 1;
    required string os_family = 2;
    required string os_name = 3;
}

message DeleteOrganizationInvitationForUserCall {
    required string user_id = 1;
}

message DeleteOrganizationInvitationForUserReply {
    // See InviteToOrganizationReply
    required PBStripeData stripe_data = 1;
}

// The data structure holds all the information that describes the Stripe subscription of a
// team. The Web server uses it to perform Stripe transactions. Ideally, all Stripe
// transactions should be done inside SP and this data structure should not be needed.
// See src/web/README.stirpe.txt for detail.
message PBStripeData {
    // Stripe customer ID of the organization. Absent if the organization doesn't have the ID.
    // If the field is present, the caller MUST update Stripe subscription based on quantity.
    optional string customer_id = 1;
    // The quantity of the subscription. It is identical to the number of team members.
    required uint32 quantity = 2;
}

message ListOrganizationInvitedUsersReply {
    repeated string user_id = 1;
}

message GetStripeDataReply {
    required PBStripeData stripe_data = 1;
}

message SignUpCall {
    required string email = 1;
    required bytes password = 2; // hashed credentials (some combo of password, etc.)
    // TOOD (WW) use PBFullName
    required string first_name = 3;
    required string last_name = 4;
}

message SignUpReply {
    required string org_id = 1;
}

message SignUpWithCodeCall {
    required string signup_code = 1;
    required bytes password = 3; // hashed credentials (some combo of password, etc.)
    // TOOD (WW) use PBFullName
    required string first_name = 4;
    required string last_name = 5;
}

message SignUpWithCodeReply {
    required string org_id = 1;
    required bool existing_team = 2; // is the user joining an existing team, or a new team?
}

message SignInCall {
    required string user_id = 1;
    optional bytes credentials = 2;
}

message ResolveSignUpCodeCall {
    required string code = 1;
}

message ResolveSignUpCodeReply {
    required string email_address = 1;
}

message VerifyBatchSignUpCodeCall {
    required string bsc = 1;
}

message InviteToSignUpCall {
    repeated string email_addresses = 1;
}

message RequestToSignUpCall {
    required string email_address = 1;
}

message InviteToOrganizationCall {
    required string email_address = 1;
}

message InviteToOrganizationReply {
    // Return Stripe data so the Web server doesn't have to make another three SP calls
    // (get customer id, get current member count, and get invited users count) to update the
    // subscription. See PBStripeData for more info.
    required PBStripeData stripe_data = 1;
}

message AcceptOrganizationInvitationCall {
    required int32 organization_id = 1;
}

message AcceptOrganizationInvitationReply {
    // Return Stripe data for the user's _previous_ team, so the Web server can downgrade
    // subscription for that team.
    required PBStripeData stripe_data = 1;
}

message RemoveUserFromOrganizationCall {
    required string user_id = 1;
}

message RemoveUserFromOrganizationReply {
    required PBStripeData stripe_data = 1;
}

message ShareFolderCall {
    // name of the folder being shared
    required string folder_name = 3;

    required bytes share_id = 2;

    // SubjectRolePair of the person with whom we want to share
    // The client (desktop/admin panel/...) is responsible for choosing the default role of
    // invited users. This has better transactional properties than inviting then changing
    // the roles of invited users in a subsequent call.
    // TODO: repeated field now to ease transition. Switch to single subject_role after
    repeated PBSubjectRolePair subject_role = 1;

    // Message to the person
    optional string note = 4;

    // whether the sharer created the share outside his root anchor
    // ignored when adding new members to an existing shared folder
    optional bool external = 5 [default = false];
}

message JoinSharedFolderCall {
    required bytes shared_id = 1;
    optional bool external = 2 [default = false];
}

message IgnoreSharedFolderCall {
    required bytes shared_id = 1;
}

message LeaveSharedFolderCall {
    required bytes shared_id = 1;
}

message ListPendingFolderInvitationsReply {
    repeated PBFolderInvitation invitation = 1;
}

message EmailUserCall {
    required string subject = 1;
    required string body = 2;
}

// WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE: remove it
message GetHeartInvitesQuotaReply {
    required uint32 count = 1;
}

message GetUserPreferencesCall {
    optional bytes device_id = 1; // if absent, no device-specific information will be returned
}

message GetUserPreferencesReply {
    // TOOD (WW) use PBFullName
    required string first_name = 1;
    required string last_name = 2;
    optional string device_name = 3; // absent if did wasn't specified
    optional uint64 signup_date = 4;
}

message SetUserPreferencesCall {

    // WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE make it required and adjust field numbers.
    // This field isoptional for backward compatibility.
    optional string user_id = 5;

    // TOOD (WW) use PBFullName
    optional string first_name = 2;
    optional string last_name = 4;

    // If set, it doesn't change the device id, but it allows setting the device name (below).
    optional bytes device_id = 1;

    // Valid iff device_id is present.
    optional string device_name = 3;
}

message GetACLCall {
    required uint64 epoch = 1;
}

message GetACLReply {
    message PBStoreACL {
        required bytes store_id = 1;
        repeated PBSubjectRolePair subject_role = 2;
        required bool external = 3;
    }

    repeated PBStoreACL store_acl = 1;
    required uint64 epoch = 2;
}

message UpdateACLCall {
    required bytes store_id = 1;
    required string subject = 2;
    required PBRole role = 3;
}

message DeleteACLCall {
    required bytes store_id = 1;
    required string subject = 2;
}

// WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE remove this
message UpdateACLDeprecatedCall {
    required bytes store_id = 1;
    repeated PBSubjectRolePair subject_role = 2;
}

// WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE remove this
message DeleteACLDeprecatedCall {
    required bytes store_id = 1;
    repeated string subject_list = 2;
}

message VerifyEmailCall {
    required string verification_code = 1;
}

message GetTeamServerUserIDReply {
    required string id = 1;
}

message RegisterDeviceCall {
    required bytes device_id = 1;

    // The Certification Signing Request generated by the client
    required bytes csr = 2;

    // WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE recertify code has been removed
    optional bool recertify_do_not_use = 3;

    // The following optional fields are for backward compatibility
    // WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE change them to required

    // Can be 'Windows', 'Mac OS X', 'Linux', 'Android', 'iOS'. See OSUtil.OSFamily.toString().
    // These strings are displayed to end users (DeviceRegistrationEmailer.java) and are used to
    // determine the icons (devices.mako).
    optional string os_family = 4;

    // Detailed OS names, e.g. 'Windows XP SP 1'
    optional string os_name = 5;

    optional string device_name = 6;
}

message RegisterDeviceReply {
    // The certificate issued by AeroFS CA
    required string cert = 1;
}

message ListOrganizationMembersCall {
    // Maximum number of entries returned on one page.
    // The SP server should enforce a reasonable upper bound for this parameter.
    required uint32 max_results = 1;

    // Offset to start retrieving the results.
    required uint32 offset = 2;
}

message ListOrganizationMembersReply {
    message PBUserAndLevel {
        required PBUser user = 1;
        required PBAuthorizationLevel level = 2;
    }

    // There will be at most 'max_results' entries
    repeated PBUserAndLevel user_and_level = 1;

    // Total number of users in the database.
    required uint32 total_count = 2;
}

message GetOrganizationIDReply {
    required string org_id = 1;
}

message GetAuthorizationLevelReply {
    required PBAuthorizationLevel level = 1;
}

message PBUser {
    // N.B. the user_email is assumed to be the user's unique ID on the SP Database
    required string user_email = 1;
    // TOOD (WW) use PBFullName
    required string first_name = 2;
    required string last_name = 3;
}

message SetAuthorizationLevelCall {
    required string user_email = 1;
    required PBAuthorizationLevel auth_level = 2;
}

enum PBAuthorizationLevel {
    USER       = 0;
    ADMIN      = 1;
}

message SendPasswordResetEmailCall {
    required string user_email = 1;
}

message ResetPasswordCall {
    // Token to be included in email
    required string password_reset_token = 1;
    required bytes new_credentials = 2;
}

message ChangePasswordCall {
    required bytes old_credentials = 1;
    required bytes new_credentials = 2;
}

message GetUserCRLCall {
    required uint64 crl_epoch = 1;
}

message GetUserCRLReply {
    required uint64 crl_epoch = 1;
    repeated uint64 serial = 2;
}

message GetCRLReply {
    repeated uint64 serial = 1;
}

message UnlinkDeviceCall {
    required bytes device_id = 1;
    required bool erase = 2;
}

message GetDeviceInfoCall {
    repeated bytes device_id = 1;
}

message GetDeviceInfoReply {

    // See also GetUserDevicesReply.PBDevice
    message PBDeviceInfo {
        // These fields are absent if:
        // 1) the device ID is not found, or
        // 2) the caller is not sharing any folder with the device owner.
        optional PBUser owner = 1;
        optional string device_name = 2;
    }

    repeated PBDeviceInfo device_info = 1;
}

message ListOrganizationSharedFoldersCall {
    // Maximum number of folders returned.
    required uint32 max_results = 1;

    // Offset into results
    required uint32 offset = 2;
}

message ListOrganizationSharedFoldersReply {
    repeated PBSharedFolder shared_folder = 1;

    // Total number of shared folders in the database
    required uint32 total_count = 2;
}

message ListUserSharedFoldersCall {
    required string user_id = 1;
}

message ListUserSharedFoldersReply {
    repeated PBSharedFolder shared_folder = 1;
}

message PBSharedFolder {

    message PBUserAndRole {
        // Since only the Web UI uses this method, we include the full name for pretty display.
        required PBUser user = 1;
        required PBRole role = 2;
    }

    required bytes store_id = 1;
    required string name = 2;
    // Whether any team member of the session user's team owns the folder
    required bool owned_by_team = 3;
    repeated PBUserAndRole user_and_role = 4;
}

message GetOrganizationInvitationsReply {
    message OrganizationInvitation {
        required string inviter = 1;
        required string organization_name = 2;
        required int32 organization_id = 3;
    }

    // Organizations the user has been invited to. Excludes the current organization and the default
    // organization.
    repeated OrganizationInvitation organization_invitations = 2;
}

// WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE. convert them to required fields
message GetOrgPreferencesReply {
    required string organization_name = 1;
    optional string organization_contact_phone = 2;
}

message SetOrgPreferencesCall {
    optional string org_name = 1;
    optional string organization_contact_phone = 2;
}

message SetUnsubscribeEmailCall {
    required string unsubscribe_token = 1;
}

message GetUnsubscribeEmailReply {
    required string email_id = 1;
}

message GetSharedFolderNamesCall {
    repeated bytes shared_id = 1;
}

message GetSharedFolderNamesReply {
    repeated string folder_name = 1;
}

// WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE: move this under AcceptOrganizationInvitationCall.
message DeleteOrganizationInvitationCall {
    required int32 organization_id = 1;
}

message DeleteOrganizationInvitationReply {
    // As the deletion causes the organization to lose one user, the Web server needs to adjust
    // the organization's subscription plan. However, because the current user doesn't belong to the
    // organization, the Web server doesn't have the permission to retrieve the organization's
    // subscription data which is necessary for the adjustment. Therefore, we return the
    // data in this reply.
    //
    // This design is not great. Ideally, SP should perform all Stripe transactions internally
    // without the Web server's involvement. See PBStripeData for more information.
    required PBStripeData stripe_data = 1;
}

// WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE: move this under the GetDeviceInfo messages.
message ListUserDevicesCall {
    required string user_id = 1;
}

// WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE: move this under the GetDeviceInfo messages.
message ListUserDevicesReply {

    // See also GetDeviceInfoReply.PBDeviceInfo
    message PBDevice {
        required bytes device_id = 1;
        required string device_name = 2;
        required string os_family = 3;
        required string os_name = 4;
    }

    repeated PBDevice device = 1;
}

message PBFullName {
    required string first_name = 1;
    required string last_name = 2;
}

message GetCommandQueueHeadCall {
    required bytes device_id = 1;
}

message GetCommandQueueHeadReply {
    optional Command command = 1;
    required int64 queue_size = 2;
}

message AckCommandQueueHeadCall {
    required bytes device_id = 1;
    required uint64 epoch = 2;
    required bool error = 3;
}

message AckCommandQueueHeadReply {
    // This command is the command now at the head of the queue. Included in the ack reply to
    // reduce the number of round trips when doing a full syncronization.
    optional Command command = 1;
    required int64 queue_size = 2;
}

message RecertifyDeviceCall {
    required bytes device_id = 1;
    required bytes csr = 2;
}

message RecertifyDeviceReply {
    // The certificate issued by AeroFS CA
    required string cert = 1;
}
