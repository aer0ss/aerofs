package sp;
option java_package = "com.aerofs.proto";
option optimize_for = LITE_RUNTIME; // remove reflection

import "common.proto";

/**
 * NOTE: When modifying the service declaration below, if you are not appending your new RPC
 * calls at the end of the declaration make sure to increment the SP_PROTOCOL_VERSION parameter
 * in C.java and the sp.version parameter in development.ini and production.ini (in src/web/)
 * and syncdet_test/lib/param.py
 */

service SPService {

    // Sets the message type used in case of errors
    rpc __error__(Void) returns(PBException);

    /**
     * Sign up a user without a signup code
     * The user will be marked as unverified, and an email verification code will be sent.
     *
     * Required Auth Level: none
     *
     * Throws:
     *   ExAlreadyExist if the email address is unavailable
     */
    rpc SignUp(SignUpCall) returns(Void);

    /**
     * Sign up a user using a targeted signup code.
     * Since the invitation has been delivered by mail, the user will be marked as verified.
     *
     * Required Auth Level: none
     *
     * Throws:
     *   ExAlreadyExist if the email address is unavailable
     *   ExNotFound if the targeted signup code was not found
     */
    rpc SignUpWithTargeted(SignUpWithTargetedCall) returns(Void);

    /**
     * Sign into the SP server. Return the authorization level of the caller.
     *
     * Required Auth Level: none
     *
     * Throws:
     *   ExBadCredential if username/password combination is incorrect, or in the case of the team
     *                   server, if they have not signed in successfully using mutual
     *                   authentication.
     */
    rpc SignIn(SignInCall) returns(Void);

    /**
     * Finds the email address associated with an signup code.
     *
     * Required Auth Level: none
     *
     * Throws:
     *   ExNotFound if the signup code wasn't found
     */
    rpc ResolveTargetedSignUpCode(ResolveTargetedSignUpCodeCall)
            returns (ResolveTargetedSignUpCodeReply);

    /**
     * Send a verification code to the user's email address. This function will be called
     * automatically when a user signs-up, but we may need to call again if the user
     * can't find the email (spam filter, etc...)
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExAlreadyExist if the user has already been verified
     */
     rpc SendEmailVerification(Void) returns(Void);

    /**
     * Checks an email verification code, and mark the email address as verified
     *
     * Required Auth Level: none (protected by the randomness of the verification code)
     *
     * Throws:
     *   ExNotFound if the verification code wasn't found
     *   ExAlreadyExist if the user has already been verified
     */
     rpc VerifyEmail(VerifyEmailCall) returns(Void);

    /**
     * Signs out of SP
     *
     * Required Auth Level: user
     */
    rpc SignOut(Void) returns (Void);

    /**
     * Creates a certificate for the specified device which is bound to the calling user. Creates
     * an entry in the device table when this is a new device, i.e. when the recertify flag is set
     * to false. When the recertify flag is set to true, a new device row will of course not be
     * added. In either case, once the certificate is created on the CA side, we will create an
     * entry in the certificate table.
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExNotFound  if you are trying to recertify a device that does not exist.
     *   ExNoPerm    if you are trying to recertify a device that does not belong to you.
     *   ExBadArgs   if the cname does not match the required format (hashed concatenation of user
     *               email, did).
     *   ExDeviceIDAlreadyExist if the device ID already exists
     */
    rpc CertifyDevice(CertifyDeviceCall) returns (CertifyDeviceReply);

    /**
     * Invite a person to become an AeroFS user. The will be entered into the default organization
     * The person will receive an email instructing him/her to download AeroFS. The email will also
     * contain a sign-up code to be used in the SignUpWithTargeted call. The user is silently
     * ignored if she is already an AeroFS user.
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExBadArgs if the caller does not specify one or more invitees.
     *   ExEmailSendingFailed if we were unable to send the invitation email.
     *   ExNoPerm if the user has used up their invitation quota.
     */
    rpc InviteToSignUp(InviteToSignUpCall) returns(Void);

    /**
     * Invite a person to become a member of the caller's organization. An email will be sent to the
     * requested user. When the user clicks on the link the admin panel will accept the organization
     * invite by calling the below rpc (AcceptOrganizationInvitation). At that point the user will
     * be moved in the new organization.
     *
     * Throws:
     *   ExAlreadyExist if the email address is already a member of that organization.
     *   ExAlreadyInvited if the user has already been invited to the organization but has not yet
     *                    accepted the invitation.
     *   ExNoPerm if the caller is not an organization admin.
     *   ExEmailSendingFailed if we were unable to send the email.
     */
     rpc InviteToOrganization(InviteToOrganizationCall) returns(Void);

    /**
     * Accept an organization invitation and move the caller into that organization. Makes
     * appropriate ACL updates to allow for team server sync.
     *
     * This call will also delete the pending organization invitation, since it has already been
     * acted upon.
     *
     * Throws:
     *   ExNotFound if the user does not have a pending invitation for the specified organization.
     *   ExAlreadyExist if the user is already a member of the target organization.
     */
    rpc AcceptOrganizationInvitation(AcceptOrganizationInvitationCall) returns(Void);

   /**
     * Shares a folder with another user.
     *
     * If the user doesn't exist yet, this method will automatically call InviteToSignUp
     * If the invitee email address is outside the organization's allowed domain, he
     * will be invited to the default organization. If the user is authorized to share
     * with the invitee, they will be sent an email notification.
     *
     * Only the sharer is added to the ACL for the newly created store. Invitees will be added
     * later, when they join the folder.
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExNoPerm if the sharee is (or would be created) in a different organization *and*
     *            sharing outside the organization isn't allowed for either the sharer or sharee
     *   ExNoPerm if the sharer isn't authorized to modify ACLs for the given SID
     *   TODO change the exception type below
     *   ExNoPerm if the caller's email address needs to be verified first.
     */
    rpc ShareFolder(ShareFolderCall) returns(Void);

    /**
     * Add the user to the shared folder corresponding to the invite code and returns its shareId
     * and folderName.
     *
     * NB: pushes ACL update to clients
     *
     * Calling this function with a valid shared folder code will set the user's email address
     * as verified.
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExNotFound if the shared folder code wasn't found
     *   ExNoPerm if the user email address doesn't match the email address specified in the invitation
     */
    rpc JoinSharedFolder(JoinSharedFolderCall) returns(Void);

    /**
     * Returns a list of pending shared folder invitations for the user
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExNoPerm if there is at least one pending invitaton and the user email address
     *            isn't be verified.
     */
    rpc ListPendingFolderInvitations(Void) returns(ListPendingFolderInvitationsReply);

    /**
     * Sends an email to the user
     *
     * Required Auth Level: user
     */
    rpc EmailUser(EmailUserCall) returns (Void);

    /**
     * Return the quota of AeroFS "heart menu" invites
     * This is a legacy of the old system and should disappear once we allow anyone to sign-up.
     *
     * Required Auth Level: user
     */
    rpc GetHeartInvitesQuota(Void) returns (GetHeartInvitesQuotaReply);

    /**
     * Get the user's preferences (name, device name, etc)
     *
     * Required Auth Level: user
     */
    rpc GetPreferences(GetPreferencesCall) returns (GetPreferencesReply);

    /**
     * Set the user's preferences (name, device name, etc)
     * Optional fields that aren't present won't be changed
     *
     * Required Auth Level: user
     */
    rpc SetPreferences(SetPreferencesCall) returns (Void);

    /**
     * Get the list of users in the system
     * Used by the admin panel
     *
     * Required Auth Level: admin
     *
     * Throws:
     *   ExNoPerm if the user does not have admin privileges
     */
    rpc ListUsers(ListUsersCall) returns(ListUsersReply);

    /**
     * Get the list of users with the desired authentication level in the system
     * Used by the admin panel
     *
     * Required Auth Level: admin
     *
     * Throws:
     *   ExNoPerm if the user does not have admin privileges
     */
    rpc ListUsersAuth(ListUsersAuthCall) returns(ListUsersReply);

    /**
     * Sends an email to a user with instructions to reset his password. The user
     * will be sent an email containing a link with a reset password token. The link
     * will take the user to a form when they can set a new password.
     * The reset_password token and the new password will be used in the ResetPassword
     * call.
     *
     * Required Auth Level: none
     *
     * Throws:
     *   Nothing... No feedback makes brute force attacks useless
     *
     */
    rpc SendPasswordResetEmail(SendPasswordResetEmailCall) returns(Void);

    /**
     * Reset a user's password. The user will already have received a reset_password token
     * via email.
     *
     * Required Auth Level: none
     *
     *
     * Throws:
     *   ExNotFound if the provided token has no associated user account
     */
    rpc ResetPassword(ResetPasswordCall) returns(Void);

    /**
     * Changes a users password.  The old password is replaced with the new password.
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExNoPerm   if the authorization requirements are not met
     *              if the old password is not correct
     *
     */
    rpc ChangePassword(ChangePasswordCall) returns(Void);

    /**
     * Set the user's authorization level for SP services
     *
     * Required Auth Level: admin
     * throws:
     *   ExNotFound if the provided user email has no AeroFS account set up.
     *   ExNoPerm   if the authorization requirements are not met,
     *              if the new authorization level exceeds that of the caller,
     *              if the caller does not belong to the same organization as the user email
     */
    rpc SetAuthorizationLevel(SetAuthorizationLevelCall) returns(Void);

    /**
     * Create a new organization
     *
     * Required Auth Level: (see below)
     *
     * Throws:
     *   ExNoPerm if the user calling is not a member of the default organization or is not an admin
     */
    rpc AddOrganization(AddOrganizationCall) returns(Void);

    /////////
    // these are internal API calls only (meant to be called by the daemon only)
    // Required Auth Level: user for all of them

    rpc GetACL(GetACLCall) returns (GetACLReply);
    rpc UpdateACL(UpdateACLCall) returns (Void);
    rpc DeleteACL(DeleteACLCall) returns (Void);

    /**
     * Get the certificate revocations relevant to a specific user, based on the certificate
     * revocation list epoch number.
     *
     * Required Auth Level: user
     */
    rpc GetUserCRL(GetUserCRLCall) returns(GetUserCRLReply);

    /**
     * Get global (full, non-user specific) certificate revocation list.
     */
    rpc GetCRL(Void) returns(GetCRLReply);

    /**
     * Revoke the certificate of a specific device. This will trigger a verkehr notification.
     *
     * Q. Why is this needed? Isn't it sufficient to manage users only by the ACL system?
     * A. Consider the case where a user quits AeroFS and we revoke all privileges via ACLs. Their
     * certs will still be valid but it won't matter due to the fact that they lack ACLs.
     * But then consider that the user could re-join aerofs with the same email address, then these
     * certs will be valid again, which would be bad.
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExNoPerm   if the user does not own the certificate that they are trying to revoke.
     *   ExNotFound if the user is trying to revoke certificate that does not exist.
     */
    rpc RevokeUserDeviceCertificate(RevokeUserDeviceCertificateCall) returns(Void);

    /**
     * Revoke all certificates belonging to one user. This will trigger a verkehr notification.
     *
     * Required Auth Level: user
     */
    rpc RevokeAllUserDeviceCertificates(Void) returns(Void);

    /**
     * Revoke the certificate of a specific team server. This will trigger a verkehr notification.
     *
     * Required Auth Level: admin
     *
     * Throws:
     *   ExNoPerm   if the user is not an admin of the organization that owns the team server.
     *   ExNotFound if the user is trying to revoke a certificate that does not exist.
     */
    rpc RevokeTeamServerDeviceCertificate(RevokeTeamServerDeviceCertificateCall) returns(Void);

    /**
     * Revoke all team server certificates in the callers organization. This will trigger a verkehr
     * notification.
     *
     * Required Auth Level: admin
     *
     * Throws:
     *   ExNoPerm if the user is not an admin of the organization.
     */
    rpc RevokeAllTeamServerDeviceCertificates(Void) returns(Void);

    /**
     * Get information about a device ID.
     *
     * Required Auth Level: user
     */
    rpc GetDeviceInfo(GetDeviceInfoCall) returns(GetDeviceInfoReply);

    /**
     * Get list of folders being shared by users in organization
     *
     * Throws:
     *   ExNoPerm       if the user calling this does not have admin privileges
     */
    rpc ListSharedFolders(ListSharedFoldersCall) returns(ListSharedFoldersReply);

    /**
     * Gets a list of organizations the user has been invited to, excluding their current
     * organization and the default organization.
     *
     * Required Auth Level: user
     */
    rpc GetOrganizationInvitations(Void) returns (GetOrganizationInvitationsReply);

    /**
     * Get the user's organization's preferences (organization name).
     *
     * Required Auth Level: user
     */
    rpc GetOrgPreferences(Void) returns (GetOrgPreferencesReply);

    /**
     * Set the user's organization's preferences (organization name).
     *
     * Required Auth Level: admin
     *
     * Throws:
     *   ExNoPerm if the user calling this does not have admin privileges
     */
    rpc SetOrgPreferences(SetOrgPreferencesCall) returns (Void);

    /**
     * Unsubscribe a user from email reminders based on the unsubscribe token id
     *
     * Required Auth Level: none
     */
    rpc UnsubscribeEmail(SetUnsubscribeEmailCall) returns (GetUnsubscribeEmailReply);

    /**
     * Return the auth level of the current user
     *
     * Required Auth Level: none
     */
    rpc GetAuthorizationLevel(Void) returns (GetAuthorizationLevelReply);

    /**
     * Setup the team server account:
     *
     *  1. If the user is in default organization, create a new organization.
     *     Else, if the user is not an admin, throw ExNoPerm.
     *  2. If the organization doesn't have a team server user account, create the user.
     *  3. Return the user ID.
     *
     * See the Team Server design doc for design rationale.
     *
     * Required Auth Level: (see below, same as AddOrganization)
     *
     * Throws:
     *   ExNoPerm   if the user calling is not a member of the default organization or is not
     *                  an admin
     */
    rpc GetTeamServerUserID(Void) returns (GetTeamServerUserIDReply);

    /**
     * Certify a Team Server's device certificate. It is different from the CertifyDevice call in
     * that the this call allows the user to certify the device under a user ID different from his
     * own ID. This call is needed only for setting up the team server. After setup, the server can
     * call CertifyDevice on its own.
     *
     * Required Auth Level: Admin
     *
     * Throws:
     *   ExDeviceIDAlreadyExist if the device ID already exists
     */
    rpc CertifyTeamServerDevice(CertifyTeamServerDeviceCall) returns (CertifyDeviceReply);

    /*
     * Fetch shared folder names
     *
     * Required Auth Level: user, ACL on all shared folders in request
     */
     rpc GetSharedFolderNames(GetSharedFolderNamesCall) returns(GetSharedFolderNamesReply);

    /**
     * TODO (downtime) move this under AcceptOrganizationInvite
     *
     * Ignore an invitation to a specific organization. This call deletes the entry in the
     * organization invitation table so that when the user views the pending organization invites
     * page in the admin panel, that organization will no longer appear in the list.
     *
     *
     * Throws:
     *   ExNotFound if the user does not have a pending invitation for the specified organization.
     */
    rpc IgnoreOrganizationInvitation(IgnoreOrganizationInvitationCall) returns(Void);
}

message SignUpCall {
    required string user_id = 1;
    required bytes credentials = 2; // hashed credentials (some combo of password, etc.)
    required string first_name = 3;
    required string last_name = 4;
}

message SignUpWithTargetedCall {
    required string targeted_signup_code = 1;
    required bytes credentials = 3; // hashed credentials (some combo of password, etc.)
    required string first_name = 4;
    required string last_name = 5;
}

message SignInCall {
    required string user_id = 1;
    optional bytes credentials = 2;
}

message ResolveTargetedSignUpCodeCall {
    required string tsc = 1;
}

message ResolveTargetedSignUpCodeReply {
    required string email_address = 1;
}

message VerifyBatchSignUpCodeCall {
    required string bsc = 1;
}

message CertifyDeviceCall {
    required bytes device_id = 1;
    required bytes csr = 2;
    required bool recertify = 3;
}

message CertifyDeviceReply {
    required string cert = 1;
}

message InviteToSignUpCall {
    repeated string email_addresses = 1;
}

message InviteToOrganizationCall {
    required string email_address = 1;
}

message AcceptOrganizationInvitationCall {
    required int32 organization_id = 1;
}

message ShareFolderCall {
    // name of the folder being shared
    required string folder_name = 3;

    required bytes share_id = 2;

    // SubjectRolePair of the person with whom we want to share
    // The client (desktop/admin panel/...) is responsible for choosing the default role of
    // invited users. This has better transactional properties than inviting then changing
    // the roles of invited users in a subsequent call.
    // TODO: repeated field now to ease transition. Switch to single subject_role after
    repeated PBSubjectRolePair subject_role = 1;

    // Message to the person
    optional string note = 4;
}

message JoinSharedFolderCall {
    required string shared_folder_code = 1;
}

message ListPendingFolderInvitationsReply {

    message PBFolderInvitation {
        required string sharer = 1;       // email address of the sharer
        required string folder_name = 2;
        required string shared_folder_code = 3;
    }

    repeated PBFolderInvitation invitations = 1;
}


message EmailUserCall {
    required string subject = 1;
    required string body = 2;
}

message GetHeartInvitesQuotaReply {
    required uint32 count = 1;
}

message GetPreferencesCall {
    required bytes device_id = 1;
}

message GetPreferencesReply {
    required string first_name = 1;
    required string last_name = 2;
    required string device_name = 3;
}

message SetPreferencesCall {
    optional string first_name = 2;
    optional string last_name = 4;

    // if set, it doesn't change the device id, but it allows setting
    // the device name (below)
    optional bytes device_id = 1;

    // valid iff device_id is present
    optional string device_name = 3;
}

message GetACLCall {
    required uint64 epoch = 1;
}

message GetACLReply {
    message PBStoreACL {
        required bytes store_id = 1;
        repeated PBSubjectRolePair subject_role = 2;
    }

    repeated PBStoreACL store_acl = 1;
    required uint64 epoch = 2;
}

message UpdateACLCall {
    required bytes store_id = 1;
    repeated PBSubjectRolePair subject_role = 2;
}

message DeleteACLCall {
    required bytes store_id = 1;
    repeated string subject_list = 2;
}

message VerifyEmailCall {
    required string verification_code = 1;
}

message GetTeamServerUserIDReply {
    required string id = 1;
}

message CertifyTeamServerDeviceCall {
    required bytes device_id = 1;
    required bytes csr = 2;
}

message ListUsersCall {
    // Return only users whose name match this string. Empty string matches all users.
    optional string search = 1;

    // Maximum number of users returned on one page.
    // The SP server should enforce a reasonable upper bound for this parameter (like 1000)
    required int32 max_results = 2;

    // Offset to start retrieving the results
    required int32 offset = 3;
}

message ListUsersReply {
    // A subset of the users. There will be at most 'max_results' users
    repeated PBUser users = 1;

    // Total number of users in the database
    required int32 total_count = 2;

    // Total number of users in the database that match the 'search' parameter
    required int32 filtered_count = 3;
}

message ListUsersAuthCall {
    // Return only admins whose name match this string. Empty string matches all admins
    optional string search = 1;

    // Authentication level of the users that we want to fetch
    required PBAuthorizationLevel auth_level = 2;

    // Maximum number of admins returned on one page
    required int32 max_results = 3;

    // Offet to start retrieving the results
    required int32 offset = 4;
}

message GetAuthorizationLevelReply {
    required PBAuthorizationLevel level = 1;
}

message PBUser {
    // N.B. the user_email is assumed to be the user's unique ID on the SP Database
    required string user_email = 1;
    required string first_name = 2;
    required string last_name = 3;
}

message SetAuthorizationLevelCall {
    required string user_email = 1;
    required PBAuthorizationLevel auth_level = 2;
}

enum PBAuthorizationLevel {
    USER       = 0;
    ADMIN      = 1;
}

message AddOrganizationCall {
    required string org_name = 1;
}

message SendPasswordResetEmailCall {
    required string user_email = 1;
}

message ResetPasswordCall {
    // Token to be included in email
    required string password_reset_token = 1;
    required bytes new_credentials = 2;
}

message ChangePasswordCall {
    required bytes old_credentials = 1;
    required bytes new_credentials = 2;
}

message GetUserCRLCall {
    required uint64 crl_epoch = 1;
}

message GetUserCRLReply {
    required uint64 crl_epoch = 1;
    repeated uint64 serial = 2;
}

message GetCRLReply {
    repeated uint64 serial = 1;
}

message RevokeUserDeviceCertificateCall {
    required bytes device_id = 1;
}

message RevokeTeamServerDeviceCertificateCall {
    required bytes device_id = 1;
}

message GetDeviceInfoCall {
    repeated bytes device_id = 1;
}

message GetDeviceInfoReply {

    message PBDeviceInfo {
        // These fields are absent if:
        // 1) the device ID is not found, or
        // 2) the caller is not sharing any folder with the device owner.
        optional PBUser owner = 1;
        optional string device_name = 2;
    }

    repeated PBDeviceInfo device_info = 1;
}

message ListSharedFoldersCall {
    // Maximum number of folders returned.
    optional int32 max_results = 1 [default = 100];

    // Offset into results
    optional int32 offset = 2;
}

message ListSharedFoldersReply {
    message PBSharedFolder {
        required bytes store_id = 1;                   // store id (unique identifier)
        required string name = 2;                      // folder name (user facing)
        repeated PBSubjectRolePair subject_role = 3;   // list of users
    }

    repeated PBSharedFolder shared_folders = 1;

    // Total number of shared folders in the database for this organization
    required int32 total_count = 2;
}

message GetOrganizationInvitationsReply {
    message OrganizationInvitation {
        required string inviter = 1;
        required string organization_name = 2;
        required int32 organization_id = 3;
    }

    // Organizations the user has been invited to. Excludes the current organization and the default
    // organization.
    repeated OrganizationInvitation organization_invitations = 2;
}

message GetOrgPreferencesReply {
    // The users current organization.
    required string organization_name = 1;
}

message SetOrgPreferencesCall {
    optional string org_name = 1;
}

message SetUnsubscribeEmailCall {
    required string unsubscribe_token = 1;
}

message GetUnsubscribeEmailReply {
    required string email_id = 1;
}

message GetSharedFolderNamesCall {
    repeated bytes shared_id = 1;
}

message GetSharedFolderNamesReply {
    repeated string folder_name = 1;
}

// TODO (downtime) move this under AcceptOrganizationInvitationCall
message IgnoreOrganizationInvitationCall {
    required int32 organization_id = 1;
}
