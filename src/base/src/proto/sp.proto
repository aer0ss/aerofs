package sp;
option java_package = "com.aerofs.proto";
option optimize_for = LITE_RUNTIME; // remove reflection

import "common.proto";
import "cmd.proto";

/**
 * NOTE: When modifying the service declaration below, if you are not appending your new RPC
 * calls at the end of the declaration make sure to increment the SP_PROTOCOL_VERSION parameter
 * in C.java and the sp.version parameter in development.ini and production.ini (in src/web/)
 * and syncdet_test/lib/param.py
 */

service SPService {

    // Sets the message type used in case of errors
    rpc __error__(Void) returns(PBException);

    /**
     * Request to sign up a user and enable business plan. The method sends an email to the user
     * with a sign-up link. After the user signs up, the user is directed to the payment page.
     *
     * No-op if the user exists. Do not throw ExAlreadyExist to avoid leaking email information to
     * attackers.
     *
     * Required Auth Level: none
     */
    rpc RequestToSignUpWithBusinessPlan(RequestToSignUpWithBusinessPlanCall) returns(Void);

    /**
     * Sign up a user using a signup code.
     *
     * No-op if the user already exists and the password matches the existing user's password.
     * This is needed for the business users to retry signing up using the link in their email.
     * That link points to the user signup page with business signup as the followup page.
     *
     * Required Auth Level: none
     *
     * Throws:
     *   ExAlreadyExist if the email address is unavailable
     *   ExNotFound if the targeted signup code was not found
     *   ExBadCredential if the user exists and the password doesn't match the existing user
     */
    rpc SignUpWithCode(SignUpWithCodeCall) returns(Void);

    /**
     * Sign into the SP server. Return the authorization level of the caller.
     *
     * Required Auth Level: none
     *
     * Throws:
     *   ExBadCredential if username/password combination is incorrect, or in the case of the team
     *                   server, if they have not signed in successfully using mutual
     *                   authentication.
     */
    rpc SignIn(SignInCall) returns(Void);

    /**
     * Finds the email address associated with an signup code.
     *
     * Required Auth Level: none
     *
     * Throws:
     *   ExNotFound if the signup code wasn't found
     */
    rpc ResolveSignUpCode(ResolveSignUpCodeCall)
            returns (ResolveSignUpCodeReply);

    /**
     * Send a verification code to the user's email address. This function will be called
     * automatically when a user signs-up, but we may need to call again if the user
     * can't find the email (spam filter, etc...)
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExAlreadyExist if the user has already been verified
     */
     rpc SendEmailVerification(Void) returns(Void);

    /**
     * Checks an email verification code, and mark the email address as verified
     *
     * Required Auth Level: none (protected by the randomness of the verification code)
     *
     * Throws:
     *   ExNotFound if the verification code wasn't found
     *   ExAlreadyExist if the user has already been verified
     */
     rpc VerifyEmail(VerifyEmailCall) returns(Void);

    /**
     * Signs out of SP
     *
     * Required Auth Level: user
     */
    rpc SignOut(Void) returns (Void);

    /**
     * Creates a certificate for the specified device which is bound to the calling user. Creates
     * an entry in the device table when this is a new device, i.e. when the recertify flag is set
     * to false. When the recertify flag is set to true, a new device row will of course not be
     * added. In either case, once the certificate is created on the CA side, we will create an
     * entry in the certificate table.
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExNotFound  if you are trying to recertify a device that does not exist.
     *   ExNoPerm    if you are trying to recertify a device that does not belong to you.
     *   ExBadArgs   if the cname does not match the required format (hashed concatenation of user
     *               email, did).
     *   ExDeviceIDAlreadyExist if the device ID already exists
     */
    rpc CertifyDevice(CertifyDeviceCall) returns (CertifyDeviceReply);

    /**
     * Invite a person to become an AeroFS user. The will be entered into the default organization
     * The person will receive an email instructing him/her to download AeroFS. The email will also
     * contain a sign-up code to be used in the SignUpWithCode call. The user is silently
     * ignored if she is already an AeroFS user.
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExBadArgs if the caller does not specify one or more invitees.
     *   ExEmailSendingFailed if we were unable to send the invitation email.
     *   ExNoPerm if the user has used up their invitation quota.
     */
    rpc InviteToSignUp(InviteToSignUpCall) returns(Void);

    /**
     * Invite a person to become a member of the caller's organization. An email will be sent to the
     * requested user. When the user clicks on the link the admin panel will accept the organization
     * invite by calling the below rpc (AcceptOrganizationInvitation). At that point the user will
     * be moved in the new organization.
     *
     * Throws:
     *   ExAlreadyExist if the email address is already a member of that organization.
     *   ExAlreadyInvited if the user has already been invited to the organization but has not yet
     *                    accepted the invitation.
     *   ExNoPerm if the caller is not an organization admin.
     *   ExEmailSendingFailed if we were unable to send the email.
     */
     rpc InviteToOrganization(InviteToOrganizationCall) returns(Void);

    /**
     * Accept an organization invitation and move the caller into that organization. Makes
     * appropriate ACL updates to allow for team server sync.
     *
     * This call will also delete the pending organization invitation, since it has already been
     * acted upon.
     *
     * Throws:
     *   ExNotFound if the user does not have a pending invitation for the specified organization.
     *   ExAlreadyExist if the user is already a member of the target organization.
     */
    rpc AcceptOrganizationInvitation(AcceptOrganizationInvitationCall) returns(Void);

   /**
     * Shares a folder with another user.
     *
     * If the user doesn't exist yet, this method will automatically call InviteToSignUp
     * If the invitee email address is outside the organization's allowed domain, he
     * will be invited to the default organization. If the user is authorized to share
     * with the invitee, they will be sent an email notification.
     *
     * Only the sharer is added to the ACL for the newly created store. Invitees will be added
     * later, when they join the folder.
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExNoPerm if the sharee is (or would be created) in a different organization *and*
     *            sharing outside the organization isn't allowed for either the sharer or sharee
     *   ExNoPerm if the sharer isn't authorized to modify ACLs for the given SID
     *   TODO change the exception type below
     *   ExNoPerm if the caller's email address needs to be verified first.
     */
    rpc ShareFolder(ShareFolderCall) returns(Void);

    /**
     * Add the user to a shared folder (provided he/she was invited).
     *
     * NB: pushes ACL update to clients
     *
     * Calling this function with a valid shared folder code will set the user's email address
     * as verified.
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExNotFound if the shared folder code wasn't found
     *   ExNoPerm if the user was not invited to the shared folder
     */
    rpc JoinSharedFolder(JoinSharedFolderCall) returns(Void);

    /**
     * Ignore an invite to a shared folder.
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExNotFound if the shared folder does not exist.
     *   ExNoPerm if the user has not been invited to this shared folder.
     *   ExAlreadyExist if the user is already a member of this shared folder.
     */
    rpc IgnoreSharedFolderInvitation(IgnoreSharedFolderCall) returns(Void);

    /**
     * Remove the user from a shared folder (provided he/she was a member).
     *
     * NB: pushes ACL update to clients
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExNotFound if the shared folder wasn't found.
     *   ExNoPerm if the user was not invited to the shared folder.
     */
    rpc LeaveSharedFolder(LeaveSharedFolderCall) returns(Void);

    /**
     * Returns a list of pending shared folder invitations for the user
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExNoPerm if there is at least one pending invitaton and the user email address
     *            hasn't be verified.
     */
    rpc ListPendingFolderInvitations(Void) returns(ListPendingFolderInvitationsReply);

    /**
     * Sends an email to the user.
     *
     * Required Auth Level: user
     */
    rpc EmailUser(EmailUserCall) returns (Void);

    /**
     * WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE: remove this method
     */
    rpc Noop(Void) returns (GetHeartInvitesQuotaReply);

    /**
     * Get the user's preferences (name, device name, etc)
     *
     * Required Auth Level: user
     */
    rpc GetPreferences(GetPreferencesCall) returns (GetPreferencesReply);

    /**
     * TODO (MP) send verkehr notification(s) when we change the device name.
     *
     * Set the user's preferences (name, device name, etc). Optional fields that aren't present
     * won't be changed.
     *
     * Required Auth Level: user
     */
    rpc SetPreferences(SetPreferencesCall) returns (Void);

    /**
     * Get the list of users in the system
     * Used by the admin panel
     *
     * Required Auth Level: admin
     *
     * Throws:
     *   ExNoPerm if the user does not have admin privileges
     */
    rpc ListUsers(ListUsersCall) returns(ListUsersReply);

    /**
     * Get the list of users with the desired authentication level in the system
     * Used by the admin panel
     *
     * Required Auth Level: admin
     *
     * Throws:
     *   ExNoPerm if the user does not have admin privileges
     */
    rpc ListUsersAuth(ListUsersAuthCall) returns(ListUsersReply);

    /**
     * Sends an email to a user with instructions to reset his password. The user
     * will be sent an email containing a link with a reset password token. The link
     * will take the user to a form when they can set a new password.
     * The reset_password token and the new password will be used in the ResetPassword
     * call.
     *
     * Required Auth Level: none
     *
     * Throws:
     *   Nothing... No feedback makes brute force attacks useless
     *
     */
    rpc SendPasswordResetEmail(SendPasswordResetEmailCall) returns(Void);

    /**
     * Reset a user's password. The user will already have received a reset_password token
     * via email.
     *
     * Required Auth Level: none
     *
     *
     * Throws:
     *   ExNotFound if the provided token has no associated user account
     */
    rpc ResetPassword(ResetPasswordCall) returns(Void);

    /**
     * Changes a users password.  The old password is replaced with the new password.
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExNoPerm   if the authorization requirements are not met
     *              if the old password is not correct
     *
     */
    rpc ChangePassword(ChangePasswordCall) returns(Void);

    /**
     * Set the user's authorization level for SP services
     *
     * Required Auth Level: admin
     * throws:
     *   ExNotFound if the provided user email has no AeroFS account set up.
     *   ExNoPerm   if the authorization requirements are not met,
     *              if the new authorization level exceeds that of the caller,
     *              if the caller does not belong to the same organization as the user email
     */
    rpc SetAuthorizationLevel(SetAuthorizationLevelCall) returns(Void);

    /**
     * Create a new organization
     *
     * Required Auth Level: (see below)
     *
     * Throws:
     *   ExNoPerm if the user calling is not a member of the default organization or is not an admin
     */
    rpc AddOrganization(AddOrganizationCall) returns(Void);

    /////////
    // these are internal API calls only (meant to be called by the daemon only)
    // Required Auth Level: user for all of them

    rpc GetACL(GetACLCall) returns (GetACLReply);
    rpc UpdateACL(UpdateACLCall) returns (Void);
    rpc DeleteACL(DeleteACLCall) returns (Void);

    /**
     * Get the certificate revocations relevant to a specific user, based on the certificate
     * revocation list epoch number.
     *
     * Required Auth Level: user
     */
    rpc GetUserCRL(GetUserCRLCall) returns(GetUserCRLReply);

    /**
     * Get global (full, non-user specific) certificate revocation list.
     */
    rpc GetCRL(Void) returns(GetCRLReply);

    /**
     * Revoke the certificate of a specific device. This will trigger a verkehr notification for the
     * CRL.
     *
     * Q. Why is this needed? Isn't it sufficient to manage users only by the ACL system?
     * A. Consider the case where a user quits AeroFS and we revoke all privileges via ACLs. Their
     * certs will still be valid but it won't matter due to the fact that they lack ACLs.
     * But then consider that the user could re-join aerofs with the same email address, then these
     * certs will be valid again, which would be bad.
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExNoPerm   if the user does not own the certificate that they are trying to revoke.
     *   ExNotFound if the user is trying to revoke certificate that does not exist.
     */
    rpc UnlinkUserDevice(UnlinkUserDeviceCall) returns(Void);

    // WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE: remove this.
    rpc UnlinkAllUserDevices(Void) returns(Void);

    /**
     * Revoke the certificate of a specific team server. This will trigger a verkehr notification
     * for the CRL.
     *
     * Required Auth Level: admin
     *
     * Throws:
     *   ExNoPerm   if the user is not an admin of the organization that owns the team server.
     *   ExNotFound if the user is trying to revoke a certificate that does not exist.
     *   ExBadArgs  if the device specified does not belong to the team server user.
     */
    rpc UnlinkTeamServerDevice(UnlinkTeamServerDeviceCall) returns(Void);

    // WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE: remove this.
    rpc UnlinkAllTeamServerDevices(Void) returns(Void);

    /**
     * Get information about a device ID.
     *
     * Required Auth Level: user
     */
    rpc GetDeviceInfo(GetDeviceInfoCall) returns(GetDeviceInfoReply);

    /**
     * Get list of folders being shared by users in organization. See also: ListUserSharedFolders
     *
     * Required Auth Level: admin
     */
    rpc ListOrganizationSharedFolders(ListOrganizationSharedFoldersCall)
            returns(ListOrganizationSharedFoldersReply);

    /**
     * Gets a list of organizations the user has been invited to, excluding their current
     * organization and the default organization.
     *
     * Required Auth Level: user
     */
    rpc GetOrganizationInvitations(Void) returns (GetOrganizationInvitationsReply);

    /**
     * Get the user's organization's preferences (organization name).
     *
     * Required Auth Level: user
     */
    rpc GetOrgPreferences(Void) returns (GetOrgPreferencesReply);

    /**
     * Set the user's organization's preferences (organization name).
     *
     * Required Auth Level: admin
     *
     * Throws:
     *   ExNoPerm if the user calling this does not have admin privileges
     */
    rpc SetOrgPreferences(SetOrgPreferencesCall) returns (Void);

    /**
     * Unsubscribe a user from email reminders based on the unsubscribe token id
     *
     * Required Auth Level: none
     */
    rpc UnsubscribeEmail(SetUnsubscribeEmailCall) returns (GetUnsubscribeEmailReply);

    /**
     * Return the auth level of the current user
     *
     * Required Auth Level: none
     */
    rpc GetAuthorizationLevel(Void) returns (GetAuthorizationLevelReply);

    /**
     * Setup the team server account:
     *
     *  1. If the user is in default organization, create a new organization.
     *     Else, if the user is not an admin, throw ExNoPerm.
     *  2. If the organization doesn't have a team server user account, create the user.
     *  3. Return the user ID.
     *
     * See the Team Server design doc for design rationale.
     *
     * Required Auth Level: (see below, same as AddOrganization)
     *
     * Throws:
     *   ExNoPerm   if the user calling is not a member of the default organization or is not
     *                  an admin
     */
    rpc GetTeamServerUserID(Void) returns (GetTeamServerUserIDReply);

    /**
     * Certify a Team Server's device certificate. It is different from the CertifyDevice call in
     * that the this call allows the user to certify the device under a user ID different from his
     * own ID. This call is needed only for setting up the team server. After setup, the server can
     * call CertifyDevice on its own.
     *
     * Required Auth Level: Admin
     *
     * Throws:
     *   ExDeviceIDAlreadyExist if the device ID already exists
     */
    rpc CertifyTeamServerDevice(CertifyTeamServerDeviceCall) returns (CertifyDeviceReply);

    /*
     * Fetch shared folder names
     *
     * Required Auth Level: user, ACL on all shared folders in request
     */
     rpc GetSharedFolderNames(GetSharedFolderNamesCall) returns(GetSharedFolderNamesReply);

    /**
     * TODO (downtime) move this under AcceptOrganizationInvite
     *
     * Ignore an invitation to a specific organization. This call deletes the entry in the
     * organization invitation table so that when the user views the pending organization invites
     * page in the admin panel, that organization will no longer appear in the list.
     *
     *
     * Throws:
     *   ExNotFound if the user does not have a pending invitation for the specified organization.
     */
    rpc IgnoreOrganizationInvitation(IgnoreOrganizationInvitationCall) returns(Void);

    /**
     * Extend the tomcat session. Does not throw, since we are guaranteed by tomcat that the session
     * will exist in the tracker.
     *
     * Required Auth Level: user
     */
    rpc ExtendSession(Void) returns(Void);

    /**
     * WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE: move this under GetDeviceInfo.
     *
     * List all user devices (used in the admin panel device management page).
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExBadArgs: if the offset is negative or max results is too large.
     */
    rpc ListUserDevices(ListUserDevicesCall) returns(ListUserDevicesReply);

    /**
     * Retrieve the Stripe Customer ID associated with the organization that the current
     * AeroFS user is a member of.
     *
     * Required Auth Level: admin
     */
    rpc GetStripeCustomerID(Void) returns(GetStripeCustomerIDReply);

    /**
     * WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE: move this under ListOrganizationSharedFolders
     *
     * Get list of folders being shared by a specified user. If the specified user is not the
     * current user, the current user must be the admin of the organization the specified user
     * belongs to.
     *
     * See also: ListOrganizationSharedFolders
     *
     * Required Auth Level: user or admin (see above)
     *
     * Throws:
     *   ExNoPerm       if the user calling this does not have enough privileges (see above)
     */
    rpc ListUserSharedFolders(ListUserSharedFoldersCall) returns(ListUserSharedFoldersReply);

    /**
     * List all the users who have been invited to the current user's organization.
     *
     * Required Auth Level: admin
     */
     rpc ListOrganizationInvitedUsers(Void) returns(ListOrganizationInvitedUsersReply);

    /**
     * Get the head of the command queue for a given device.
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExNotFound: if the specified device does not exist or does not belong to you.
     */
    rpc GetCommandQueueHead(GetCommandQueueHeadCall) returns(GetCommandQueueHeadReply);

    /**
     * Acknowledge the command at the head of the command queue for a given device. If the client
     * is unable to process the command they should specify error = true and the command will be
     * retried later.
     *
     * To reduce the number of messages transferred this call also returns the new head of this
     * device's command queue.
     *
     * Required Auth Level: user
     *
     * Throws:
     *   ExNotFound: if the specified device does not exist or does not belong to you.
     */
    rpc AckCommandQueueHead(AckCommandQueueHeadCall) returns(AckCommandQueueHeadReply);
}

message ListOrganizationInvitedUsersReply {
    repeated string user_id = 1;
}

message GetStripeCustomerIDReply {
    // The field is absent if the organization doesn't have a Customer ID.
    optional string stripe_customer_id = 1;
}

message SignUpWithCodeCall {
    required string signup_code = 1;
    required bytes credentials = 3; // hashed credentials (some combo of password, etc.)
    // TOOD (WW) use PBFullName
    required string first_name = 4;
    required string last_name = 5;
}

message SignInCall {
    required string user_id = 1;
    optional bytes credentials = 2;
}

message ResolveSignUpCodeCall {
    required string code = 1;
}

message ResolveSignUpCodeReply {
    required string email_address = 1;
}

message VerifyBatchSignUpCodeCall {
    required string bsc = 1;
}

message CertifyDeviceCall {
    required bytes device_id = 1;
    required bytes csr = 2;
    // WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE
    // DEPRECATED: (PH) recertify code has been removed. It will be added back in as a new call.
    required bool recertify_do_not_use= 3;
}

message CertifyDeviceReply {
    required string cert = 1;
}

message InviteToSignUpCall {
    repeated string email_addresses = 1;
}

message RequestToSignUpWithBusinessPlanCall {
    required string email_address = 1;
}

message InviteToOrganizationCall {
    required string email_address = 1;
}

message AcceptOrganizationInvitationCall {
    required int32 organization_id = 1;
}

message ShareFolderCall {
    // name of the folder being shared
    required string folder_name = 3;

    required bytes share_id = 2;

    // SubjectRolePair of the person with whom we want to share
    // The client (desktop/admin panel/...) is responsible for choosing the default role of
    // invited users. This has better transactional properties than inviting then changing
    // the roles of invited users in a subsequent call.
    // TODO: repeated field now to ease transition. Switch to single subject_role after
    repeated PBSubjectRolePair subject_role = 1;

    // Message to the person
    optional string note = 4;
}

message JoinSharedFolderCall {
    required bytes shared_id = 1;
}

message IgnoreSharedFolderCall {
    required bytes shared_id = 1;
}

message LeaveSharedFolderCall {
    required bytes shared_id = 1;
}

message ListPendingFolderInvitationsReply {
    repeated PBFolderInvitation invitation = 1;
}

message EmailUserCall {
    required string subject = 1;
    required string body = 2;
}

// WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE: remove it
message GetHeartInvitesQuotaReply {
    required uint32 count = 1;
}

message GetPreferencesCall {
    required bytes device_id = 1;
}

message GetPreferencesReply {
    // TOOD (WW) use PBFullName
    required string first_name = 1;
    required string last_name = 2;
    required string device_name = 3;
}

message SetPreferencesCall {
    // TOOD (WW) use PBFullName
    optional string first_name = 2;
    optional string last_name = 4;

    // If set, it doesn't change the device id, but it allows setting the device name (below).
    optional bytes device_id = 1;

    // Valid iff device_id is present.
    optional string device_name = 3;
}

message GetACLCall {
    required uint64 epoch = 1;
}

message GetACLReply {
    message PBStoreACL {
        required bytes store_id = 1;
        repeated PBSubjectRolePair subject_role = 2;
    }

    repeated PBStoreACL store_acl = 1;
    required uint64 epoch = 2;
}

message UpdateACLCall {
    required bytes store_id = 1;
    repeated PBSubjectRolePair subject_role = 2;
}

message DeleteACLCall {
    required bytes store_id = 1;
    repeated string subject_list = 2;
}

message VerifyEmailCall {
    required string verification_code = 1;
}

message GetTeamServerUserIDReply {
    required string id = 1;
}

message CertifyTeamServerDeviceCall {
    required bytes device_id = 1;
    required bytes csr = 2;
}

message ListUsersCall {
    // Return only users whose name match this string. Empty string matches all users.
    optional string search = 1;

    // Maximum number of users returned on one page.
    // The SP server should enforce a reasonable upper bound for this parameter (like 1000).
    required uint32 max_results = 2;

    // Offset to start retrieving the results.
    required uint32 offset = 3;
}

message ListUsersReply {
    // A subset of the users. There will be at most 'max_results' users.
    repeated PBUser users = 1;

    // Total number of users in the database.
    required uint32 total_count = 2;

    // Total number of users in the database that match the 'search' parameter.
    required uint32 filtered_count = 3;
}

message ListUsersAuthCall {
    // TODO (WW) remove search, auth_level, max_result, and offset
    // Return only admins whose name match this string. Empty string matches all admins.
    optional string search = 1;

    // Authentication level of the users that we want to fetch.
    required PBAuthorizationLevel auth_level = 2;

    // Maximum number of admins returned on one page.
    required uint32 max_results = 3;

    // Offet to start retrieving the results.
    required uint32 offset = 4;
}

message GetAuthorizationLevelReply {
    required PBAuthorizationLevel level = 1;
}

message PBUser {
    // N.B. the user_email is assumed to be the user's unique ID on the SP Database
    required string user_email = 1;
    // TOOD (WW) use PBFullName
    required string first_name = 2;
    required string last_name = 3;
}

message SetAuthorizationLevelCall {
    required string user_email = 1;
    required PBAuthorizationLevel auth_level = 2;
}

enum PBAuthorizationLevel {
    USER       = 0;
    ADMIN      = 1;
}

message AddOrganizationCall {
    required string organization_name = 1;
    required string organization_contact_phone = 2;
    required string stripe_customer_id = 3;
}

message SendPasswordResetEmailCall {
    required string user_email = 1;
}

message ResetPasswordCall {
    // Token to be included in email
    required string password_reset_token = 1;
    required bytes new_credentials = 2;
}

message ChangePasswordCall {
    required bytes old_credentials = 1;
    required bytes new_credentials = 2;
}

message GetUserCRLCall {
    required uint64 crl_epoch = 1;
}

message GetUserCRLReply {
    required uint64 crl_epoch = 1;
    repeated uint64 serial = 2;
}

message GetCRLReply {
    repeated uint64 serial = 1;
}

message UnlinkUserDeviceCall {
    required bytes device_id = 1;
}

message UnlinkTeamServerDeviceCall {
    required bytes device_id = 1;
}

message GetDeviceInfoCall {
    repeated bytes device_id = 1;
}

message GetDeviceInfoReply {

    message PBDeviceInfo {
        // These fields are absent if:
        // 1) the device ID is not found, or
        // 2) the caller is not sharing any folder with the device owner.
        optional PBUser owner = 1;
        optional string device_name = 2;
    }

    repeated PBDeviceInfo device_info = 1;
}

message ListOrganizationSharedFoldersCall {
    // Maximum number of folders returned.
    required uint32 max_results = 1;

    // Offset into results
    required uint32 offset = 2;
}

message ListOrganizationSharedFoldersReply {
    repeated PBSharedFolder shared_folder = 1;

    // Total number of shared folders in the database
    required uint32 total_count = 2;
}

message ListUserSharedFoldersCall {
    required string user_id = 1;
}

message ListUserSharedFoldersReply {
    repeated PBSharedFolder shared_folder = 1;
}

message PBSharedFolder {

    message PBUserAndRole {
        // Since only the Web UI uses this method, we include the full name for pretty display.
        required PBUser user = 1;
        required PBRole role = 2;
    }

    required bytes store_id = 1;
    required string name = 2;
    repeated PBUserAndRole user_and_role = 3;
}

message GetOrganizationInvitationsReply {
    message OrganizationInvitation {
        required string inviter = 1;
        required string organization_name = 2;
        required int32 organization_id = 3;
    }

    // Organizations the user has been invited to. Excludes the current organization and the default
    // organization.
    repeated OrganizationInvitation organization_invitations = 2;
}

// WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE. convert them to required fields
message GetOrgPreferencesReply {
    required string organization_name = 1;
    optional string organization_contact_phone = 2;
}

message SetOrgPreferencesCall {
    optional string org_name = 1;
    optional string organization_contact_phone = 2;
}

message SetUnsubscribeEmailCall {
    required string unsubscribe_token = 1;
}

message GetUnsubscribeEmailReply {
    required string email_id = 1;
}

message GetSharedFolderNamesCall {
    repeated bytes shared_id = 1;
}

message GetSharedFolderNamesReply {
    repeated string folder_name = 1;
}

// WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE: move this under AcceptOrganizationInvitationCall.
message IgnoreOrganizationInvitationCall {
    required int32 organization_id = 1;
}

// WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE: move this under the GetDeviceInfo messages.
message ListUserDevicesCall {
    // TODO (WW) remove search, offset, and max results
    // Return only users whose name match this string. Empty string matches all users.
    required string search = 1;

    // Maximum number of users returned on one page.
    required int32 max_results = 2;

    // Offset to start retrieving the results.
    required int32 offset = 3;
}

// WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE: move this under the GetDeviceInfo messages.
message ListUserDevicesReply {
    message PBDeviceInfo {
        required string device_name = 1;
        required string os = 2;
        required bytes device_id = 3;
    }

    // List of device names.
    repeated PBDeviceInfo device_info = 1;

    // Total number of users in the database.
    required uint32 total_count = 2;

    // Total number of users in the database that match the 'search' parameter.
    required uint32 filtered_count = 3;
}

message PBFullName {
    required string first_name = 1;
    required string last_name = 2;
}

message GetCommandQueueHeadCall {
    required bytes device_id = 1;
}

message GetCommandQueueHeadReply {
    optional Command command = 1;
    required int64 queue_size = 2;
}

message AckCommandQueueHeadCall {
    required bytes device_id = 1;
    required uint64 epoch = 2;
    required bool error = 3;
}

message AckCommandQueueHeadReply {
    // This command is the command now at the head of the queue. Included in the ack reply to
    // reduce the number of round trips when doing a full syncronization.
    optional Command command = 1;
    required int64 queue_size = 2;
}
