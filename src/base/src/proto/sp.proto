package sp;
option java_package = "com.aerofs.proto";
option optimize_for = LITE_RUNTIME; // remove reflection

import "common.proto";
import "cmd.proto";

// NOTE: The SP protocol uses a single version number that is incremented whenever backward-compat
// is broken.
//
// Backward-compatible changes:
//      appending RPC at the end of a service declaration
//      adding new message types
//      adding new *optional* fields in existing messages
//
// Backward-incompatible changes:
//      changing order of RPCs in a service (corollary: adding RPC anywhere but at the end)
//      changing field ids in messages
//      changing field type in messages
//      changing field qualifier in messages (optional/required)
//      removing required fields from existing messages
//      adding required fields in *Call messages
//
// When this happens, deal with any comment tagged with WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE and
// make sure you bump the protocol version everywhere:
//      SP_PROTOCOL_VERSION in BaseParam.java
//      SP_PROTO_VERSION in src/python-lib/aerofs_sp/param.py
//      sp.version in
//          src/web/development/modes/local.ini
//          src/web/development/modes/private.ini
//          puppetmaster/modules/web/files/production.ini
//          puppetmaster/modules/unified/files/production.ini.template
// TODO: consolidate this mess (hopefully RESTfulness will simplify versioning)

service SPService {

    // Sets the message type used in case of errors
    rpc __error__(Void) returns(PBException);

    // Send the specified email address a signup verification email that contains the link to
    // complete signup. If the user is an AeroFS user, a different email is sent indicating that the
    // user already exists.
    //
    // Required Auth Level: none
    //
    // Throws: ExEmptyEmailAddress is the email address is empty
    rpc RequestToSignUp(RequestToSignUpCall) returns(Void);

    // Sign up a user using a signup code.
    //
    // No-op if the user already exists and the password matches the existing user's password.
    // This is needed for the business users to retry signing up using the link in their email.
    // That link points to the user signup page with business signup as the followup page.
    //
    // NOTE: this expects the credential to be submitted in clear text.
    //
    // Required Auth Level: none
    //
    // Throws:
    //   ExNotFound if the targeted signup code was not found
    //   ExBadCredential if the user exists and the password doesn't match the existing user
    rpc SignUpWithCode(SignUpWithCodeCall) returns(SignUpWithCodeReply);

    // Finds the email address associated with an signup code.
    //
    // Required Auth Level: none
    //
    // Throws:
    //   ExNotFound if the signup code wasn't found
    rpc ResolveSignUpCode(ResolveSignUpCodeCall)
            returns (ResolveSignUpCodeReply);

    // Send a verification code to the user's email address. This function will be called
    // automatically when a user signs-up, but we may need to call again if the user
    // can't find the email (spam filter, etc...)
    //
    // Required Auth Level: user
    //
    // Throws:
    //   ExAlreadyExist if the user has already been verified
     rpc SendEmailVerification(Void) returns(Void);

    // Checks an email verification code, and mark the email address as verified
    //
    // Required Auth Level: none (protected by the randomness of the verification code)
    //
    // Throws:
    //   ExNotFound if the verification code wasn't found
    //   ExAlreadyExist if the user has already been verified
     rpc VerifyEmail(VerifyEmailCall) returns(Void);

    // Signs out of SP
    //
    // Required Auth Level: user
    rpc SignOut(Void) returns (Void);

    // Creates a certificate for the specified device which is bound to the calling user. Creates
    // an entry in the device table to save registration information.
    //
    // Required Auth Level: user
    //
    // Throws:
    //   ExBadArgs   if the cname does not match the required format (hashed concatenation of user
    //               email, did).
    //   ExDeviceIDAlreadyExist if the device ID already exists
    rpc RegisterDevice(RegisterDeviceCall) returns (RegisterDeviceReply);


    // Invite a person to become a member of the caller's organization. An email will be sent to the
    // requested user. When the user clicks on the link the admin panel will accept the organization
    // invite by calling the below rpc (AcceptOrganizationInvitation). At that point the user will
    // be moved in the new organization.
    //
    // Required Auth Level: admin
    //
    // Throws:
    //   ExEmptyEmailAddress if the user id is empty
    //   ExAlreadyExist if the email address is already a member of that organization.
    //   ExAlreadyInvited if the user has already been invited to the organization but has not yet
    //                  accepted the invitation.
    //   ExEmailSendingFailed if we were unable to send the email.
    //   ExNoStripeCustomerID if payment is required but the current organization doesn't have a
    // Stripe customer ID.
    //   ExEmailNotVerified if the user's email hasn't been verified
     rpc InviteToOrganization(InviteToOrganizationCall) returns(InviteToOrganizationReply);

    // Accept an organization invitation and move the caller into that organization. Makes
    // appropriate ACL updates to allow for Team Server sync.
    //
    // This call will also delete the pending organization invitation, since it has already been
    // acted upon.
    //
    // Throws:
    //   ExNotFound if the user does not have a pending invitation for the specified organization.
    //   ExBadArgs if the user is already a member of the target organization.
    //   ExNoAdminForNonEmptyTeam if the organization would have no admins but non-admin members.
    //   ExEmailNotVerified if the user's email hasn't been verified
    rpc AcceptOrganizationInvitation(AcceptOrganizationInvitationCall)
            returns(AcceptOrganizationInvitationReply);

    // Ignore an invitation to a specific organization. This call deletes the entry in the
    // organization invitation table so that when the user views the pending organization invites
    // page in the admin panel, that organization will no longer appear in the list.
    //
    // This method returns the user counts as well as Stripe customer id of the specific
    // organization, so the Python Web server may update Stripe subscription plan for that org.
    //
    // TODO (WW) This design smells weird.
    // Alternatively we can use a separate method to retrieve  the number but it would bring up
    // several security issues. The fundamental problem is that the Web server shouldn't have
    // handled Stripe calls. Either SP or a service that SP depends on should do the job.
    //
    // Required Auth Level: user
    //
    // Throws:
    //   ExNotFound if the user does not have a pending invitation for the specified organization.
    rpc DeleteOrganizationInvitation(DeleteOrganizationInvitationCall) returns(
            DeleteOrganizationInvitationReply);

    // Remove a user from the caller's organization. The user will be moved to a new empty
    // organization, and will be seen as an external user on any shared folders that he
    // may have with the previous organization.
    //
    // Required Auth Level: admin
    //
    // Throws: ExNoPerm if the current user isn't an admin of the target user, or if an admin tries
    //         to remove itself from the organization
    rpc RemoveUserFromOrganization(RemoveUserFromOrganizationCall)
            returns(RemoveUserFromOrganizationReply);

    // Shares a folder with another user.
    //
    // If the user doesn't exist yet, this method invites the user to sign up AeroFS first.
    //
    // The invitation list can be empty.
    //
    // See docs/design/sharing_and_migration.md for high-level design.
    //
    // Required Auth Level: user
    //
    // Throws:
    //   ExNoPerm if the sharer isn't authorized to modify ACLs for the given SID
    //   ExAlreadyExists if the user is already a member of the folder
    //   ExCannotInviteSelf if the sharer appears in the list of sharees
    //   ExNoStripeCustomerID if payment is required but the current organization doesn't have a
    //     Stripe customer ID.
    //   ExEmailNotVerified if the user's email hasn't been verified
    //
    // Exceptions from shared folder rules.
    rpc ShareFolder(ShareFolderCall) returns(Void);

    // Add the user to a shared folder (provided he/she was invited).
    //
    // NB: pushes ACL update to clients
    //
    // Calling this function with a valid shared folder code will set the user's email address
    // as verified.
    //
    // Required Auth Level: user
    //
    // Throws:
    //   ExNotFound if the shared folder code wasn't found
    //   ExNoPerm if the user was not invited to the shared folder
    //   ExEmailNotVerified if the user's email hasn't been verified
    rpc JoinSharedFolder(JoinSharedFolderCall) returns(Void);

    // Ignore an invite to a shared folder.
    //
    // Required Auth Level: user
    //
    // Throws:
    //   ExNotFound if the shared folder does not exist.
    //   ExNoPerm if the user has not been invited to this shared folder.
    //   ExAlreadyExist if the user is already a member of this shared folder.
    rpc IgnoreSharedFolderInvitation(IgnoreSharedFolderCall) returns(Void);

    // Remove the user from a shared folder (provided he/she was a member).
    //
    // NB: pushes ACL update to clients
    //
    // Required Auth Level: user
    //
    // Throws:
    //   ExNotFound if the shared folder wasn't found.
    //   ExNoPerm if the user was not invited to the shared folder.
    rpc LeaveSharedFolder(LeaveSharedFolderCall) returns(Void);

    // Returns a list of pending shared folder invitations for the user
    //
    // Required Auth Level: user
    rpc ListPendingFolderInvitations(Void) returns(ListPendingFolderInvitationsReply);

    // Sends an email to the user.
    //
    // Required Auth Level: user
    rpc EmailUser(EmailUserCall) returns (Void);

    // Get the user's preferences (name, device name, etc)
    //
    // Required Auth Level: user
    rpc GetUserPreferences(GetUserPreferencesCall) returns (GetUserPreferencesReply);

    // Set a given user's preferences (name, device name, etc). Optional fields that aren't present
    // won't be changed. The session user must be either the given user or the admin of the user's
    // organization.
    //
    // Required Auth Level: user or admin (see above)
    rpc SetUserPreferences(SetUserPreferencesCall) returns (Void);

    // List members of the current organization
    //
    // Required Auth Level: admin
    //
    // Throws:
    //   ExNoPerm if the user does not have admin privileges
    rpc ListOrganizationMembers(ListOrganizationMembersCall) returns(ListOrganizationMembersReply);


    // Sends an email to a user with instructions to reset his password. The user
    // will be sent an email containing a link with a reset password token. The link
    // will take the user to a form when they can set a new password.
    // The reset_password token and the new password will be used in the ResetPassword
    // call.
    //
    // Required Auth Level: none
    //
    // Throws:
    //   Nothing... No feedback makes brute force attacks useless
    rpc SendPasswordResetEmail(SendPasswordResetEmailCall) returns(Void);

    // Reset a user's password. The user will already have received a reset_password token
    // via email.
    //
    // Required Auth Level: none
    //
    //
    // Throws:
    //   ExNotFound if the provided token has no associated user account
    rpc ResetPassword(ResetPasswordCall) returns(Void);

    // Changes a users password.  The old password is replaced with the new password.
    //
    // Required Auth Level: user
    //
    // Throws:
    //   ExNoPerm   if the authorization requirements are not met
    //              if the old password is not correct
    rpc ChangePassword(ChangePasswordCall) returns(Void);

    // Set the user's authorization level for SP services
    //
    // Required Auth Level: admin
    // throws:
    //   ExNotFound if the provided user email has no AeroFS account set up.
    //   ExNoPerm   if the authorization requirements are not met,
    //              if the new authorization level exceeds that of the caller,
    //              if the caller does not belong to the same organization as the user email
    rpc SetAuthorizationLevel(SetAuthorizationLevelCall) returns(Void);

    //
    // Deactivate a user, delete all its ACLs and unlink all its devices.
    //
    // If the user to be deleted is the only remaining owner of a shared folder:
    //      - if the caller is an org admin it will take ownership of this folder
    //      - if the caller is the user itself ExNoAdminOrOwner is thrown
    //
    // Required Auth Level: User to delete self, Admin to delete others
    rpc DeactivateUser(DeactivateUserCall) returns(DeactivateUserReply);


    /////////
    // these are internal API calls only (meant to be called by the daemon only)
    // Required Auth Level: user for all of them

    // Update the ACL for an existing member of a shared folder
    //
    // Required Auth Level: user
    //
    // Throws: ExNotFound if the user is not a member of the specified folder
    //
    // Exceptions from shared folder rules.
    rpc UpdateACL(UpdateACLCall) returns (Void);

    // Delete the ACL for an existing member or an pending user of a shared folder
    //
    // Required Auth Level: user
    //
    // Throws: ExNotFound if the user is not a member or pending user of the specified folder
    rpc DeleteACL(DeleteACLCall) returns (Void);

    // Get the certificate revocations relevant to a specific user, based on the certificate
    // revocation list epoch number.
    //
    // Required Auth Level: user
    rpc GetUserCRL(GetUserCRLCall) returns(GetUserCRLReply);

    // Get global (full, non-user specific) certificate revocation list.
    rpc GetCRL(Void) returns(GetCRLReply);

    // Revoke the certificate of a specific device and optionally erase AeroFS files from the
    // device. This will trigger a verkehr notification for the CRL.
    //
    // Q. Why is this needed? Isn't it sufficient to manage users only by the ACL system?
    // A. Consider the case where a user quits AeroFS and we revoke all privileges via ACLs. Their
    // certs will still be valid but it won't matter due to the fact that they lack ACLs.
    // But then consider that the user could re-join aerofs with the same email address, then these
    // certs will be valid again, which would be bad.
    //
    // The session user must be the owner of the specified device, or the admin of the organization
    // the device owner belongs to.
    //
    // Required Auth Level: user or admin (see above)
    //
    // Throws:
    //   ExNoPerm   if the user does not have enough privilege (see above)
    //   ExNotFound if the user is trying to unlink a device that does not exist.
    rpc UnlinkDevice(UnlinkDeviceCall) returns(Void);

    // Get information about a device ID.
    //
    // Required Auth Level: user
    rpc GetDeviceInfo(GetDeviceInfoCall) returns(GetDeviceInfoReply);

    // List all the devices belonging to a specified user. If the specified user is not the
    // current user, the current user must be the admin of the organization the specified user
    // belongs to.
    //
    // Required Auth Level: user or admin (see above)
    //
    // Throws: ExEmptyEmailAddress if the user id is empty
    rpc ListUserDevices(ListUserDevicesCall) returns(ListUserDevicesReply);

    // Get list of folders being shared by users in organization. See also: ListUserSharedFolders
    //
    // Required Auth Level: admin
    rpc ListOrganizationSharedFolders(ListOrganizationSharedFoldersCall)
            returns(ListOrganizationSharedFoldersReply);

    // Get list of folders being shared by a specified user. If the specified user is not the
    // current user, the current user must be the admin of the organization the specified user
    // belongs to.
    //
    // See also: ListOrganizationSharedFolders
    //
    // Required Auth Level: user or admin (see above)
    //
    // Throws:
    //   ExNoPerm       if the user calling this does not have enough privileges (see above)
    rpc ListUserSharedFolders(ListUserSharedFoldersCall) returns(ListSharedFoldersReply);

    // Gets a list of organizations the user has been invited to, excluding their current
    // organization.
    //
    // Required Auth Level: user
    rpc GetOrganizationInvitations(Void) returns (GetOrganizationInvitationsReply);

    // Get the user's organization's preferences (organization name).
    //
    // Required Auth Level: user
    rpc GetOrgPreferences(Void) returns (GetOrgPreferencesReply);

    // Set the user's organization's preferences (organization name).
    //
    // Required Auth Level: admin
    //
    // Throws:
    //   ExNoPerm if the user calling this does not have admin privileges
    rpc SetOrgPreferences(SetOrgPreferencesCall) returns (Void);

    // Unsubscribe a user from email reminders based on the unsubscribe token id
    //
    // Required Auth Level: none
    rpc UnsubscribeEmail(SetUnsubscribeEmailCall) returns (GetUnsubscribeEmailReply);

    // Return the auth level of the current user
    //
    // Required Auth Level: none
    rpc GetAuthorizationLevel(Void) returns (GetAuthorizationLevelReply);

    // Return the Team Server user id of the current organization
    //
    // Required Auth Level: admin
    rpc GetTeamServerUserID(Void) returns (GetTeamServerUserIDReply);

    // Certify a Team Server's device and save the device information on SP. It is different from
    // RegisterDevice in that the this call allows the user to register the device under a user
    // ID different from his own ID. This call is needed only for setting up the Team Server.
    //
    // Required Auth Level: Admin
    //
    // Throws:
    //   ExDeviceIDAlreadyExist if the device ID already exists
    //   ExEmailNotVerified if the user's email hasn't been verified. We do it to avoid
    //   security complications on Team Servers, such as inviting users from the Team Server
    //   desktop app.
    rpc RegisterTeamServerDevice(RegisterDeviceCall) returns (RegisterDeviceReply);


    // Extend the tomcat session. Does not throw, since we are guaranteed by tomcat that the session
    // will exist in the tracker.
    //
    // Required Auth Level: user
    rpc ExtendSession(Void) returns(Void);


    // Retrieve Stripe data of the current organization.
    //
    // Required Auth Level: admin
    rpc GetStripeData(Void) returns(GetStripeDataReply);


    // List all the users who have been invited to the current user's organization.
    //
    // Required Auth Level: admin
    rpc ListOrganizationInvitedUsers(Void) returns(ListOrganizationInvitedUsersReply);

    // Get the head of the command queue for a given device.
    //
    // Required Auth Level: none
    //
    // Throws:
    //   ExNotFound: if the specified device does not exist.
    rpc GetCommandQueueHead(GetCommandQueueHeadCall) returns(GetCommandQueueHeadReply);

    // Acknowledge the command at the head of the command queue for a given device. If the client
    // is unable to process the command they should specify error = true and the command will be
    // retried later.
    //
    // To reduce the number of messages transferred this call also returns the new head of this
    // device's command queue.
    //
    // Required Auth Level: user
    //
    // Throws:
    //   ExNotFound: if the specified device does not exist or does not belong to you.
    rpc AckCommandQueueHead(AckCommandQueueHeadCall) returns(AckCommandQueueHeadReply);

    // Delete organization invitation for a given user.
    //
    // Required Auth Level: admin
    //
    // Throws: ExEmptyEmailAddress if the user id is empty
    rpc DeleteOrganizationInvitationForUser(DeleteOrganizationInvitationForUserCall) returns(
            DeleteOrganizationInvitationForUserReply);

    // Used only by a DaemonPostUpdateTask to set OS information for existing devices
    //
    // Required Auth Level: user
    rpc SetDeviceOSFamilyAndName(SetDeviceOSFamilyAndNameCall) returns(Void);

    // Set the Stripe customer ID of the current organization
    //
    // Required Auth Level: admin
    rpc SetStripeCustomerID(SetStripeCustomerIDCall) returns(Void);

    // Delete the Stripe customer ID of the current organization
    //
    // Required Auth Level: admin
    rpc DeleteStripeCustomerID(Void) returns (Void);

    // Retrieve ACL entries for the user, including those flagged as "external".
    // See docs/design/sharing_and_migration.txt for information about the external flag.
    //
    // Required Auth Level: user
    rpc GetACL(GetACLCall) returns(GetACLReply);

    // Issue a new certificate to the requesting user/did.
    //
    // Required Auth Level: user
    // Throws: ExNotFound if the specified device id is not known to be owned by that user.
    rpc RecertifyDevice(RecertifyDeviceCall) returns (RecertifyDeviceReply);

    // Issue a new Team Server (organization) certificate for the requesting user/did.
    // Requires
    //
    // Required Auth Level: admin
    // Throws: ExNoPerm if the current user isn't an admin of her organization
    //         ExNotFound if the specified device does not exist for the given organization. Note
    //              that this is necessary, otherwise, we would allow email-unverified users to
    //              certify Team Servers, bypassing RegisterTeamServerDevice(). The latter method
    //              throws if the requesting user's email is not verified.
    rpc RecertifyTeamServerDevice(RecertifyDeviceCall) returns (RecertifyDeviceReply);

    // Get User's Organization ID
    //
    // Required Auth Level: user
    rpc GetOrganizationID(Void) returns(GetOrganizationIDReply);

    // Sign in a user using userid/password credentials.
    //
    // NOTE: this method expects the user credential information in the clear. Key-derivation
    // (SCrypt or similar) will be applied on the server side if needed.
    //
    // Required Auth Level: none
    //
    // Throws:
    //   ExEmptyEmailAddress if the user id is empty
    //   ExBadCredential if username/password combination is incorrect
    rpc CredentialSignIn(SignInUserCall) returns (SignInUserReply);

    // Validate the given username/credential pair without signing the user in.
    //
    //   ExEmptyEmailAddress if the user id is empty
    //   ExBadCredential if username/password combination is incorrect, or in the case of the Team
    //                   Server, if they have not signed in successfully using mutual
    //                   authentication.
    rpc ValidateCredential(SignInUserCall) returns (Void);

    // NB: this method is obsolete and should not be used in new code
    // TODO: remove once automatic ahead-of-time recertification is implemented (i.e. renew cert
    // every 6 month instead of waiting for expiration and fallback on password request if dev
    // remains offline for so long that automatic re-cert fails)
    //
    // Sign in a user using userid/password credentials.
    //
    // Required Auth Level: none
    //
    // Throws:
    //   ExEmptyEmailAddress if the user id is empty
    //   ExBadCredential if username/password combination is incorrect, or in the case of the Team
    //                   Server, if they have not signed in successfully using mutual
    //                   authentication.
    rpc SignInUser(SignInUserCall) returns (SignInUserReply);

    // Sign in a device using an existing device certificate.
    //
    // Required Auth Level: none
    //
    // Throws:
    //   ExBadCredential if the certificate is not recognized or the DID does not match.
    rpc SignInDevice(SignInDeviceCall) returns (Void);

    // Kick off the OpenId authentication flow by generating session keys for the
    // authenticating session, and returning those to the client.
    //
    // Required Auth Level: none
    //
    // Throws:
    //   Something Bad if the server does not have openid enabled.
    rpc OpenIdBeginTransaction(Void) returns (OpenIdSessionNonces);

    // Complete the authentication flow by returning the session attributes from
    // the authenticated session.
    // This will return null if the session referenced by the
    // query key is not yet authenticated by an OpenId provider.
    //
    // An exception indicates non-retryable error (timeout or otherwise).
    //
    // NOTE: this will only return session attributes _once_.
    //
    // Required Auth Level: none
    //
    // Throws:
    //   Something Bad if the server does not have openid enabled.
    rpc OpenIdGetSessionAttributes(OpenIdSessionQuery) returns (OpenIdSessionAttributes);


    // Generate an access code that can be used to request an access token for a mobile device.
    // The access code will be valid for a short time. Each access code can be used
    // only once to generate an access token.
    //
    // TODO: configure and document access code lifetime; currently 3 minutes.
    // Required Auth Level: User
    rpc GetMobileAccessCode(Void) returns (MobileAccessCode);

    // Given a valid API access code, get the user attributes to be cached
    // for the user account. This will implicitly invalidate the access code so it cannot
    // be reused.
    //
    // The API client that will own the access token should submit a name
    // ("Greg's iPad") along with the authorization request in the deviceInfo field.
    //
    // Required Auth Level: None
    rpc AuthorizeAPIClient(AuthorizeAPIClientCall) returns (AuthorizeAPIClientReply);

    // Lists the shared folder information associated with the given list of Store IDs. The
    // caller must be a member of every shared folder.
    //
    // The returned shared folders will match the input store IDs by the indices in the list.
    // Alternatively, the client can also inspect the store ID of the returned folders.
    //
    // See Also: ListUserSharedFolders, ListOrganizationSharedFolders
    //
    // Required Auth Level: user (see above)
    //
    // Throws:
    //   ExNoPerm if the caller does not have the required privileges for any store inquired
    rpc ListSharedFolders(ListSharedFoldersCall) returns (ListSharedFoldersReply);

    // Adds user to sharer whitelist.
    //
    // Required Auth Level: admin
    // Throws:
    //   ExNoPerm if the current user isn't an admin of her organization
    //   ExNotFound if the specified user doesn't exist
    rpc AddUserToWhitelist(AddUserToWhitelistCall) returns (Void);

    // Removes user from sharer whitelist
    //
    // Required Auth Level: admin
    // Throws:
    //   ExNoPerm if the current user isn't an admin of her organization
    //   ExNotFound if the specified user doesn't exist
    rpc RemoveUserFromWhitelist(RemoveUserFromWhitelistCall) returns (Void);

    // List users that have been added to the sharer whitelist
    //
    // Required Auth Level: admin
    // Throws:
    //   ExNoPerm if the current user isn't an admin of her organization
    rpc ListWhitelistedUsers(Void) returns (ListWhitelistedUsersReply);

    // Sets the name of a shared folder for the authenticated user
    //
    // Required Auth Level: user
    // Throws:
    //   ExNotFound if the shared folder wasn't found.
    //   ExBadArgs if the name is an empty string
    // WAIT_FOR_SP_PROTOCOL_VERSION_CHANGE - Move this method after LeaveSharedFolder
    rpc SetSharedFolderName(SetSharedFolderNameCall) returns (Void);

    // Given a set of stores and the bytes contained in each, return whether
    // each store should continue to collect
    //
    // Required Auth Level: teamserver
    //
    rpc CheckQuota(CheckQuotaCall) returns (CheckQuotaReply);

    // Set the organization-wide per-user quota
    //
    // Required Auth Level: admin
    //
    rpc SetQuota(SetQuotaCall) returns (Void);

    // Remove the organization-wide per-user quota
    //
    // Required Auth Level: admin
    //
    rpc RemoveQuota(Void) returns (Void);

    // Get the organization-wide per-user quota
    //
    // Required Auth Level: admin
    //
    rpc GetQuota(Void) returns (GetQuotaReply);

    // Create a unique key which maps to a rest object and an OAuth token,
    // which a user can share to allow access to that object via URL
    //
    // Required Auth Level: store owner
    // Throws:
    //   ExNoPerm if the current user isn't a manager of the containing store
    //   ExBadArgs if the SOID provided is invalid
    //
    rpc CreateUrl(CreateUrlCall) returns (CreateUrlReply);

    // Get the info associated with a URL key (rest object, token, expiry, etc.)
    //
    // Required Auth Level:
    //   None, if no password is set
    //   store owner OR provide password, if password is set
    // Throws:
    //   ExNotFound if the key does not exist
    //   ExBadCredential if a password is set and the user is not a store owner and does not
    //      provide the correct password.
    //
    rpc GetUrlInfo(GetUrlInfoCall) returns (GetUrlInfoReply);

    // Set the expiry associated with a URL
    //
    // Required Auth Level: store owner
    // Throws:
    //   ExNotFound if the key does not exist
    //   ExNoPerm if the current user isn't a manager of the containing store
    //
    rpc SetUrlExpires(SetUrlExpiresCall) returns (Void);

    // Remove the expiry associated with a URL
    //
    // Required Auth Level: store owner
    // Throws:
    //   ExNotFound if the key does not exist
    //   ExNoPerm if the current user isn't a manager of the containing store
    //
    rpc RemoveUrlExpires(RemoveUrlExpiresCall) returns (Void);

    // Delete a URL
    //
    // Required Auth Level: store owner
    // Throws:
    //   ExNotFound if the key does not exist
    //   ExNoPerm if the current user isn't a manager of the containing store
    //
    rpc RemoveUrl(RemoveUrlCall) returns (Void);

    // Set a password for the URL
    //
    // Required Auth Level: store owner
    // Throws:
    //   ExNotFound if the key does not exist
    //   ExNoPerm if the current user isn't a manager of the containing store
    //
    rpc SetUrlPassword(SetUrlPasswordCall) returns (Void);

    // Remove the password for the URL
    //
    // Required Auth Level: store owner
    // Throws:
    //   ExNotFound if the key does not exist
    //   ExNoPerm if the current user isn't a manager of the containing store
    //
    rpc RemoveUrlPassword(RemoveUrlPasswordCall) returns (Void);

    // Check the password against the hashed password stored in the db.
    // No-op if they match, and throw ExBadCredential if they do not.
    //
    // Required Auth Level: none
    // Throws:
    //   ExNotFound if the key does not exist
    //   ExBadCredential if the password is incorrect
    //
    rpc ValidateUrlPassword(ValidateUrlPasswordCall) returns (Void);

    // Destroy a shared folder and remove all ACLs for it
    //
    // Required Auth Level: store owner
    //   ExNotFound if the key does not exist
    //   ExNoPerm if the current user isn't a manager or an admin of a manager
    //
    rpc DestroySharedFolder(DestroySharedFolderCall) returns (Void);

    // Requests SP to send a notification email to support to report a
    // problem on the user's behalf.
    //
    // The call returns as soon as the e-mail is queued. E-mail is sent
    // asynchronously and may not succeed; the client is not notified
    // when the notification e-mail failed.
    //
    // Required Auth Level: user
    // Throws:
    //   ExInvalidEmailAddress if the contact email address is invalid
    //   ExFormatError if the Dryad ID is invalid
    //
    rpc SendDryadEmail(SendDryadEmailCall) returns (Void);

    // Request (re-)generation of two-factor auth secrets/recovery tokens for
    // the session's user
    //
    // Required Auth Level: user
    rpc SetupTwoFactor(Void) returns (SetupTwoFactorReply);

    // Enable or disable two-factor enforcement for the session's user.
    //
    // Required Auth Level: user
    rpc SetTwoFactorEnforcement(SetTwoFactorEnforcementCall) returns (Void);

    // List all urls for any objects in the given store
    //
    // Required Auth Level: store owner
    // Throws:
    //   ExNotFound if the store does not exist
    //   ExNoPerm if the current user isn't a manager or an admin of a manager
    //
    rpc ListUrlsForStore(ListUrlsForStoreCall) returns (ListUrlsForStoreReply);

    // Provide second factor to an already-authenticated session. Requires a half-open session.
    // After N unsuccessful second factor login attempts, the session is discarded.
    rpc ProvideSecondFactor(ProvideSecondFactorCall) returns (Void);

    // Provide backup code to act as second factor to an already-authenticated session. Requires a
    // half-open session. If this rpc returns success, the code cannot be used again.
    rpc ProvideBackupCode(ProvideBackupCodeCall) returns (Void);

    // Fetch a user's current set of backup codes.
    rpc GetBackupCodes(Void) returns (GetBackupCodesReply);


    // Create a locally-managed sharing group.
    //
    // Required Auth Level: admin
    rpc CreateGroup(CreateGroupCall) returns (CreateGroupReply);

    // Set the common name of a group.
    //
    // Required Auth Level: admin
    //
    // Throws:
    //   ExNotFound if the group does not exist.
    //   ExNotLocallyManaged if the group is not locally managed and this op cannot be completed.
    rpc SetGroupCommonName(SetGroupCommonNameCall) returns (Void);

    // Add users to a group. The users must be in the organization that owns the group in order to
    // be added.
    //
    // Requried Auth Level: admin
    //
    // Throws:
    //   ExNotFound if the group does not exist.
    //   ExWrongOrganization if one or more of the group members to be added are not in the
    //     group's owner organization.
    //   ExNotLocallyManaged if the group is not locally managed and this op cannot be completed.
    rpc AddGroupMembers(AddGroupMembersCall) returns (Void);

    // Remove users from a group. This will also remove the user from shares that are associated
    // with this group. Permission prescedence applies (see group sharing design and requirements
    // documents).
    //
    // Requried Auth Level: admin
    //
    // Throws:
    //   ExNotFound if one or more of the users are not members of the group.
    //   ExNotLocallyManaged if the group is not locally managed and this op cannot be completed.
    rpc RemoveGroupMembers(RemoveGroupMembersCall) returns (Void);

    // Completely delete a group. Users are removed from shares associated with this group. Again
    // with the permission precedence thing.
    //
    // Requried Auth Level: admin
    //
    // Throws:
    //   ExNotFound if the group to be deleted does not exist.
    //   ExNotLocallyManaged if the group is not locally managed and this op cannot be completed.
    rpc DeleteGroup(DeleteGroupCall) returns (Void);

    // List all groups in the caller's organization.
    //
    // Requried Auth Level: user
    rpc ListGroups(ListGroupsCall) returns (ListGroupsReply);

    // List all group members in the given group.
    //
    // Required Auth Level: user
    //
    // Throws:
    //   ExNotFound if the group in question does not exist.
    rpc ListGroupMembers(ListGroupMembersCall) returns (ListGroupMembersReply);
}

message SetStripeCustomerIDCall {
    required string stripe_customer_id = 1;
}

message SetDeviceOSFamilyAndNameCall {
    required bytes device_id = 1;
    required string os_family = 2;
    required string os_name = 3;
}

message DeleteOrganizationInvitationForUserCall {
    required string user_id = 1;
}

message DeleteOrganizationInvitationForUserReply {
    // See InviteToOrganizationReply
    required PBStripeData stripe_data = 1;
}

// The data structure holds all the information that describes the Stripe subscription of an
// organization. The Web server uses it to perform Stripe transactions. Ideally, all Stripe
// transactions should be done inside SP and this data structure should not be needed.
// See src/web/README.stirpe.txt for detail.
message PBStripeData {
    // Stripe customer ID of the organization. Absent if the organization doesn't have the ID.
    // If the field is present, the caller MUST update Stripe subscription based on quantity.
    optional string customer_id = 1;
    // The quantity of the subscription. It is identical to the number of organization members.
    required uint32 quantity = 2;
}

message ListOrganizationInvitedUsersReply {
    repeated string user_id = 1;
}

message GetStripeDataReply {
    required PBStripeData stripe_data = 1;
}

message SignUpWithCodeCall {
    required string signup_code = 1;
    required bytes password = 3; // hashed credentials (some combo of password, etc.)
    // TOOD (WW) use PBFullName
    required string first_name = 4;
    required string last_name = 5;
}

message SignUpWithCodeReply {
    required string org_id = 1;
    required bool existing_team = 2; // is the user joining an existing organization, or a new one?
}

message ResolveSignUpCodeCall {
    required string code = 1;
}

message ResolveSignUpCodeReply {
    required string email_address = 1;
}

message VerifyBatchSignUpCodeCall {
    required string bsc = 1;
}

message RequestToSignUpCall {
    required string email_address = 1;
}

message InviteToOrganizationCall {
    required string email_address = 1;
}

message InviteToOrganizationReply {
    // Return Stripe data so the Web server doesn't have to make another three SP calls
    // (get customer id, get current member count, and get invited users count) to update the
    // subscription. See PBStripeData for more info.
    required PBStripeData stripe_data = 1;

    // Whether the invited user is locally managed (see Authenticator#isLocallyManaged). Used by
    // the frontend to determine if to add the user to the pending invitation list.
    // optional is for backward compatibility. Can be convert to required after Dec 1, 2013.
    optional bool locally_managed = 2 [default = true];
}

message AcceptOrganizationInvitationCall {
    required int32 organization_id = 1;
}

message AcceptOrganizationInvitationReply {
    // Return Stripe data for the user's _previous_ organization, so the Web server can downgrade
    // subscription for that organization.
    required PBStripeData stripe_data = 1;
}

message DeleteOrganizationInvitationCall {
    required int32 organization_id = 1;
}

message RemoveUserFromOrganizationCall {
    required string user_id = 1;
}

message RemoveUserFromOrganizationReply {
    required PBStripeData stripe_data = 1;
}

// TODO (MP) clean this up.
// I would love to reorganize the parameters of this message a bit, but that's not possible without
// bumping the API version. Let's do this soon^TM.
message ShareFolderCall {
    // Name of the folder being shared.
    required string folder_name = 3;
    required bytes share_id = 2;

    // This list can be empty.
    repeated PBSubjectPermissions subject_permissions = 1;

    // Message to the person.
    optional string note = 4;

    // Whether the sharer created the share outside his root anchor. Ignored when adding new
    // members to an existing shared folder. See docs/design/sharing_and_migration.md for more.
    optional bool external = 5;

    // Whether to suppress warning exceptions (i.e. ExSharingRulesWarning) generated by shared
    // folder rules. These exceptions are used by the UI to ask the user to confirm execution of
    // potentially harmful actions. Once confirmed, the UI will call the same method again with
    // this flag on.
    optional bool suppress_sharing_rules_warnings = 6;

    // This list can be empty.
    repeated PBGroupPermissions group_permissions = 7;
}

message JoinSharedFolderCall {
    required bytes shared_id = 1;
    // See docs/design/sharing_and_migration.md for information about this flag.
    optional bool external = 2;
}

message IgnoreSharedFolderCall {
    required bytes shared_id = 1;
}

message LeaveSharedFolderCall {
    required bytes shared_id = 1;
}

message SetSharedFolderNameCall {
    required bytes share_id = 1;
    required string folder_name = 2;  // New name. Cannot be empty.
}

message ListPendingFolderInvitationsReply {
    repeated PBFolderInvitation invitation = 1;
}

message EmailUserCall {
    required string subject = 1;
    required string body = 2;
}

message GetUserPreferencesCall {
    optional bytes device_id = 1; // if absent, no device-specific information will be returned
}

message GetUserPreferencesReply {
    // TOOD (WW) use PBFullName
    required string first_name = 1;
    required string last_name = 2;
    optional string device_name = 3; // absent if did wasn't specified
    optional uint64 signup_date = 4;
    optional bool two_factor_enforced = 5;
}

message SetUserPreferencesCall {
    required string user_id = 1;

    // TODO (WW) use PBFullName
    optional string first_name = 2;
    optional string last_name = 3;

    // If set, it doesn't change the device id, but it allows setting the device name (below).
    optional bytes device_id = 4;

    // Valid iff device_id is present.
    optional string device_name = 5;
}

message GetACLCall {
    // The epoch number the client holds. If the server has the same epoch number, store_acl in the
    // reply message will be empty. See GetACLReply.
    required uint64 epoch = 1;
}

message GetACLReply {
    message PBStoreACL {
        required bytes store_id = 1;
        repeated PBSubjectPermissions subject_permissions = 2;
        // See docs/design/sharing_and_migration.md for information about this flag.
        required bool external = 3;
        required string name = 4;
    }

    repeated PBStoreACL store_acl = 1;

    // The epoch number on the server. store_acl is always empty if this number is the same as the
    // epoch on the client. See GetACLCall.
    required uint64 epoch = 2;
}

message UpdateACLCall {
    required bytes store_id = 1;
    required string subject = 2;
    required PBPermissions permissions = 3;

    // See the same parameter in ShareFolderCall
    optional bool suppress_sharing_rules_warnings = 4;
}

message DeleteACLCall {
    required bytes store_id = 1;
    required string subject = 2;
}

message VerifyEmailCall {
    required string verification_code = 1;
}

message GetTeamServerUserIDReply {
    required string id = 1;
}

message RegisterDeviceCall {
    message Interface {
        required string name = 1;
        required string mac = 2;
        repeated string ips = 3;
    }

    required bytes device_id = 1;

    // The Certification Signing Request generated by the client
    required bytes csr = 2;

    // Can be 'Windows', 'Mac OS X', 'Linux', 'Android', 'iOS'. See OSUtil.OSFamily.toString().
    // These strings are displayed to end users (DeviceRegistrationEmailer.java) and are used to
    // determine the icons (devices.mako).
    required string os_family = 3;
    // Detailed OS names, e.g. 'Windows XP SP 1'
    required string os_name = 4;

    required string device_name = 5;

    // The list of interfaces on the machine. Required for validation with the system authorization
    // endpoint (see docs/design/device_authorization.md).
    repeated Interface interfaces = 6;
}

message RegisterDeviceReply {
    // The certificate issued by AeroFS CA
    required string cert = 1;
}

message ListOrganizationMembersCall {
    // Maximum number of entries returned on one page.
    // The SP server should enforce a reasonable upper bound for this parameter.
    required uint32 max_results = 1;
    // Offset to start retrieving the results.
    required uint32 offset = 2;
    optional string search_prefix = 3;
}

message ListOrganizationMembersReply {
    message PBUserAndLevel {
        required PBUser user = 1;
        required PBAuthorizationLevel level = 2;
    }

    // There will be at most 'max_results' entries
    repeated PBUserAndLevel user_and_level = 1;

    // Total number of users in the database.
    required uint32 total_count = 2;
}

message GetOrganizationIDReply {
    required string org_id = 1;
}

message GetAuthorizationLevelReply {
    required PBAuthorizationLevel level = 1;
}

message PBUser {
    // N.B. the user_email is assumed to be the user's unique ID on the SP Database
    required string user_email = 1;
    // TOOD (WW) use PBFullName
    required string first_name = 2;
    required string last_name = 3;
    optional bool two_factor_enforced = 4;
}

message PBGroup {
    required uint32 group_id = 1;
    required string common_name = 2;
}

message SetAuthorizationLevelCall {
    required string user_email = 1;
    required PBAuthorizationLevel auth_level = 2;
}

enum PBAuthorizationLevel {
    USER       = 0;
    ADMIN      = 1;
}

message SendPasswordResetEmailCall {
    required string user_email = 1;
}

message ResetPasswordCall {
    // Token to be included in email
    required string password_reset_token = 1;
    required bytes new_credentials = 2;
}

message ChangePasswordCall {
    required bytes old_credentials = 1;
    required bytes new_credentials = 2;
}

message GetUserCRLCall {
    required uint64 crl_epoch = 1;
}

message GetUserCRLReply {
    required uint64 crl_epoch = 1;
    repeated uint64 serial = 2;
}

message GetCRLReply {
    repeated uint64 serial = 1;
}

message UnlinkDeviceCall {
    required bytes device_id = 1;
    required bool erase = 2;
}

message GetDeviceInfoCall {
    repeated bytes device_id = 1;
}

message GetDeviceInfoReply {

    // See also GetUserDevicesReply.PBDevice
    message PBDeviceInfo {
        // These fields are absent if:
        // 1) the device ID is not found, or
        // 2) the caller is not sharing any folder with the device owner.
        optional PBUser owner = 1;
        optional string device_name = 2;
    }

    repeated PBDeviceInfo device_info = 1;
}

message ListUserDevicesCall {
    required string user_id = 1;
}

message ListUserDevicesReply {

    // See also GetDeviceInfoReply.PBDeviceInfo
    message PBDevice {
        required bytes device_id = 1;
        required string device_name = 2;
        required string os_family = 3;
        required string os_name = 4;
    }

    repeated PBDevice device = 1;
}

message ListOrganizationSharedFoldersCall {
    // Maximum number of folders returned.
    required uint32 max_results = 1;

    // Offset into results
    required uint32 offset = 2;
}

message ListOrganizationSharedFoldersReply {
    repeated PBSharedFolder shared_folder = 1;

    // Total number of shared folders in the database
    required uint32 total_count = 2;
}

message ListUserSharedFoldersCall {
    required string user_id = 1;
}

message PBSharedFolder {

    message PBUserPermissionsAndState {
        required PBUser user = 1;
        required PBPermissions permissions = 2;
        required PBSharedFolderState state = 3;
    }

    message PBGroupPermissionsAndState {
        required PBGroup group = 1;
        required PBPermissions permissions = 2;
        required PBSharedFolderState state = 3;
    }

    required bytes store_id = 1;
    required string name = 2;
    // Whether any user of the session user's organization owns the folder
    required bool owned_by_team = 3;
    repeated PBUserPermissionsAndState user_permissions_and_state = 4;
    repeated PBGroupPermissionsAndState group_permissions_and_state = 5;
}

message GetOrganizationInvitationsReply {
    message OrganizationInvitation {
        required string inviter = 1;
        required string organization_name = 2;
        required int32 organization_id = 3;
    }

    // Organizations the user has been invited to. Excludes the current organization and the default
    // organization.
    repeated OrganizationInvitation organization_invitations = 2;
}

message GetOrgPreferencesReply {
    required string organization_name = 1;
    required string organization_contact_phone = 2;
}

message SetOrgPreferencesCall {
    optional string org_name = 1;
    optional string organization_contact_phone = 2;
}

message SetUnsubscribeEmailCall {
    required string unsubscribe_token = 1;
}

message GetUnsubscribeEmailReply {
    required string email_id = 1;
}

message DeleteOrganizationInvitationReply {
    // As the deletion causes the organization to lose one user, the Web server needs to adjust
    // the organization's subscription plan. However, because the current user doesn't belong to the
    // organization, the Web server doesn't have the permission to retrieve the organization's
    // subscription data which is necessary for the adjustment. Therefore, we return the
    // data in this reply.
    //
    // This design is not great. Ideally, SP should perform all Stripe transactions internally
    // without the Web server's involvement. See PBStripeData for more information.
    required PBStripeData stripe_data = 1;
}

message PBFullName {
    required string first_name = 1;
    required string last_name = 2;
}

message GetCommandQueueHeadCall {
    required bytes device_id = 1;
}

message GetCommandQueueHeadReply {
    optional Command command = 1;
    required int64 queue_size = 2;
}

message AckCommandQueueHeadCall {
    required bytes device_id = 1;
    required uint64 epoch = 2;
    required bool error = 3;
}

message AckCommandQueueHeadReply {
    // This command is the command now at the head of the queue. Included in the ack reply to
    // reduce the number of round trips when doing a full syncronization.
    optional Command command = 1;
    required int64 queue_size = 2;
}

message RecertifyDeviceCall {
    required bytes device_id = 1;
    required bytes csr = 2;
}

message RecertifyDeviceReply {
    // The certificate issued by AeroFS CA
    required string cert = 1;
}

message SignInDeviceCall {
    required string user_id = 1;
    required bytes did = 2;
}

message SignInUserCall {
    required string user_id = 1;
    required bytes credential = 2;
}

message SignInUserReply {
    // optional for backwards-compatibility with Void reply
    optional bool need_second_factor = 1;
}

message OpenIdSessionNonces {
    // TODO (WW) replace CamelCase with underscore
    required string sessionNonce = 1;
    required string delegateNonce = 2;
}

message OpenIdSessionQuery {
    // TODO (WW) replace CamelCase with underscore
    required string sessionNonce = 1;
}

message OpenIdSessionAttributes {
    // TODO (WW) replace CamelCase with underscore
    optional string userId = 1;
    optional string firstName = 2;
    optional string lastName = 3;
    optional bool need_second_factor = 4;
}

message MobileAccessCode {
    // TODO (WW) replace CamelCase with underscore
    optional string accessCode = 1;
}

message AuthorizeAPIClientCall {
    // TODO (WW) replace CamelCase with underscore
    optional string accessCode = 1;
    optional string deviceName = 2;
}

message AuthorizeAPIClientReply {
    // TODO (WW) replace CamelCase with underscore
    optional string userId = 1;
    optional string orgId = 2;
    optional bool isOrgAdmin = 3;
}

message ListSharedFoldersCall {
    repeated bytes store_id = 1;
}

message ListSharedFoldersReply {
    repeated PBSharedFolder shared_folder = 1;
}

enum PBSharedFolderState {
    PENDING = 0;
    JOINED = 1;
    LEFT = 2;
}

message DeactivateUserCall {
    required string user_id = 1;
    required bool erase_devices = 2;
}

message DeactivateUserReply {
    required PBStripeData stripe_data = 1;
}

message AddUserToWhitelistCall {
    required string user_email = 1;
}

message RemoveUserFromWhitelistCall {
    required string user_email = 1;
}

message ListWhitelistedUsersReply {
    repeated PBUser user = 1;
}

message CheckQuotaCall {
    message PBStoreUsage {
        required bytes sid = 1;
        required uint64 bytes_used = 2;
    }
    repeated PBStoreUsage store = 1;
}

message CheckQuotaReply {
    message PBStoreShouldCollect {
        required bytes sid = 1;
        required bool collect_content = 2;
    }
    repeated PBStoreShouldCollect store = 1;
}

message GetQuotaReply {
    // absent to indicate no quota
    optional uint64 quota = 1;
}

message SetQuotaCall {
    required uint64 quota = 1;
}

message CreateUrlCall {
    required string soid = 1;
    required string token = 2;
}

message PBRestObjectUrl {
    required string key = 1;
    required string soid = 2;
    required string token = 3;
    required string created_by = 4;
    optional uint64 expires = 5;
    optional bool has_password = 6;  // no field == false
}

message CreateUrlReply {
    required PBRestObjectUrl url_info = 1;
}

message SetUrlExpiresCall {
    required string key = 1;
    required uint64 expires = 2;
    required string new_token = 3;
}

message RemoveUrlExpiresCall {
    required string key = 1;
    required string new_token = 2;
}

message GetUrlInfoCall {
    required string key = 1;
    optional bytes password = 2;
}

message GetUrlInfoReply {
    required PBRestObjectUrl url_info = 1;
}

message RemoveUrlCall {
    required string key = 1;
}

message SetUrlPasswordCall {
    required string key = 1;
    required bytes password = 2;
    required string new_token = 3;
}

message RemoveUrlPasswordCall {
    required string key = 1;
}

message ValidateUrlPasswordCall {
    required string key = 1;
    required bytes password = 2;
}

message DestroySharedFolderCall {
    required bytes shared_id = 1;
}

message SendDryadEmailCall {
    required string dryad_id = 1;
    required string contact_email = 2;
    required string description = 3;
}

message SetupTwoFactorCall {
    // currently empty, but we may need to add things like "code delivery
    // mechanism" later.
}

message SetupTwoFactorReply {
    required bytes secret = 1;
}

message SetTwoFactorEnforcementCall {
    required bool enforce = 1;
    optional int32 current_code = 2;
    optional string user_id = 3; // If absent, the target of this call is the caller's session's user.
}

message ListUrlsForStoreCall {
    required bytes shared_id = 1;
}

message ListUrlsForStoreReply {
    repeated PBRestObjectUrl url = 1;
}

message ProvideSecondFactorCall {
    required int32 current_code = 1;
}

message ProvideBackupCodeCall {
    required string backup_code = 1;
}

message GetBackupCodesReply {
    message BackupCode {
        required string code = 1;
        optional uint64 date_used = 2; // timestamp in "milliseconds since the epoch"
    }
    repeated BackupCode codes = 1;
}

message CreateGroupCall {
    required string common_name = 1;
}

message CreateGroupReply {
    required uint32 group_id = 1;
}

message SetGroupCommonNameCall {
    required uint32 group_id = 1;
    required string common_name = 2;
}

message AddGroupMembersCall {
    repeated string user_emails = 1;
}

message RemoveGroupMembersCall {
    repeated string user_emails = 1;
}

message DeleteGroupCall {
    required uint32 group_id = 1;
}

message ListGroupsCall {
    required uint32 max_results = 1;
    required uint32 offset = 2;
    optional string search_prefix = 3;
}

message ListGroupsReply {
    repeated PBGroup groups = 1;
}

message ListGroupMembersCall {
    required uint32 group_id = 1;
}

message ListGroupMembersReply {
    repeated PBUser users = 1;
}