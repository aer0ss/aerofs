#!/usr/bin/ruby
require "yaml"
require "puppet"
require "net/https"
require "pry"

class Kick
  attr_reader :update_status, :useful_logs

  def initialize(host)
    @http = Net::HTTP.new(host,8139)
    @http.use_ssl = true
    @http.verify_mode = OpenSSL::SSL::VERIFY_NONE
    @http.read_timeout = 500
  end

  def run
    response = @http.put("/production/run/deploy", '{}', {"Content-type" => "text/pson"})
    @report = YAML.load(response.body)
    if @report.ivars["status"] == "success" then
      @logs = @report.ivars["options"][:report].logs
      @update_status = @report.ivars["options"][:report].status
      @useful_logs = @logs.select { |v| v.level == :err}
    end
    @report.ivars["status"]
  end
end

# find all nodes that will be kicked
nodes = YAML::load(File.open("/etc/puppet/nodes.yaml"))

do_not_kick_nodes = YAML::load(File.open("/etc/puppet/do_not_kick.yaml"))

# take difference of two arrays, unless do_not_kick_nodes is not an Array
if do_not_kick_nodes.kind_of?(Array)
  hosts_to_kick = nodes - do_not_kick_nodes
else
  hosts_to_kick = nodes
end

# get rid of nils and sort
hosts_to_kick = hosts_to_kick.compact.sort

puts "Preparing to kick the following hostnames:"
hosts_to_kick.each{ |h| puts "\t#{h}" }

# keep a list of failed nodes
failed_nodes = []

# since this gets called from ant, we have to call $stdout.flush
hosts_to_kick.each do |host|
  k = Kick.new(host)
  puts "Running puppet on #{host}"
  $stdout.flush
  kick_result = k.run
  if kick_result == "running" then
    puts "#{host} is already running, will try again"
    $stdout.flush
    # try again later
    hosts_to_kick << host
    next
  end
  if k.update_status == "failed" then
    failed_nodes << host
  end
  puts "#{host} finished with status: #{k.update_status}"
  puts k.useful_logs
  $stdout.flush
end

if failed_nodes.length > 0 then
  puts "Failures: #{failed_nodes.length}"
end

exit failed_nodes.length
