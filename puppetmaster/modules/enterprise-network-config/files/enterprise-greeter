#!/usr/bin/env python
# Script to provide command-line prompt for configuring the network.
# Expects to be run as root.

import cmd
import os
import re
import sys
import subprocess

CHOSEN_CONF_FILE = "/etc/network/selected-network-type"
STATIC_CONF = "/etc/network/interfaces.d/static"
RESOLV_CONF = "/etc/resolv.conf"

VALID_IPV4_REGEX = r'((2[0-5]|1[0-9]|[0-9])?[0-9]\.){3}((2[0-5]|1[0-9]|[0-9])?[0-9])'

STATIC_CONFIG_TEMPLATE = """iface static inet static
  address {address}
  netmask {netmask}
  broadcast {broadcast}
  gateway {gateway}
"""

# pretty display things
CYAN = "\033[01;36m"
NORMAL = "\033[0m"
DEFAULT_WIDTH = 80

def centered(s, width=DEFAULT_WIDTH):
    padding = " " * ((width - len(s)) / 2 )
    return padding + s

# Use this URL to generate the ASCII art:
#   http://patorjk.com/software/taag/#p=display&f=Standard&t=aerofs%20%20appliance
BANNER = CYAN + "\n".join([
        # Print couple of newlines to push old text out of the screen
        # TODO (WW) issue a clear-screen command?
        "",
        "",
        "",
centered(r"                        __                          _ _                       "),
centered(r"   __ _  ___ _ __ ___  / _|___     __ _ _ __  _ __ | (_) __ _ _ __   ___ ___  "),
centered(r"  / _` |/ _ \ '__/ _ \| |_/ __|   / _` | '_ \| '_ \| | |/ _` | '_ \ / __/ _ \ "),
centered(r" | (_| |  __/ | | (_) |  _\__ \  | (_| | |_) | |_) | | | (_| | | | | (_|  __/ "),
centered(r"  \__,_|\___|_|  \___/|_| |___/   \__,_| .__/| .__/|_|_|\__,_|_| |_|\___\___| "),
centered(r"                                       |_|   |_|                              "),
        "",
    ]) + NORMAL

def current_netconfig():
    if os.path.exists(CHOSEN_CONF_FILE):
        with open(CHOSEN_CONF_FILE) as f:
            return f.read().strip()
    return False

def set_static_netconfig(value):
    with open(STATIC_CONF, "w") as f:
        f.write(value)

def set_current_netconfig(value):
    with open(CHOSEN_CONF_FILE, "w") as f:
        f.write(value)

class MenuOption(object):
    def __init__(self, prompt, callback, default=None, validator=None, invalid_message=None, okay_message=None):
        self.prompt = prompt
        self.callback = callback
        self.default = default
        self.validator = re.compile(validator) if validator is not None else None
        self.invalid_message = invalid_message
        self.okay_message = okay_message

class Menu(object):
    def __init__(self, header):
        self.header = header
        self.choices = []

    def add_choice(self, choice):
        if not isinstance(choice, MenuOption):
            raise ValueError("Expected a MenuOption, got a {}".format(type(choice)))
        self.choices.append(choice)

    def interact(self):
        print self.header
        for i, choice in enumerate(self.choices):
            print "{}. {}".format(i+1, choice.prompt)
        sys.stdout.write("? ")
        sys.stdout.flush()
        choice = sys.stdin.readline().rstrip()
        if choice == "root-shell":
            # Drop to a root bash shell.
            # If you have access to tty1, you are clearly an admin.
            os.execl("/bin/bash", "/bin/bash")
        try:
            choice_index = int(choice, 10)
        except ValueError:
            print "Invalid input '{}' - please choose a number between 1 and {}".format(choice, len(self.choices))
            return
        if choice_index < 1 or choice_index > len(self.choices) :
            print "Invalid input '{}' - please choose a number between 1 and {}".format(choice, len(self.choices))
            return
        # Okay, trigger the callback for the menu item chosen
        self.choices[choice_index - 1].callback()

# Helper functions
def request(label, default=None, validator=None, ok_message=None, invalid_message=None):
    done = False
    example = "|{}| ".format(default) if default else ""
    prompt = "{} {}".format(label, example)
    while not done:
        sys.stdout.write(prompt)
        sys.stdout.flush()
        choice = sys.stdin.readline().rstrip() or default
        if validator is not None:
            match = re.match(validator, choice)
            if not (match and match.start() == 0 and match.end() == len(choice)):
                if invalid_message:
                    print invalid_message
                else:
                    print "Sorry, I didn't understand that.  Please enter something matching"
                    print validator
                continue
        done = True
        if ok_message is not None:
            print ok_message
        return choice

def ifdown():
    subprocess.call("ifdown eth0", shell=True)

def ifup():
    subprocess.call("ifup eth0", shell=True)

def dhcp_menu_text():
    return "Use DHCP" + (" [selected]" if current_netconfig() == "dhcp" else "")

def static_menu_text():
    return "Use Static IP" + (" [selected]" if current_netconfig() == "static" else "")

def current_static_value(search_key):
    if os.path.exists(STATIC_CONF):
        with open(STATIC_CONF) as f:
            for line in f:
                try:
                    key, value = line.strip().split(" ", 1)
                    if key == search_key:
                        return value
                except ValueError:
                    # Ignore lines that don't split
                    pass
    return None

def get_current_network_state():
    # helper function to convert CIDR to netmask:
    # >>> mask_bits_to_mask(17) -> "255.255.128.0"
    def mask_bits_to_mask(mask_bits):
        values = [128, 64, 32, 16, 8, 4, 2, 1]
        blocks = []
        for i in xrange(4):
            bits_consumed = min(8, mask_bits)
            mask_bits = mask_bits - bits_consumed
            chunk = sum(values[0:bits_consumed])
            blocks.append(str(chunk))
        return ".".join(blocks)
    # Values to be filled out below.
    # For the first four, we screen scrape "ip addr"; for the gateway, we
    # screenscrape "ip route"
    address = None
    netmask = None
    broadcast = None
    mac_addr = None
    gateway = None

    # Scrape address, netmask, broadcast, mac_addr
    addr_text = subprocess.check_output("ip addr show dev eth0 scope global".split())
    addr_lines = addr_text.split("\n")

    network_matcher = re.compile("    inet ([^ ]+) brd ([^ ]+) scope global eth0")
    macaddr_matcher = re.compile("    link/ether (([0-9a-f]{2}:){5}[0-9a-f]{2})")
    for line in addr_lines:
        net_matches = network_matcher.match(line)
        if net_matches:
            cidr = net_matches.group(1)
            address, mask_bits = cidr.split("/", 1)
            netmask = mask_bits_to_mask(int(mask_bits))
            broadcast = net_matches.group(2)
        mac_matches = macaddr_matcher.match(line)
        if mac_matches:
            mac_address = mac_matches.group(1)

    # Scrape gateway
    route_text = subprocess.check_output("ip route show to 0/0".split())
    route_lines = route_text.split("\n")
    route_matcher = re.compile("default via ({})".format(VALID_IPV4_REGEX))
    for line in route_lines:
        route_match = route_matcher.match(line)
        if route_match:
            gateway = route_match.group(1)
            break
    return (address, netmask, broadcast, mac_address, gateway)

def print_network_state_and_next_instructions():
    address, netmask, broadcast, mac_address, gateway = get_current_network_state()
    print "                        MAC Address: {}".format(mac_address)
    print "                         IP Address: {}".format(address)
    print "                            Netmask: {}".format(netmask)
    print "                          Broadcast: {}".format(broadcast)
    print "                            Gateway: {}".format(gateway)
    print ""
    if address:
        url = centered("https://{}".format(address))
        colored_url = "{}{}{}".format(CYAN, url, NORMAL)
        print centered("To continue configuring this node, point your browser at:")
        print colored_url
    else:
        print centered("Please provide this machine with network configuration below:")
    print

def read_resolvconf():
    nameservers = []
    additional_lines = []
    # Note: this regex only works because we try to match() on individual lines.
    # don't try to use it on a full file
    regex = re.compile(r"nameserver (.*)")
    if os.path.exists(RESOLV_CONF):
        # Read lines of /etc/resolv.conf.
        # If it starts "nameserver ", add the nameserver to the list.
        # otherwise, add that line to the "additional_lines" list
        with open(RESOLV_CONF) as f:
            for line in f:
                match = regex.match(line)
                if match:
                    nameservers.append(match.group(1).strip())
                else:
                    additional_lines.append(line.rstrip())
    return (nameservers, additional_lines)


# Main menu callbacks
def select_dhcp():
    print "Configuring network for DHCP"
    ifdown()
    set_current_netconfig("dhcp")
    ifup()

def show_static_menu():
    # read static values from user
    ip_address = request("IP Address:",
                         default=current_static_value("address"),
                         validator=VALID_IPV4_REGEX)
    netmask    = request("Netmask:",
                         default=current_static_value("netmask"),
                         validator=VALID_IPV4_REGEX)
    broadcast  = request("Broadcast address:",
                         default=current_static_value("broadcast"),
                         validator=VALID_IPV4_REGEX)
    gateway    = request("Gateway:",
                         default=current_static_value("gateway"),
                         validator=VALID_IPV4_REGEX)
    # render static template with config values
    static_config_file_contents = STATIC_CONFIG_TEMPLATE.format(address=ip_address,
                 netmask=netmask,
                 broadcast=broadcast,
                 gateway=gateway,)
    # bring old network down
    ifdown()
    # save new config file and tell eth0 to use static conf
    set_static_netconfig(static_config_file_contents)
    set_current_netconfig("static")
    # bring new network configuration up
    ifup()

def show_dns_menu():
    old_nameservers, additional_lines = read_resolvconf()
    new_nameservers = []

    # Get primary nameserver from user.
    previous_default_nameserver = old_nameservers[0] if len(old_nameservers) > 0 else None
    first_nameserver = request("Primary nameserver: ", default=previous_default_nameserver, validator=VALID_IPV4_REGEX)
    new_nameservers.append(first_nameserver)
    # Collect additional nameservers, if desired
    while True:
        want_more = request("Add another nameserver? [y/n] ", validator=r"y|n")
        if want_more == "n":
            break
        next_nameserver_default = old_nameservers[len(new_nameservers)] if len(old_nameservers) > len(new_nameservers) else None
        next_nameserver = request("Next nameserver: ", default=next_nameserver_default, validator=VALID_IPV4_REGEX)
        new_nameservers.append(next_nameserver)
    # Commit.
    with open(RESOLV_CONF, "w") as f:
        for server in new_nameservers:
            print >>f, "nameserver {}".format(server)
        for line in additional_lines:
            print >>f, line

def restart():
    subprocess.call("init 6", shell=True)
    sys.exit(0)

def shutdown():
    subprocess.call("init 0", shell=True)
    sys.exit(0)

def main():
    print BANNER
    print_network_state_and_next_instructions()
    print ""
    menu = Menu("Or select an option below:")
    menu.add_choice(MenuOption(dhcp_menu_text(), select_dhcp))
    menu.add_choice(MenuOption(static_menu_text(), show_static_menu))
    menu.add_choice(MenuOption("Set DNS server", show_dns_menu))
    menu.add_choice(MenuOption("Reboot system", restart))
    menu.add_choice(MenuOption("Shutdown system", shutdown))
    menu.interact()

if __name__ == "__main__":
    while True:
        try:
            main()
        except KeyboardInterrupt:
            exit(0)
