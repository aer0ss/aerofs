package util

import (
	"aerofs.com/sloth/errors"
	"crypto/md5"
	"crypto/rand"
	"encoding/hex"
	"regexp"
	"sort"
	"strings"
)

// returns hex-encoded 128-bits
func GenerateRandomId() string {
	b := make([]byte, 16)
	_, err := rand.Read(b)
	errors.PanicOnErr(err)
	return hex.EncodeToString(b)
}

// Channel IDs are hex-encoded random 128-bit strings where the left-most
// nibble is 0x0.
func GenerateChannelId() string {
	return "0" + GenerateRandomId()[1:]
}

// Direct Convo IDs are generated by taking the MD5 of the space-separated,
// alphabetically-sorted list of convo-members, and setting the left-most
// nibble to 0x1.
func GenerateDirectConvoId(members []string) string {
	sort.Strings(members)
	hash := md5.Sum([]byte(strings.Join(members, " ")))
	return "1" + hex.EncodeToString(hash[:])[1:]
}

func GenerateFileConvoId(fileId string) string {
	hash := md5.Sum([]byte(fileId))
	return "2" + hex.EncodeToString(hash[:])[1:]
}

func IsTagPresent(msg, id string) bool {
	tag := "@" + id
	for i := 0; i <= len(msg)-len(tag); i += 1 {
		// check tag is found
		if msg[i:i+len(tag)] != tag {
			continue
		}
		// check left bound
		if i != 0 && isIllegalTagBoundChar(msg[i-1]) {
			continue
		}

		// check right bound
		if i+len(tag) < len(msg) && isIllegalTagBoundChar(msg[i+len(tag)]) {
			continue
		}

		return true
	}
	return false
}

// Illegal bound chars cannot be immediately to the left or right of @tagid
// Keep these characters in sync with tag.js#isIllegalBoundingChar
func isIllegalTagBoundChar(c byte) bool {
	b, err := regexp.Match("^[a-zA-Z0-9@]$", []byte{c})
	errors.PanicOnErr(err)
	return b
}
