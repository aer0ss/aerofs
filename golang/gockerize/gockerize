#!/bin/bash
#
# Copyright (c) 2015, Air Computing Inc. <oss@aerofs.com>
# All rights reserved.

set -e

[[ $# -ge 2 ]] && [[ $# -lt 6 ]] || {
    echo "Usage: $0 <image> <service> [<source> [<mapping> [<Dockerfile>]]]"
    echo "      <image>      name of the docker image to be produced"
    echo "      <service>    fully qualified name of the go package to build"
    echo "                   e.g. 'aerofs.com/ca-server'"
    echo "      <source>     path to source hierarchy to be imported into container"
    echo "                   Default: ."
    echo "      <mapping>    location into which sources are copied, under GOPATH/src/"
    echo "                   Default: <service>/<source> if <source> starts with \"..\""
    echo "                            <service> otherwise"
    echo "      <Dockerfile> path to Dockerfile"
    echo "                   Default: ./Dockerfile"
    echo ""
    echo "Extra arguments, such as build tags, can be passed to the go build command via"
    echo "the GOARGS environment variable."
    exit 11
}

IMAGE=$1
SERVICE=$2
SRC_DIR=${3:-.}
if [[ $SRC_DIR == ..* ]] ; then
    DST_DIR=${4:-${SERVICE}/${SRC_DIR}}
else
    DST_DIR=${4:-${SERVICE}}
fi
DOCKERFILE=${5:-/dev/null}

BUILDER=aerofs/gockerize
THIS_DIR="$( cd "$(dirname "${BASH_SOURCE[0]}" )" && pwd )"

if [[ $(uname -s) == "Darwin" ]] ; then
    # sigh...
    #  1. docker CLI is not flexible enough so we need to use API directly
    #  2. OSX is a broken piece of shit, SecureTransport can't load PEM cert/key so we need to
    #     convert them to PKCS12
    if [[ ! -f $DOCKER_CERT_PATH/client.p12 ]] ; then
        openssl pkcs12 -export -in $DOCKER_CERT_PATH/cert.pem -inkey $DOCKER_CERT_PATH/key.pem \
            -out $DOCKER_CERT_PATH/client.p12 -passout pass:.
    fi

    curl_opts="-k -E $DOCKER_CERT_PATH/client.p12:. https${DOCKER_HOST#tcp}"
    stat_format="-f %m"
elif [[ $(uname -s) == "Linux" ]] ; then
    curl_opts="--unix-socket /var/run/docker.sock http:"
    stat_format="-c %Y"
else
    echo "unsupported platform: always rebuild"
fi

if [[ -n "$stat_format" ]] ; then
    # find newest timestamp in entire source tree
    newest=$(find ${SRC_DIR} -type f | xargs stat $stat_format | sort -nr | head -n 1)

    url_image=$(python -c "import urllib; print urllib.quote('''$IMAGE''')")
    # find creation date of container, if present
    # NB: remove sub-second precision and convert from ISO 8601 to Unix epoch
    created=$(curl --fail $curl_opts/images/$url_image/json 2>/dev/null | jq -r '.Created[0:19]+"Z" | fromdate')

    echo "newest : $newest"
    echo "created: $created"

    if [[ -n "$created" ]] && (( "$created" > "$newest" )) ; then
        echo "${IMAGE} already up-to-date"
        exit 0
    fi
fi

echo "Building $BUILDER ..."
# build base builder container
docker build -t $BUILDER "$THIS_DIR"

tmpimg="${BUILDER}-$(echo "$IMAGE" | sed 's/\//./g')"
echo "Building $tmpimg ..."

# one cannot use a Dockerfile outside of the build context, hence the use of a tempfile
tmpfile="${SRC_DIR}/.gockerize.dockerfile"

cat - > "$tmpfile" <<EOF
FROM $BUILDER
COPY . /gopath/src/$DST_DIR
EOF

if ! docker -v | grep -v 'version 1.9.0' &>/dev/null ; then
    echo "WARNING: disabling build cache to workaround bug in docker 1.9.0"
    CACHE=--no-cache=true
fi

# build temporary container w/ build context
docker build $CACHE -t "$tmpimg" -f "$tmpfile" "$SRC_DIR"

rm -f "$tmpfile"

echo "Building container image $IMAGE ..."
docker run --rm -i -v /var/run/docker.sock:/var/run/docker.sock \
    ${GOARGS:+"-e=GOARGS=$GOARGS"} "$tmpimg" "$IMAGE" "$SERVICE" < "$DOCKERFILE"

# remove temporary container
docker rmi "$tmpimg"

