
RPC Plugins for Protobuf
========================

Introduction to Protobuf plugins
--------------------------------

When protoc is invoked with switches in the form --foobar_out, it will look in $PATH for executables named protoc-gen-foobar.

The plugins receive protobuf messages on stdin that describe the parsed .proto file, and they output on stdout the code that should go inside the compiled file.

Plugins can be chained. In this case, the plugins are called in the order that they switch appear on the command line, and they can insert code in the code generated by the previous plugins

Example:
	protoc --java_out=out_dir --foobar_out=out_dir

	The foobar plugin will be called after the java code generator completed, and will have the opportunity to insert code at locations marked with // @@protoc_insertion_point in the Java file.


Our RPC plugins
---------------

The protobuf language defines a way to declare a RPC services like this:

service SearchService {
  rpc Search (SearchRequest) returns (SearchResponse);
}

However, by default no code is generated for those services. It's up to the developers to create a protobuf plugin that generates the code.

That's what our plugins do. We have one RPC plugin per language we use. (Currently, Java and Objective-C). They can be invoked with --rpc-java_out or --rpc-objc_out.


How to build
------------

We use Qt Creator as our IDE, and qmake as our build system.
Download the Qt SDK from http://qt.nokia.com/downloads, open rpc_plugins.pro, and hit 'build'.

Alternatively, the project can be built from the command-line:

(assuming current directory is where rpc_plugins.pro resides)

$ mkdir ../build
$ cd ../build
$ qmake ../rpc_plugins/rpc_plugins.pro
$ make


Testing
-------

Once built, each plugin can be tested by running the 'run_tests' shell script in test/[plugin]/


Folder hierarchy
----------------

3rdparty          Headers and code from third parties, such as Google
common            Code common to several plugins
gen_rpc_java      RPC code generator for Java
gen_rpc_objc      RPC code generator for Objective-C
proto             Protobuf files that must be compiled and used at runtime by the clients
test              Test suite, launch ./run_tests within each subfodler to test
tools             Build tools


Details about the Objective-C plugin
------------------------------------

Since Objective-C is not part of the default languages supported by the Protobuf compiler, we rely on a third-party plugin to generate the Protobuf Objective-C classes:

https://github.com/booyah/protobuf-objc

As of this writing, this plugin does not create the insertion points that we need to allow our own rpc plugin to insert code in the Objective-c generated code. There's a pending pull request on Github that we created to fix this:

https://github.com/booyah/protobuf-objc/pull/23

So if you're cloning the protobuf-objc plugin, make sure this pull request is fully merged (or pull it manually into your clone).

We are also using 2 headers and 2 .cc files from them:

3rdparty/google/protobuf/objectivec-descriptor.pb.cc
3rdparty/google/protobuf/objectivec-descriptor.pb.h
3rdparty/google/protobuf/compiler/objc/objc_helpers.cc
3rdparty/google/protobuf/compiler/objc/objc_helpers.h

Make sure you update those files to their current version when you clone the protobuf-obj project.

Details about the Python-RPC plugin
-----------------------------------

NOTE: It is important to note that the current version of the Python-RPC plugin generates BLOCKING RPC calls. Even though the method through which the bytes are sent
to the remote client is implemented by you, the generated code that calls your method expects to receive the results in the return value.

In order to run the Python code generated by the Python-RPC plugin, you will need to have the Python protobuf module in your Python path. The easiest way to
do that is with pip:

    pip install protobuf

And if you don't have pip, you can install pip via easy_install:

    easy_install pip