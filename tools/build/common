#!/bin/bash
set -e -u

###############################################################################
#
# This include file contains all important constants for use with building
# and uploading release files to the release server.
#
# This file should be included with the following syntax:
#
# include common $MODE $PRODUCT
#
###############################################################################

# Similar to an ifndef in the C preprocessor. Only includes the contents of this
# file if they weren't imported before.
if [ x"${__COMMON_INCLUDE__:-}" == x ] ; then readonly __COMMON_INCLUDE__=true

###############################################################################
#
# Error codes
#
###############################################################################
readonly ERRNOINTERNET=16
readonly ERRBADARGS=17
readonly ERRBADMODE=18
readonly ERRBADPASS=19
readonly ERRS3=20
readonly ERRBADPRODUCT=21
readonly ERRBADVERSION=22
readonly ERRTESTFAIL=23

###############################################################################
#
# Local path constants
#
###############################################################################
GIT_ROOT="$(git rev-parse --show-cdup)"
if [ -z "$GIT_ROOT" ]; then
    GIT_ROOT="."
fi
readonly GIT_ROOT="$(cd "$GIT_ROOT" && pwd)"
readonly TOOLS_ROOT="${GIT_ROOT}/tools"
readonly BUILD_SCRIPT_DIR="${TOOLS_ROOT}/build"
readonly PROGUARD_HOME="${TOOLS_ROOT}/proguard"
readonly LOCAL_NSIS_DIR="${TOOLS_ROOT}/win_installer"

# Local resources directories
readonly BASE_RESOURCES_DIR="${GIT_ROOT}/resource"
readonly COMMON_RESOURCES_DIR="${BASE_RESOURCES_DIR}/common"
readonly MODE_RESOURCES_DIR="${COMMON_RESOURCES_DIR}/mode"
readonly OTHER_RESOURCES_DIR="${COMMON_RESOURCES_DIR}/other"
readonly CLIENT_RESOURCES_DIR="${BASE_RESOURCES_DIR}/client"
readonly CLIENT_ALL_PLATFORMS_RESOURCES_DIR="${CLIENT_RESOURCES_DIR}/all"
readonly LABELING_RESOURCES_DIR="${CLIENT_ALL_PLATFORMS_RESOURCES_DIR}/labeling"
readonly CLIENT_LINUX_RESOURCES_DIR="${CLIENT_RESOURCES_DIR}/linux"
readonly CLIENT_LINUX_SHARED_RESOURCES_DIR="${CLIENT_RESOURCES_DIR}/linux/shared"
readonly CLIENT_LINUX32_RESOURCES_DIR="${CLIENT_RESOURCES_DIR}/linux/i386"
readonly CLIENT_LINUX64_RESOURCES_DIR="${CLIENT_RESOURCES_DIR}/linux/amd64"
readonly CLIENT_OSX_RESOURCES_DIR="${CLIENT_RESOURCES_DIR}/osx"
readonly CLIENT_WIN_RESOURCES_DIR="${CLIENT_RESOURCES_DIR}/win"
readonly CLIENT_BASE_SHELLEXT_DIR="${CLIENT_RESOURCES_DIR}/shellext"
readonly CLIENT_OSX_SHELLEXT_DIR="${CLIENT_BASE_SHELLEXT_DIR}/osx"
readonly CLIENT_WIN_SHELLEXT_DIR="${CLIENT_BASE_SHELLEXT_DIR}/win"

# Local resource template directories
readonly BASE_TEMPLATES_DIR="${BASE_RESOURCES_DIR}/templates"
readonly CLIENT_TEMPLATES_DIR="${BASE_TEMPLATES_DIR}/client"
readonly CLIENT_LINUX_TEMPLATES_DIR="${CLIENT_TEMPLATES_DIR}/linux"
readonly CLIENT_OSX_TEMPLATES_DIR="${CLIENT_TEMPLATES_DIR}/osx"
readonly CLIENT_LINUX_SHARED_TEMPLATES_DIR="${CLIENT_LINUX_TEMPLATES_DIR}/shared"

# local build directory (where gradle will put stuff)
readonly BUILD_OUTPUT_DIR="${GIT_ROOT}/out.gradle"

# local root release directory and release dirs for each platform
# avoid putting scratch stuff in any of these directories because they are packaged into the installer
readonly LOCAL_RELEASE_DIR="${BUILD_OUTPUT_DIR}/release"
readonly AEROFS_RELEASE_DIR="${LOCAL_RELEASE_DIR}/aerofs"
readonly AEROFS_RELEASE_WIN_DIR="${LOCAL_RELEASE_DIR}/aerofs.win"
readonly AEROFS_RELEASE_OSX_DIR="${LOCAL_RELEASE_DIR}/aerofs.osx"
readonly AEROFS_RELEASE_LINUX_DIR="${LOCAL_RELEASE_DIR}/aerofs.linux"
readonly AEROFS_RELEASE_LINUX_SHARED_DIR="${AEROFS_RELEASE_LINUX_DIR}/shared"
readonly AEROFS_RELEASE_LINUX_I386_DIR="${AEROFS_RELEASE_LINUX_DIR}/i386"
readonly AEROFS_RELEASE_LINUX_AMD64_DIR="${AEROFS_RELEASE_LINUX_DIR}/amd64"

# Package temp folder
readonly PACKAGE_BUILD_DIR="$LOCAL_RELEASE_DIR/expandedpackages"
# Package output folder (final deployable artifacts go here)
readonly PACKAGE_DIR="$BUILD_OUTPUT_DIR/packages"

# Some OSX specific constants
readonly OSX_TEMPLATE_DMG_FILENAME="osx.dmg.template"
readonly OSX_TEMPLATE_APP_FILENAME="osx.app.template"

# Proguard maps server credentials and paths
readonly MAP_SERVER="rocklog.aerofs.com"
readonly MAP_SERVER_LOGIN=${MAP_SERVER}
readonly MAP_FILES_DIR="/maps"

readonly SLACK_WEBHOOK="https://hooks.slack.com/services/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"

###############################################################################
#
# Constants relating to the product to be built (CLIENT/TEAM_SERVER)
#
###############################################################################

###############################################################################
#
# Returns 0 if the product is one that's recognized, or $ERRBADPRODUCT
# otherwise
#
# Args:
#    1: product to check
#
###############################################################################
function is_valid_product() {
    if [[ "$1" != "CLIENT" && "$1" != "TEAM_SERVER" ]]; then
        return $ERRBADPRODUCT
    fi
    return 0
}

# check that a valid product was specified
readonly PRODUCT="${2:-CLIENT}" # FIXME (AG): This should not be specified in here since deploy doesn't need this
if ! is_valid_product "$PRODUCT" ; then
    echo "error: invalid build product $PRODUCT. Expected CLIENT|TEAM_SERVER." >&2
    exit $ERRBADPRODUCT
fi
readonly LOWERCASE_PRODUCT="$(echo $PRODUCT | tr '[A-Z]' '[a-z]')"
readonly LABELING_FILE="$LABELING_RESOURCES_DIR/$LOWERCASE_PRODUCT/labeling.properties"

###############################################################################
#
# Constants relating to the deploy mode (PUBLIC|PRIVATE|CI)
#
###############################################################################

# check that a valid mode was specified
readonly MODE="${1:-}"
if [ ${MODE} != PRIVATE ]; then
    echo "error: invalid build mode $MODE. Expected PRIVATE." >&2
    exit $ERRBADMODE
fi
readonly LOWERCASE_MODE="private"

###############################################################################
#
# Release server constants
#
###############################################################################

# We use the same user account when deploying to public/private.
# TODO (MP) use a more reasonable username.
readonly RELEASE_SERVER_USERNAME=release-prod
readonly RELEASE_SERVER="b.arrowfs.org"
readonly RELEASE_SERVER_LOGIN="${RELEASE_SERVER_USERNAME}@${RELEASE_SERVER}"
readonly RELEASE_SERVER_SHELL="bash -s -e -u"

###############################################################################
#
# Release server paths
#
###############################################################################
readonly INSTALLERS_DOWNLOAD_DIR="/data/${LOWERCASE_MODE}-downloads"
readonly CURRENT_VER="current.ver"

###############################################################################
#
# Returns 0 if the product is CLIENT, 1 otherwise
#
###############################################################################
function is_client() {
    if [ "$PRODUCT" == "CLIENT" ]; then
        return 0
    fi
    return 1
}

###############################################################################
#
# Returns 0 if the product is TEAM_SERVER, 1 otherwise
#
###############################################################################
function is_team_server() {
    if [ "$PRODUCT" == "TEAM_SERVER" ]; then
        return 0
    fi
    return 1
}

RELEASE_VERSION_REGEX="^[0-9]+\\.[0-9]+\\.[0-9]+$"

###############################################################################
#
# Exit if the given string is not a properly-formatted version string like "1.2.3"
#
###############################################################################
function check_version_format() {
    if [[ ! ${1:-} =~ $RELEASE_VERSION_REGEX ]]; then
        echo "You said ${1} ..." >&2
        echo "That's a weird release version.  I was expecting something matching:" >&2
        echo "$RELEASE_VERSION_REGEX" >&2
        echo "like 0.8.33 or something." >&2
        exit $ERRBADARGS
    fi
}

###############################################################################
#
# Gets the currently deployed version, like "0.4.98"
#
###############################################################################
function current_release_version() {
    local VERSION="$(curl --silent https://privatecloud.aerofs.com/appliance_version)"
    if [[ ! $VERSION =~ $RELEASE_VERSION_REGEX ]] ; then
        echo ""
        exit $ERRBADVERSION
    fi

    echo "$VERSION"
}

# Gets the product names from the labeling file.
function compute_product_names() {
    echo ">> computing product name"
    function get_property() {
        local local_PROPERTY="$1"
        # Note the equals.
        local local_KEY_VALUE_PAIR=$(grep ^"$local_PROPERTY"= $LABELING_FILE)
        if [[ $? -ne 0 ]] ; then
            echo "Couldn't retrieve property $local_PROPERTY from $LABELING_FILE"
            exit 1
        fi
        local local_VALUE=$(echo "$local_KEY_VALUE_PAIR" | cut -d = -f 2)
        if [[ -z "$local_VALUE" ]] ; then
            echo "Couldn't retrieve property $local_PROPERTY from $LABELING_FILE"
            exit 1
        fi
        echo "$local_VALUE"
    }

    readonly AEROFS_PRODUCT=$(get_property "labeling.product")
    readonly AEROFS_PRODUCT_SPACEFREE=$(get_property "labeling.productSpaceFreeName")
    readonly AEROFS_PRODUCT_UNIX=$(get_property "labeling.productUnixName")
    echo "PRODUCT = $AEROFS_PRODUCT"
    echo "PRODUCT_SPACEFREE = $AEROFS_PRODUCT_SPACEFREE"
    echo "PRODUCT_UNIX = $AEROFS_PRODUCT_UNIX"
}

# replaces the values AEROFS_PRODUCT_SPACEFREE, AEROFS_PRODUCT_UNIX, and
# AEROFS_PRODUCT in a file with the appropriate set from the environment, given
# the current labeling
function render_template() {
    if [ -z "$AEROFS_PRODUCT_SPACEFREE" -o -z "$AEROFS_PRODUCT_UNIX" -o -z "$AEROFS_PRODUCT" ] ; then
        echo "Can't render template: one of the following is empty or unset:"
        echo "\$AEROFS_PRODUCT           = $AEROFS_PRODUCT"
        echo "\$AEROFS_PRODUCT_UNIX      = $AEROFS_PRODUCT_UNIX"
        echo "\$AEROFS_PRODUCT_SPACEFREE = $AEROFS_PRODUCT_SPACEFREE"
        exit 1
    fi

    if [ $# -ne 2 ]; then
        echo "You invoked: $0 $@"
        echo "Usage: $0 <template_file> <output_file>"
        exit 1
    fi

    if [ ! -f "$1" ]; then
        echo "Template file does not exist: $1"
        exit 1
    fi

    if [ -f "$2" ]; then
        echo "Tried to render to existing file: $2"
        exit 1
    fi

    # render from template file to output file
    # we cp -a first to make sure the rendered file keeps the same permissions
    # as its source file, which is important for things like the Linux launcher
    # and copier scripts, as well as the Linux and OSX updaters.  > will
    # truncate the file before writing output without changing permissions.
    cp -a "$1" "$2"
    sed -e "s/\[AEROFS_PRODUCT_SPACEFREE\]/${AEROFS_PRODUCT_SPACEFREE}/g" \
        -e "s/\[AEROFS_PRODUCT_UNIX\]/${AEROFS_PRODUCT_UNIX}/g" \
        -e "s/\[AEROFS_PRODUCT\]/${AEROFS_PRODUCT}/g" \
        "$1" > "$2"
}

# single-quoted - we want $HOME expanded serverside
DEPLOY_LOCKFILE='$HOME/deploy.lock'

# Creates a lockfile on the release server, to allow deploys to mutex each other.
function lock_release_server() {
    declare REASON="$1"
    echo "establishing deploy lock..."
    kssh $RELEASE_SERVER_LOGIN $RELEASE_SERVER_SHELL << ENDCMDS
        if [ -f $DEPLOY_LOCKFILE ] ; then
            echo "A deploy appears to be in progress already:"
            cat $DEPLOY_LOCKFILE
            echo "If you're sure that deploy has indeed been terminated:"
            echo "    ssh $RELEASE_SERVER_LOGIN rm $DEPLOY_LOCKFILE"
            exit 1
        fi
        lockfile-create --retry 1 --lock-name $DEPLOY_LOCKFILE && echo "Deploy started by $USER at:" >> $DEPLOY_LOCKFILE && date >> $DEPLOY_LOCKFILE && echo "for reason $REASON" >> $DEPLOY_LOCKFILE
ENDCMDS
    echo "locked $RELEASE_SERVER for deploy"
}

# Deletes a lockfile from the release server, to allow another deploy to use it.
function unlock_release_server() {
    echo "releasing deploy lock..."
    kssh $RELEASE_SERVER_LOGIN "rm -f $DEPLOY_LOCKFILE"
    echo "done"
}

# Using the version files in $INSTALLERS_DOWNLOAD_DIR/release-versions/,
# copy exactly the set of things that should exist on S3 into deploy-stage
# and then use s3cmd to sync them to the bucket
function publish_public_to_s3() {
    declare DEPLOY_STAGE=$INSTALLERS_DOWNLOAD_DIR/deploy-stage/
    ssh $RELEASE_SERVER_LOGIN $RELEASE_SERVER_SHELL << ENDCMDS
        rm -rf $DEPLOY_STAGE
        mkdir -p $DEPLOY_STAGE
        for version_file in $INSTALLERS_DOWNLOAD_DIR/release-versions/* ; do
            foldername=\$(cat \$version_file | cut -d = -f 2)
            cp -av $INSTALLERS_DOWNLOAD_DIR/\$foldername/* $DEPLOY_STAGE/
        done
        # Copy versions in last, since the versioned client folders may have
        # current.ver and canary.ver files inside
        for version_file in $INSTALLERS_DOWNLOAD_DIR/release-versions/* ; do
            cp \$version_file $DEPLOY_STAGE/
        done
        s3cmd --follow-symlinks --acl-public --delete-removed --cf-invalidate sync "$DEPLOY_STAGE"/* $1
ENDCMDS
}

# Emails team@aerofs.com about this deployment and sends message to #eng channel on Slack
function notify_successful_deployment {
    echo ">> notifying team of successful deployment via Slack"
    echo "$(whoami) pushed $MODE $RELEASE_VERSION" |
        $(git rev-parse --show-cdup)puppetmaster/modules/slack/files/slack_message -c good -u $SLACK_WEBHOOK -f "Deploy" > /dev/null
}

# Uploads proguard map file to the servers that need it.
function upload_map {
    declare MAP_FILE_NAME="aerofs-${RELEASE_VERSION}-${LOWERCASE_MODE}.map"
    echo "uploading proguard map file to $MAP_SERVER..."
    scp "${LOCAL_RELEASE_DIR}/aerofs.map" $MAP_SERVER_LOGIN:"${MAP_FILES_DIR}/${MAP_FILE_NAME}"
}

# Tags this release in the codeline.
#   $1 : public or private (lowercase mode flag)
#
function tag_release {
    case ${1:-} in
    public|private) prefix=$1 ;;
    *)              echo "Illegal tag prefix; should be public or private." ; return 1 ;;
    esac

    echo ">> tagging git release"
    git tag -a "${prefix}-$RELEASE_VERSION" -m "${prefix}-$RELEASE_VERSION"
    git push --tags
}

fi # endif
