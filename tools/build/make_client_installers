#!/bin/bash
set -eu
set -x

###############################################################################
#
# This script builds AeroFS installation and update packages for Linux, OSX and
# Windows
#
###############################################################################

function DieUsage {
    set +x
    echo "usage: $0 <build_product> <release_version> <sign_mode>" >&2
    echo "       [--build-linux-tgz] [--build-linux-update-tgzs] [--build-linux-deb]" >&2
    echo "       [--build-windows-exe] [--build-windows-msi] [--build-osx-packages]" >&2
    echo "       [--build-all]" >&2
    echo " " >&2
    echo "<build_product>: CLIENT|TEAM_SERVER|STORAGE_AGENT" >&2
    echo "<release_version>: release version (for example: 0.1.0)" >&2
    echo "<sign_mode>: SIGNED|UNSIGNED" >&2
    echo "[--build-linux-tgz]: build the Linux installer .tgz" >&2
    echo "[--build-linux-update-tgzs]: build the Linux updater .tgzs" >&2
    echo "[--build-linux-deb]: build the Linux installer .deb " >&2
    echo "[--build-windows-exe]: build the Windows installer .exe " >&2
    echo "[--build-windows-msi]: build the Windows installer .msi " >&2
    echo "[--build-osx-packages]: build the OSX installer/updater packages" >&2
    echo "[--build-all]: build all of the above (the others do not need to be specified)" >&2
    echo " " >&2
    echo "example: $0 CLIENT 0.1.0 UNSIGNED --build-all" >&2
    echo "example: $0 TEAM_SERVER 0.1.0 UNSIGNED --build-linux-tgz --build-linux-update-tgzs" >&2
    exit $ERRBADARGS
}

##
# Parse positional args
##
case ${1:-} in
    CLIENT|TEAM_SERVER|STORAGE_AGENT) BUILD_PRODUCT=$1;;
    *) DieUsage;;
esac
case ${2:-} in
    '') DieUsage;;
    *) readonly RELEASE_VERSION=$2;;
esac
case ${3:-} in
    SIGNED) SIGNED=true;;
    UNSIGNED) SIGNED=false;;
    *) DieUsage;;
esac
shift 3

##
# Parse long opts
##
BUILD_LINUX_INSTALL_TGZ=false
BUILD_LINUX_UPDATE_TGZS=false
BUILD_LINUX_INSTALL_DEB=false
BUILD_WINDOWS_EXE=false
BUILD_WINDOWS_MSI=false
BUILD_OSX_PACKAGES=false
while [ "${1:-}" != "" ]; do
    case "$1" in
        "--build-linux-tgz") BUILD_LINUX_INSTALL_TGZ=true ;;
        "--build-linux-update-tgzs") BUILD_LINUX_UPDATE_TGZS=true ;;
        "--build-linux-deb") BUILD_LINUX_INSTALL_DEB=true ;;
        "--build-windows-exe") BUILD_WINDOWS_EXE=true ;;
        "--build-windows-msi") BUILD_WINDOWS_MSI=true ;;
        "--build-osx-packages") BUILD_OSX_PACKAGES=true ;;
        "--build-all")
            BUILD_LINUX_INSTALL_TGZ=true
            BUILD_LINUX_UPDATE_TGZS=true
            BUILD_LINUX_INSTALL_DEB=true
            BUILD_WINDOWS_EXE=true
            BUILD_WINDOWS_MSI=true
            BUILD_OSX_PACKAGES=true
            ;;
        *)
            echo "Unknown argument: $1" >&2
            DieUsage
            ;;
    esac
    shift
done

include common $BUILD_PRODUCT

###############################################################################
#
# Functions to make packages on all operating systems
#
###############################################################################

function make_linux_installer_deb() {
    local DEBSCRIPT="${BUILD_SCRIPT_DIR}/make_deb"
    mkdir -p "$PACKAGE_DIR"
    "$DEBSCRIPT" $RELEASE_VERSION \
                 $AEROFS_PRODUCT_UNIX \
                 "$LOCAL_RELEASE_DIR" \
                 "${PACKAGE_DIR}/${AEROFS_PRODUCT_UNIX}-installer-${RELEASE_VERSION}.deb"
}

function make_linux_installer_tgz() {
    local TGZ_EXPANDED_DIR=$PACKAGE_BUILD_DIR/linux-installer-tgz
    local local_LINUX_INSTALLER_TGZ_FILENAME=${AEROFS_PRODUCT_UNIX}-installer-${RELEASE_VERSION}.tgz
    rm -rf $TGZ_EXPANDED_DIR
    mkdir -p $TGZ_EXPANDED_DIR/aerofs
    cp -av "${LOCAL_RELEASE_DIR}/aerofs.linux"/* "${TGZ_EXPANDED_DIR}/aerofs/"
    cp -av "${LOCAL_RELEASE_DIR}/aerofs"/* "${TGZ_EXPANDED_DIR}/aerofs/shared/"
    pushd "${TGZ_EXPANDED_DIR}/aerofs/"
        ln -s shared/copier ${AEROFS_PRODUCT_UNIX}
        if ! is_storage_agent ; then
            for suffix in cli gui sh ; do
                ln -s ${AEROFS_PRODUCT_UNIX} ${AEROFS_PRODUCT_UNIX}-$suffix
            done
        fi
    popd
    mkdir -p ${PACKAGE_DIR}
    tar -C "$TGZ_EXPANDED_DIR" -zcf "${PACKAGE_DIR}/${local_LINUX_INSTALLER_TGZ_FILENAME}" aerofs
}

function make_linux_update_tgz() {
    if [[ "x$1" != "xi386" && "x$1" != "xamd64" ]]; then
        echo "error: unsupported bits:$1" >&2
        echo "usage: make_linux_update_tgz [i386|amd64]" >&2
        exit $ERRBADARGS
    fi

    local local_ARCH="$1"
    local local_TGZ_SUFFIX=""
    case "$local_ARCH" in
    "i386")
        local_TGZ_SUFFIX="x86"
        ;;
    "amd64")
        local_TGZ_SUFFIX="x86_64"
        ;;
    *)
        echo "error: unsupported arch:$local_ARCH" >&2
        exit $ERRBADARGS
        ;;
    esac

    echo ">> make arch dependent tgz (${local_ARCH})"
    local VERSIONED_ARCH_TGZ_FILENAME=${AEROFS_PRODUCT_UNIX}-${RELEASE_VERSION}-${local_TGZ_SUFFIX}.tgz
    ARCH_TGZ_TEMP_DIR="$PACKAGE_BUILD_DIR/linux-$local_TGZ_SUFFIX"
    rm -rf "$ARCH_TGZ_TEMP_DIR"
    mkdir -p "${ARCH_TGZ_TEMP_DIR}/aerofs"
    cp -a "${LOCAL_RELEASE_DIR}/aerofs"/* "${ARCH_TGZ_TEMP_DIR}/aerofs"
    cp -a "${LOCAL_RELEASE_DIR}/aerofs.linux/shared"/* "${ARCH_TGZ_TEMP_DIR}/aerofs"
    cp -a "${LOCAL_RELEASE_DIR}/aerofs.linux/${local_ARCH}"/* "${ARCH_TGZ_TEMP_DIR}/aerofs"
    mkdir -p ${PACKAGE_DIR}
    tar -C "${ARCH_TGZ_TEMP_DIR}" -zcf "${PACKAGE_DIR}/${VERSIONED_ARCH_TGZ_FILENAME}" aerofs
}

function make_windows_installers() {
    echo ">> make windows installer"
    mkdir -p ${PACKAGE_DIR}
    local OUT_EXE="${PACKAGE_DIR}/${AEROFS_PRODUCT_SPACEFREE}Install-${RELEASE_VERSION}.exe"
    local OUT_MSI="${PACKAGE_DIR}/${AEROFS_PRODUCT_SPACEFREE}Install-${RELEASE_VERSION}.msi"
    local EXECUTABLE="${AEROFS_PRODUCT_UNIX}.exe"

    # This function is used to sign exe files and dll's
    function sign_exe() {
        FILENAME="$1"

        local CERT_FILE="/Volumes/aerofskeys/windows/cert.spc"
        local KEY_FILE="/Volumes/aerofskeys/windows/privateKey.pvk"
        local CODESIGNING_PASSWORD_FILE="/Volumes/aerofskeys/windows/passphrase.txt"
        # If we later want to let CI use a test cert and key for signing, use the following:
        # CERT_FILE="$BUILD_SCRIPT_DIR/signing/cert.spc"
        # KEY_FILE="$BUILD_SCRIPT_DIR/signing/privateKey.pvk"
        # CODESIGNING_PASSWORD_FILE="$BUILD_SCRIPT_DIR/signing/passphrase.txt"
        if [ ! -r $CODESIGNING_PASSWORD_FILE ] ; then
            echo "Cannot signcode: unable to read Windows codesigning password from $CODESIGNING_PASSWORD_FILE" >&2
            return 1
        fi
        CODESIGNING_PASSWORD=$(cat $CODESIGNING_PASSWORD_FILE)
        export PASSPHRASE="$CODESIGNING_PASSWORD"
        [[ -r "$CERT_FILE" && -r "$KEY_FILE" ]] || (echo "Can't find cert/key at $CERT_FILE and $KEY_FILE - do you need to mount a volume?" && exit 1)
        printenv PASSPHRASE | signcode -spc "$CERT_FILE" -v "$KEY_FILE" \
            -a sha1 -$ commercial -t http://timestamp.verisign.com/scripts/timestamp.dll \
            -tr 10 -n "AeroFS" -i "http://www.aerofs.com" "${FILENAME}"

        rm -f "${FILENAME}.bak"
    }

    # Create a temporary directory to work in
    local WINDOWS_BUILD_DIR_NAME="windows-expanded"
    local WINDOWS_TEMP_DIR="$PACKAGE_BUILD_DIR/$WINDOWS_BUILD_DIR_NAME"
    rm -rf $WINDOWS_TEMP_DIR
    mkdir -p $WINDOWS_TEMP_DIR

    # Create a subfolder in that directory with the version number
    # Note: we prepend v_ to the version number to make it easy for the NSIS installer
    # to enumerate and delete all previous versions directories
    WINDOWS_TEMP_DIR_WITH_VERSION="${WINDOWS_TEMP_DIR}/v_${RELEASE_VERSION}"
    mkdir "${WINDOWS_TEMP_DIR_WITH_VERSION}"

    # Copy the aerofs release files in that directory
    cp -a "${LOCAL_RELEASE_DIR}/aerofs"/* "${WINDOWS_TEMP_DIR_WITH_VERSION}/"
    cp -a "${LOCAL_RELEASE_DIR}/aerofs.win"/* "${WINDOWS_TEMP_DIR_WITH_VERSION}/"

    # Move the things that need to stay at the top-level folder
    # Also rename aerofs.exe to the appropriate name
    mv "${WINDOWS_TEMP_DIR_WITH_VERSION}/aerofs.exe" "${WINDOWS_TEMP_DIR}/$EXECUTABLE"
    mv "${WINDOWS_TEMP_DIR_WITH_VERSION}/aerofsd.exe" "${WINDOWS_TEMP_DIR}/"
    echo -n "${RELEASE_VERSION}" > "${WINDOWS_TEMP_DIR}/version"
    mkdir "${WINDOWS_TEMP_DIR}/icons"
    mv "${WINDOWS_TEMP_DIR_WITH_VERSION}/icons"/*.ico "${WINDOWS_TEMP_DIR}/icons"

    chmod -R a+rx "${WINDOWS_TEMP_DIR}"

    if $SIGNED ; then
        sign_exe "${WINDOWS_TEMP_DIR}/$EXECUTABLE"
        sign_exe "${WINDOWS_TEMP_DIR}/aerofsd.exe"
    fi

    if [ "${BUILD_WINDOWS_EXE}" == "true" ] ; then
        makensis -V1 -DAEROFS_IN_FOLDER="${WINDOWS_TEMP_DIR}" \
                -DAEROFS_OUT_FILE="$OUT_EXE" \
                -DAEROFS_VERSION="$RELEASE_VERSION" \
                -DAEROFS_PRODUCT="$AEROFS_PRODUCT" \
                -DAEROFS_APPROOT="${AEROFS_PRODUCT_SPACEFREE}Exec" \
                -DAEROFS_EXECUTABLE="$EXECUTABLE" \
                "${LOCAL_WINDOWS_DIR}/setup.nsi"

        if $SIGNED ; then
            sign_exe "$OUT_EXE"
        fi
    fi

    if [ "${BUILD_WINDOWS_MSI}" == "true" ] ; then
        # If you think the following line looks bizzare and makes no sense then
        # you are a reasonable person and much sensible than past-Alex.
        #
        # tl;dr: it's weird for historical reasons
        #
        # See comments in build.py for more info.
        find "${WINDOWS_TEMP_DIR}" | "${LOCAL_MSI_DIR}/build.py" \
            --directory "${WINDOWS_TEMP_DIR}" \
            --base-msi "${LOCAL_MSI_DIR}/${AEROFS_PRODUCT_SPACEFREE}Install.msi" \
            --output-msi "${OUT_MSI}" \
            --set-version "${RELEASE_VERSION}" \
            --workspace "${WINDOWS_TEMP_DIR}/workspace" | bash
    fi
}

function make_osx_packages() {
    echo ">> make mac osx dmg and zip"
    mkdir -p ${PACKAGE_DIR}

    local local_VERSIONED_MAC_ZIP_FILENAME="${AEROFS_PRODUCT_UNIX}-osx-${RELEASE_VERSION}.zip"
    local local_VERSIONED_MAC_DMG_FILENAME="${AEROFS_PRODUCT_SPACEFREE}Install-${RELEASE_VERSION}.dmg"
    local local_UNVERSIONED_MAC_DMG_FILENAME="${AEROFS_PRODUCT_SPACEFREE}Install.dmg"
    local local_OSX_LOCAL_MAC_APP_DIR=Release/${AEROFS_PRODUCT_SPACEFREE}.app/Contents/Resources/Java
    local local_OSX_INSTALLER_VOLUME_DIR="/Volumes/${AEROFS_PRODUCT_SPACEFREE} Installer"
    local local_OSX_TEMPLATE_APP_FILENAME="osx/${AEROFS_PRODUCT_UNIX}.app.template"

    readonly local_VERSIONED_MAC_ZIP_FILENAME
    readonly local_VERSIONED_MAC_DMG_FILENAME
    readonly local_UNVERSIONED_MAC_DMG_FILENAME
    readonly local_OSX_LOCAL_MAC_APP_DIR
    readonly local_OSX_INSTALLER_VOLUME_DIR
    readonly local_OSX_TEMPLATE_APP_FILENAME

    # Create a temporary directory to work in
    local DMG_TEMP_DIR="$PACKAGE_BUILD_DIR/osx-dmg"

    # Create a release folder within the temp directory and copy the template dmg and app folder
    rm -rf "${DMG_TEMP_DIR}"
    mkdir -p "${DMG_TEMP_DIR}/Release"
    cp -a "${BUILD_SCRIPT_DIR}/${local_OSX_TEMPLATE_APP_FILENAME}" \
        "${DMG_TEMP_DIR}/Release/${AEROFS_PRODUCT_SPACEFREE}.app"

    # Copy the aerofs and aerofs.osx files into the Mac App directory within the temp directory created above
    cp -a "${AEROFS_RELEASE_DIR}"/* "${AEROFS_RELEASE_OSX_DIR}"/* "${DMG_TEMP_DIR}/${local_OSX_LOCAL_MAC_APP_DIR}/"

    if $SIGNED ; then
        echo ">> sign app for Mac App Store"
        # Unlock the keychain, to prevent AFK dev from failing a build.  All
        # the secrets are available already anyway.
        SECURE_VOLUME="/Volumes/aerofskeys"
        OSX_KEYCHAIN_FILE="$SECURE_VOLUME/aerofs.keychain"
        OSX_KEYCHAIN_PASSPHRASE_FILE="$SECURE_VOLUME/keychain_passphrase.txt"
        security unlock-keychain -p "$(cat $OSX_KEYCHAIN_PASSPHRASE_FILE)" "$OSX_KEYCHAIN_FILE"
        # see http://developer.apple.com/library/mac/technotes/tn2206/_index.html#//apple_ref/doc/uid/DTS40007919-CH1-SUBSECTION9
        # for information on signing frameworks
        # Note: We avoid re-codesigning AeroFSFinderExtension because every
        # time we do so, it changes the binary, which in turn changes the
        # checksum, so we kill finder on update.  Instead, we have pre-signed
        # the checked-in resource, and must update the signature whenever we
        # modify anything under the .osax folder.
        #codesign --force --sign "Air Computing, Inc." "${DMG_TEMP_DIR}/Release/${AEROFS_PRODUCT_SPACEFREE}.app/Contents/Resources/Java/AeroFSFinderExtension.osax"
        codesign --force --sign "Air Computing, Inc." "${DMG_TEMP_DIR}/Release/${AEROFS_PRODUCT_SPACEFREE}.app/Contents/Resources/Java/Growl.framework/Versions/A"
        codesign --resource-rules "$BUILD_SCRIPT_DIR/osx/rules.plist" \
                 --force \
                 --sign "Air Computing, Inc." \
                 "${DMG_TEMP_DIR}/Release/${AEROFS_PRODUCT_SPACEFREE}.app"
    fi

    # zip the osx client (must go to the directory so that the temp path isn't included in the zip)
    pushd "$DMG_TEMP_DIR" > /dev/null
    zip -9 --symlinks --quiet --recurse-paths "${PACKAGE_DIR}/$local_VERSIONED_MAC_ZIP_FILENAME" "Release/"
    popd > /dev/null

    # Add DMG-specific contents
    ln -s /Applications "${DMG_TEMP_DIR}/Release/Applications"
    cp -a "${BUILD_SCRIPT_DIR}/osx/dmg_contents/"{.background,.VolumeIcon.icns} "${DMG_TEMP_DIR}/Release/"
    cp -a "${BUILD_SCRIPT_DIR}/osx/dmg_contents/${AEROFS_PRODUCT_UNIX}/DS_Store" "${DMG_TEMP_DIR}/Release/.DS_Store"

    # Build the installer DMG
    case $(uname) in
        Darwin)
            # Create read-write DMG
            # TODO: make the volume name not spacefree (requires fixing DS_Store for aerofsts)
            hdiutil create -fs HFS+ -volname "${AEROFS_PRODUCT} Installer" \
                -srcfolder "${DMG_TEMP_DIR}/Release/" \
                -format UDRW \
                -o "${DMG_TEMP_DIR}/${AEROFS_PRODUCT_SPACEFREE}-temp.dmg"
            # Mount DMG
            MOUNTPOINT="${DMG_TEMP_DIR}/mnt"
            hdiutil attach -readwrite -noautoopen "${DMG_TEMP_DIR}/${AEROFS_PRODUCT_SPACEFREE}-temp.dmg" -mountpoint "$MOUNTPOINT"
            # Set volume icon creator to 'icnC' (icon creator)
            SetFile -c icnC "${MOUNTPOINT}/.VolumeIcon.icns"
            # Set volume icon enabled
            SetFile -a C "${MOUNTPOINT}"
            # Unmount DMG
            hdiutil detach "$MOUNTPOINT"
            # Convert RW DMG to bzip2-compressed DMG
            hdiutil convert "${DMG_TEMP_DIR}/${AEROFS_PRODUCT_SPACEFREE}-temp.dmg" -format UDBZ -o "${PACKAGE_DIR}/${local_VERSIONED_MAC_DMG_FILENAME}"
            ;;
        Linux)
            # Create HFS filesystem
            HFS_IMAGE="${DMG_TEMP_DIR}/img.hfs"
            dd if=/dev/zero of=$HFS_IMAGE bs=1024 seek=153600 count=1
            mkfs.hfsplus -v "${AEROFS_PRODUCT} Installer" "$HFS_IMAGE"
            # Add image contents
            hfsplus "$HFS_IMAGE" mkdir "/.background"
            hfsplus "$HFS_IMAGE" addall "${DMG_TEMP_DIR}/Release/.background" "/.background"
            hfsplus "$HFS_IMAGE" add "${DMG_TEMP_DIR}/Release/.VolumeIcon.icns" "/.VolumeIcon.icns"
            hfsplus "$HFS_IMAGE" add "${DMG_TEMP_DIR}/Release/.DS_Store" "/.DS_Store"
            hfsplus "$HFS_IMAGE" mkdir "/${AEROFS_PRODUCT_SPACEFREE}.app"
            hfsplus "$HFS_IMAGE" addall "${DMG_TEMP_DIR}/Release/${AEROFS_PRODUCT_SPACEFREE}.app" "/${AEROFS_PRODUCT_SPACEFREE}.app"
            hfsplus "$HFS_IMAGE" symlink "/Applications" "/Applications"
            # Enable custom icon on drive root
            hfsplus "$HFS_IMAGE" attr / C
            # Wrap the HFS+ filesystem up in a DMG
            dmg build "$HFS_IMAGE" "${PACKAGE_DIR}/${local_VERSIONED_MAC_DMG_FILENAME}"
            rm "$HFS_IMAGE"
            ;;
        *)
            echo "unsupported platform $(uname)"
            exit 1
            ;;
    esac
}

function create_release_version_file() {
    declare VERSION_FILE="${PACKAGE_DIR}/${CURRENT_VER}"
    echo Version=$RELEASE_VERSION > "$VERSION_FILE"
    chmod a+r "$VERSION_FILE"
}

function make_installers() {
    local JOBS=""

    if [ "$BUILD_LINUX_INSTALL_DEB" == "true" ] ; then
        make_linux_installer_deb &
        JOBS="$JOBS $!"
    fi

    if [ "$BUILD_LINUX_INSTALL_TGZ" == "true" ] ; then
        make_linux_installer_tgz &
        JOBS="$JOBS $!"
    fi

    if [ "$BUILD_LINUX_UPDATE_TGZS" == "true" ] ; then
        make_linux_update_tgz i386 &
        JOBS="$JOBS $!"
        make_linux_update_tgz amd64 &
        JOBS="$JOBS $!"
    fi

    if [ "$BUILD_WINDOWS_EXE" == "true" ] || [ "$BUILD_WINDOWS_MSI" == "true" ] ; then
        make_windows_installers &
        JOBS="$JOBS $!"
    fi

    if [ "$BUILD_OSX_PACKAGES" == "true" ] ; then
        make_osx_packages &
        JOBS="$JOBS $!"
    fi

    if [ "$JOBS" == "" ] ; then
        echo "The caller did not request to make any client installers!"
        echo "This is likely a bug. Abort!"
        exit 1
    fi

    # Check that all the background tasks completed successfully
    FAIL=0
    for JOB in $JOBS ; do
        wait $JOB || let "FAIL+=1"
    done

    if [ "$FAIL" != "0" ] ; then
        echo "$FAIL of the packaging tasks failed."
        exit $FAIL
    fi
}

echo ">> make client installers and packages in $PACKAGE_DIR"
compute_product_names
make_installers
create_release_version_file
exit 0
