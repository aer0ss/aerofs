#!/bin/bash -e -u

###############################################################################
#
# This script packages AeroFS for linux, osx and windows and uploads the
# packages to the release server for deployment.
#
###############################################################################

include include/common $1

###############################################################################
#
# usage and variable definitions
#
###############################################################################

if [[ x"${1:-}" == x || x"${2:-}" == x || x"${3:-}" == x ]] ; then
    echo "usage: $0 [build_mode] [release_version] [passphrase]" >&2
    echo " " >&2
    echo "[build_mode]: STAGING or PROD" >&2
    echo "[release_version]: release version (for example: 0.1.0)" >&2
    echo "[passphrase]: release password" >&2
    echo " " >&2
    echo "example: $0 STAGING 0.1.0 password" >&2
    exit $ERRBADARGS
fi

readonly RELEASE_VERSION="$2"
readonly PASSPHRASE="$3"
readonly RELEASE_FILE_NAME="aerofs-${RELEASE_VERSION}-${LOWERCASE_MODE}"

# FIXME (AG) : the linux tgz and deb can both be built locally on OSX

###############################################################################
#
# Uploads the release files on the local machine to the release server.
#
###############################################################################
function upload_release_files_to_release_server() {
    echo ">> uploading release resources to server"

    local local_TEMP_RELEASE_ZIP_FILENAME="$( mktemp -t aerofs_temp_zip_XXXXXX )".zip
    trap "rm $local_TEMP_RELEASE_ZIP_FILENAME" EXIT

    # Create the zip
    pushd "$LOCAL_RELEASE_DIR" > /dev/null
    zip -9rqy "$local_TEMP_RELEASE_ZIP_FILENAME" {aerofs,aerofs.osx,aerofs.win,aerofs.linux32,aerofs.linux64,aerofs.linux,aerofs.linux.inst}
    popd > /dev/null

    # Copy the zip to the release server
    kscp "$local_TEMP_RELEASE_ZIP_FILENAME" $RELEASE_SERVER_LOGIN:"${RELEASE_FILES_DIR}/${RELEASE_FILE_NAME}".zip

    # Unzip the files on the server into RELEASE_UNPACK_DIR
    # NOTE: Instead of using rsync to get these files to the release server,
    # we zip then unzip because the Windows patch script requires a history of
    # zip files on the server to process diffs.
    # NOTE (GS): We no longer do patch updates on Windows, so this isn't required
    # anymore. We may switch to rsync.
    kssh $RELEASE_SERVER_LOGIN $RELEASE_SERVER_SHELL << ENDCMDS
        rm -r "$RELEASE_UNPACK_DIR" 2> /dev/null || true
        mkdir -p "$RELEASE_UNPACK_DIR"
        unzip -qo -d "$RELEASE_UNPACK_DIR" "${RELEASE_FILES_DIR}/${RELEASE_FILE_NAME}".zip
ENDCMDS
}

###############################################################################
#
# Uploads the local map file to the map server with a versioned name.
#
###############################################################################
function upload_map_file_to_map_server() {
    echo ">> uploading ProGuard map to map server"

    kscp "${LOCAL_RELEASE_DIR}/aerofs.map" $MAP_SERVER_LOGIN:"${MAP_FILES_DIR}/${RELEASE_FILE_NAME}.map"
    scp "${LOCAL_RELEASE_DIR}/aerofs.map" $ROCKLOG_SERVER:"${MAP_FILES_DIR}/${RELEASE_FILE_NAME}.map"
}

###############################################################################
#
# Creates a folder for this release version on the release server.
#
###############################################################################
function create_versioned_installer_directory_on_release_server() {
    echo ">> creating directory for installers"

    kssh $RELEASE_SERVER_LOGIN $RELEASE_SERVER_SHELL << ENDCMDS
        mkdir -p "${INSTALLERS_DOWNLOAD_DIR}/${RELEASE_VERSION}"
        rm "${INSTALLERS_DOWNLOAD_DIR}/${RELEASE_VERSION}"/* 2> /dev/null || true
ENDCMDS
}

###############################################################################
#
# Uploads the make_deb script and builds a debian package on the release server.
#
###############################################################################
function make_linux_installer_deb_on_release_server() {
    echo ">> make arch independent installer deb on release server"

    # FIXME (AG): I don't want to have to kscp make_deb to the remote machine
    kscp "${BUILD_SCRIPT_DIR}/make_deb" $RELEASE_SERVER_LOGIN:~/
    kssh $RELEASE_SERVER_LOGIN $RELEASE_SERVER_SHELL << ENDCMDS
        chmod a+x ~/make_deb
        ~/make_deb $MODE $RELEASE_VERSION "$RELEASE_UNPACK_DIR" "${INSTALLERS_DOWNLOAD_DIR}/${RELEASE_VERSION}/aerofs-installer.deb"
ENDCMDS
}

###############################################################################
#
# Tars and gzips the aerofs resources and moves them to the download directory
# on the release server.
#
###############################################################################
function make_linux_installer_tgz_on_release_server() {
    echo ">> make arch independent installer tgz on release server"

    # Any variables that are defined within the remote shell are referenced via \$ to make sure
    # the variables aren't substituted in the local shell
    local local_LINUX_INSTALLER_TGZ_FILENAME=aerofs-installer.tgz
    kssh $RELEASE_SERVER_LOGIN $RELEASE_SERVER_SHELL << ENDCMDS
        readonly INSTALLER_TGZ_TEMP_DIR="\$( mktemp -d -t temp_tgz_XXXXXX )"
        trap "rm -r \$INSTALLER_TGZ_TEMP_DIR" EXIT

        mkdir -p "\${INSTALLER_TGZ_TEMP_DIR}/aerofs"
        cp -rf "${RELEASE_UNPACK_DIR}/aerofs.linux.inst"/* "\${INSTALLER_TGZ_TEMP_DIR}/aerofs/"
        tar -C "\$INSTALLER_TGZ_TEMP_DIR" -zcf "\${INSTALLER_TGZ_TEMP_DIR}/${local_LINUX_INSTALLER_TGZ_FILENAME}" aerofs
        cp "\${INSTALLER_TGZ_TEMP_DIR}/${local_LINUX_INSTALLER_TGZ_FILENAME}" "${INSTALLERS_DOWNLOAD_DIR}/${RELEASE_VERSION}/"
ENDCMDS
}

###############################################################################
#
# Tars and gzips aerofs resources based on their architecture (32 bit/64 bit)
# and moves them to the download directory on the release server.
#
# @param $1 32|64 (all other values treated as errors)
#
# example:
#   make_linux_arch_dependent_tgz_on_release_server 32
#
###############################################################################
function make_linux_arch_dependent_tgz_on_release_server() {
    if [[ "x$1" != "x32" && "x$1" != "x64" ]]; then
        echo "error: unsupported bits:$1" >&2
        echo "usage: make_linux_arch_dependent_tgz_on_release_server [32|64]" >&2
        exit $ERRBADARGS
    fi

    local local_BITS="$1"
    local local_TGZ_SUFFIX=""
    case "$local_BITS" in
    "32")
        local_TGZ_SUFFIX="x86"
        ;;
    "64")
        local_TGZ_SUFFIX="x86_64"
        ;;
    *)
        echo "error: unsupported bits:$local_BITS" >&2
        ;;
    esac

    echo ">> make arch dependent tgz (${local_BITS}-bit) on release server"

    local local_VERSIONED_ARCH_TGZ_FILENAME=aerofs-${RELEASE_VERSION}-${local_TGZ_SUFFIX}.tgz
    local local_UNVERSIONED_ARCH_TGZ_FILENAME=aerofs-${local_TGZ_SUFFIX}.tgz

    # Any variables that are defined within the remote shell are referenced via \$ to make sure
    # the variables aren't substituted in the local shell
    kssh $RELEASE_SERVER_LOGIN $RELEASE_SERVER_SHELL << ENDCMDS
        readonly ARCH_TGZ_TEMP_DIR="\$( mktemp -d -t temp_arch_tgz_XXXXXX )"
        trap "rm -r \$ARCH_TGZ_TEMP_DIR" EXIT

        mkdir -p "\${ARCH_TGZ_TEMP_DIR}/aerofs"
        cp -rf "${RELEASE_UNPACK_DIR}/aerofs"/* "\${ARCH_TGZ_TEMP_DIR}/aerofs"
        cp -rf "${RELEASE_UNPACK_DIR}/aerofs.linux"/* "\${ARCH_TGZ_TEMP_DIR}/aerofs"
        cp -rf "${RELEASE_UNPACK_DIR}/aerofs.linux${local_BITS}"/* "\${ARCH_TGZ_TEMP_DIR}/aerofs"
        tar -C "\${ARCH_TGZ_TEMP_DIR}" -zcf "\${ARCH_TGZ_TEMP_DIR}/${local_VERSIONED_ARCH_TGZ_FILENAME}" aerofs
        cp -rf "\${ARCH_TGZ_TEMP_DIR}/${local_VERSIONED_ARCH_TGZ_FILENAME}" "${INSTALLERS_DOWNLOAD_DIR}/${RELEASE_VERSION}/"
        cp -rf "\${ARCH_TGZ_TEMP_DIR}/${local_VERSIONED_ARCH_TGZ_FILENAME}" "${INSTALLERS_DOWNLOAD_DIR}/${RELEASE_VERSION}/${local_UNVERSIONED_ARCH_TGZ_FILENAME}"
ENDCMDS
}

###############################################################################
#
# Creates all the linux installer variants
#
###############################################################################
function make_linux_installers() {
    make_linux_installer_deb_on_release_server
    make_linux_installer_tgz_on_release_server
    make_linux_arch_dependent_tgz_on_release_server 32
    make_linux_arch_dependent_tgz_on_release_server 64
}

###############################################################################
#
# Creates the Windows installer on the release server and moves it to the
# download directory. Uploads installer to Kaspersky when deploying PROD mode.
#
###############################################################################
function make_windows_installers() {
    echo ">> make windows installer on release server"

    local local_VERSIONED_INSTALLER_DIR="${INSTALLERS_DOWNLOAD_DIR}/${RELEASE_VERSION}"
    readonly local_VERSIONED_INSTALLER_DIR

    # deploy NSIS scripts
    rsync --archive --compress --rsh kssh "${LOCAL_NSIS_DIR}/" $RELEASE_SERVER_LOGIN:"$RELEASE_NSIS_DIR"

    # now make the installer
    kssh $RELEASE_SERVER_LOGIN $RELEASE_SERVER_SHELL << ENDCMDS

        # Create a temporary directory to work in
        NSIS_TEMP_DIR="\$( mktemp -d -t nsis.XXXXXXXX )"
        trap "rm -r \"\$NSIS_TEMP_DIR\"" EXIT

        # Create a subfolder in that directory with the version number
        # Note: we prepend v_ to the version number to make it easy for the NSIS installer
        # to enumerate and delete all previous versions directories
        NSIS_TEMP_DIR_WITH_VERSION="\${NSIS_TEMP_DIR}/v_${RELEASE_VERSION}"
        mkdir "\${NSIS_TEMP_DIR_WITH_VERSION}"

        # Copy the aerofs release files in that directory
        cp -r "${RELEASE_UNPACK_DIR}/aerofs"/* "\${NSIS_TEMP_DIR_WITH_VERSION}/"
        cp -r "${RELEASE_UNPACK_DIR}/aerofs.win"/* "\${NSIS_TEMP_DIR_WITH_VERSION}/"

        # Move the things that need to stay at the top-level folder
        mv "\${NSIS_TEMP_DIR_WITH_VERSION}/aerofs.exe" "\${NSIS_TEMP_DIR}/"
        mv "\${NSIS_TEMP_DIR_WITH_VERSION}/aerofsd.exe" "\${NSIS_TEMP_DIR}/"
        mv "\${NSIS_TEMP_DIR_WITH_VERSION}/plugins" "\${NSIS_TEMP_DIR}/"
        mkdir "\${NSIS_TEMP_DIR}/icons"
        mv "\${NSIS_TEMP_DIR_WITH_VERSION}/icons"/*.ico "\${NSIS_TEMP_DIR}/icons"

        # Move aerofs.ini from from the version directory to the parent dir and sed the version number into it
        sed -e "s={RELEASE_VERSION__TO_BE_REPLACED_BY_SED}=$RELEASE_VERSION=" \
            "\${NSIS_TEMP_DIR_WITH_VERSION}/aerofs.ini.template" > "\${NSIS_TEMP_DIR}/aerofs.ini"
        rm "\${NSIS_TEMP_DIR_WITH_VERSION}/aerofs.ini.template"

        chmod -R a+rx "\${NSIS_TEMP_DIR}"

        makensis -V1 -DAEROFS_IN_FOLDER="\${NSIS_TEMP_DIR}" -DAEROFS_OUT_FOLDER="$local_VERSIONED_INSTALLER_DIR" \
                 -DAEROFS_VERSION="$RELEASE_VERSION" "${RELEASE_NSIS_DIR}/setup.nsi"

        export PASSPHRASE="$PASSPHRASE"
        printenv PASSPHRASE | signcode -spc ~/.certs/cert.spc -v ~/.certs/privateKey.pvk \
            -a sha1 -$ commercial -t http://timestamp.verisign.com/scripts/timstamp.dll \
            -tr 10 -n "AeroFS" -i "http://www.aerofs.com" "${local_VERSIONED_INSTALLER_DIR}/AeroFSInstall-${RELEASE_VERSION}.exe" > /dev/null

        cp -r "${local_VERSIONED_INSTALLER_DIR}/AeroFSInstall-${RELEASE_VERSION}.exe" "${local_VERSIONED_INSTALLER_DIR}/AeroFSInstall.exe"
        chmod a+r "${local_VERSIONED_INSTALLER_DIR}/AeroFSInstall-${RELEASE_VERSION}.exe"
        chmod a+r "${local_VERSIONED_INSTALLER_DIR}/AeroFSInstall.exe"

        # Kaspersky requires us to upload the entire unpacked contents of aerofs into their servers
        # we also upload the install file for whitelisting, as some versions of the antivirus flag the
        # installer as a potential virus
        if [ "$MODE" == "PROD" ]; then
            lftp -e "mirror -R \${NSIS_TEMP_DIR}/ /aerofs/; bye" -u \`cat ~/.lftp/login.cfg\` whitelist1.kaspersky-labs.com
            lftp -e 'put $local_VERSIONED_INSTALLER_DIR/AeroFSInstall.exe; bye' -u \`cat ~/.lftp/login.cfg\` whitelist1.kaspersky-labs.com
        fi

ENDCMDS
}

###############################################################################
#
# Creates the Mac OS X DMG and Zip file and uploads it to the release server.
# Signs the App if deployment mode is PROD
#
###############################################################################
function make_osx_installers() {
    echo ">> make mac osx dmg and zip"

    local local_VERSIONED_MAC_ZIP_FILENAME="aerofs-osx-${RELEASE_VERSION}.zip"
    local local_VERSIONED_MAC_DMG_FILENAME="AeroFSInstall-${RELEASE_VERSION}.dmg"
    local local_UNVERSIONED_MAC_DMG_FILENAME="AeroFSInstall.dmg"

    readonly local_VERSIONED_MAC_ZIP_FILENAME
    readonly local_VERSIONED_MAC_DMG_FILENAME
    readonly local_UNVERSIONED_MAC_DMG_FILENAME

    # Create a temporary directory to work in
    local local_DMG_TEMP_DIR="$( mktemp -d -t dmg )"
    trap "rm -r \"$local_DMG_TEMP_DIR\"" EXIT

    # Create a release folder within the temp directory and copy the template dmg and AeroFS.app folder
    mkdir "${local_DMG_TEMP_DIR}/Release"
    cp -R "${BUILD_SCRIPT_DIR}/${OSX_TEMPLATE_APP_FILENAME}" "${local_DMG_TEMP_DIR}/Release/AeroFS.app"
    cp "${BUILD_SCRIPT_DIR}/${OSX_TEMPLATE_DMG_FILENAME}" "${local_DMG_TEMP_DIR}/AeroFSInstall-temp.dmg"

    # Copy the aerofs and aerofs.osx files into the Mac App directory within the temp directory created above
    cp -r "${AEROFS_RELEASE_DIR}"/* "${AEROFS_RELEASE_OSX_DIR}"/* "${local_DMG_TEMP_DIR}/${OSX_LOCAL_MAC_APP_DIR}/"

    if is_prod ; then
        echo ">> sign AeroFS.app for Mac App Store"
        # see http://developer.apple.com/library/mac/technotes/tn2206/_index.html#//apple_ref/doc/uid/DTS40007919-CH1-SUBSECTION9
        # for information on signing frameworks
        codesign -f -s "Air Computing, Inc." "${local_DMG_TEMP_DIR}/Release/AeroFS.app/Contents/Resources/Java/Growl.framework/Versions/A"
        codesign -f -s "Air Computing, Inc." "${local_DMG_TEMP_DIR}/Release/AeroFS.app/Contents/Resources/Java/AeroFSFinderExtension.osax"
        codesign -f -s "Air Computing, Inc." "${local_DMG_TEMP_DIR}/Release/AeroFS.app"
    fi

    # zip the osx client (must go to the directory so that the temp path isn't included in the zip)
    pushd "$local_DMG_TEMP_DIR" > /dev/null
    zip -9rq "$local_VERSIONED_MAC_ZIP_FILENAME" "Release/"
    popd > /dev/null

    hdiutil mount -quiet "${local_DMG_TEMP_DIR}/AeroFSInstall-temp.dmg"
    rm -rf "${OSX_AEROFS_INSTALLER_VOLUME_DIR}/AeroFS.app"
    cp -R "${local_DMG_TEMP_DIR}/Release/AeroFS.app" "$OSX_AEROFS_INSTALLER_VOLUME_DIR"
    hdiutil eject -quiet "$OSX_AEROFS_INSTALLER_VOLUME_DIR"
    hdiutil convert -quiet -format UDBZ -o "${local_DMG_TEMP_DIR}/${local_VERSIONED_MAC_DMG_FILENAME}" "${local_DMG_TEMP_DIR}/AeroFSInstall-temp.dmg"

    echo ">> upload mac os x release zip and dmg to release server"
    kscp "${local_DMG_TEMP_DIR}/${local_VERSIONED_MAC_ZIP_FILENAME}" $RELEASE_SERVER_LOGIN:"${INSTALLERS_DOWNLOAD_DIR}/${RELEASE_VERSION}"
    kscp "${local_DMG_TEMP_DIR}/${local_VERSIONED_MAC_DMG_FILENAME}" $RELEASE_SERVER_LOGIN:"${INSTALLERS_DOWNLOAD_DIR}/${RELEASE_VERSION}"
    kssh $RELEASE_SERVER_LOGIN $RELEASE_SERVER_SHELL << ENDCMDS
        cd "${INSTALLERS_DOWNLOAD_DIR}/${RELEASE_VERSION}"
        cp "$local_VERSIONED_MAC_DMG_FILENAME" "$local_UNVERSIONED_MAC_DMG_FILENAME"
ENDCMDS
}

###############################################################################
#
# Creates the current.ver file in the release folder to specify the version of
# the release to clients when this release is published. This file's presence
# also marks the packaging process as complete.
# This file should be checked by the publisher to ensure that this release is ready.
#
###############################################################################
function create_release_version_file_on_server() {
    echo ">> create current.ver for this release"

    local local_VERSION_FILE="${INSTALLERS_DOWNLOAD_DIR}/${RELEASE_VERSION}/${RELEASE_SERVER_VERSION_FILE}"
    kssh $RELEASE_SERVER_LOGIN $RELEASE_SERVER_SHELL << ENDCMDS
        echo Version=$RELEASE_VERSION > "$local_VERSION_FILE"
        chmod a+r "$local_VERSION_FILE"
ENDCMDS
}

#****************************************
#****************************************
#**
#** Run the actual installer build steps
#**
#****************************************
#****************************************
echo ">> make client installers and packages on release server"

upload_release_files_to_release_server
upload_map_file_to_map_server
create_versioned_installer_directory_on_release_server
make_linux_installers
make_windows_installers
make_osx_installers
create_release_version_file_on_server

exit 0
