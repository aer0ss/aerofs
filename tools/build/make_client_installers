#!/bin/bash -e -u

###############################################################################
#
# This script packages AeroFS for linux, osx and windows and uploads the
# packages to the release server for deployment.
#
###############################################################################

include include/common ${1:-} ${2:-}

###############################################################################
#
# usage and variable definitions
#
###############################################################################

if [[ x"${1:-}" == x || x"${2:-}" == x || x"${3:-}" == x  || x"${4:-}" == x ]] ; then
    echo "usage: $0 [build_mode] [release_version] [passphrase]" >&2
    echo " " >&2
    echo "[build_mode]: PROD|ENTERPRISE" >&2
    echo "[build_client]: CLIENT|TEAM_SERVER" >&2
    echo "[release_version]: release version (for example: 0.1.0)" >&2
    echo "[passphrase]: release password" >&2
    echo " " >&2
    echo "example: $0 PROD 0.1.0 password" >&2
    exit $ERRBADARGS
fi

readonly RELEASE_VERSION="$3"
readonly PASSPHRASE="$4"
readonly RELEASE_FILE_NAME="aerofs-${RELEASE_VERSION}-${LOWERCASE_MODE}"

# FIXME (AG) : the linux tgz and deb can both be built locally on OSX

###############################################################################
#
# Uploads the release files on the local machine to the release server.
#
###############################################################################
function upload_release_files_to_release_server() {
    echo ">> uploading release resources to server"

    local local_TEMP_RELEASE_ZIP_FILENAME="$( mktemp -t aerofs_temp_zip_XXXXXX )".zip
    trap "rm $local_TEMP_RELEASE_ZIP_FILENAME" EXIT

    # Create the zip
    pushd "$LOCAL_RELEASE_DIR" > /dev/null
    zip -9rqy "$local_TEMP_RELEASE_ZIP_FILENAME" {aerofs,aerofs.osx,aerofs.win,aerofs.linux32,aerofs.linux64,aerofs.linux,aerofs.linux.inst}
    popd > /dev/null

    # Copy the zip to the release server
    kscp "$local_TEMP_RELEASE_ZIP_FILENAME" $RELEASE_SERVER_LOGIN:"${RELEASE_FILES_DIR}/${RELEASE_FILE_NAME}".zip

    # Unzip the files on the server into RELEASE_UNPACK_DIR
    # NOTE: Instead of using rsync to get these files to the release server,
    # we zip then unzip because the Windows patch script requires a history of
    # zip files on the server to process diffs.
    # NOTE (GS): We no longer do patch updates on Windows, so this isn't required
    # anymore. We may switch to rsync.
    kssh $RELEASE_SERVER_LOGIN $RELEASE_SERVER_SHELL << ENDCMDS
        rm -r "$RELEASE_UNPACK_DIR" 2> /dev/null || true
        mkdir -p "$RELEASE_UNPACK_DIR"
        unzip -qo -d "$RELEASE_UNPACK_DIR" "${RELEASE_FILES_DIR}/${RELEASE_FILE_NAME}".zip
ENDCMDS
}

###############################################################################
#
# Uploads the local map file to the map server with a versioned name.
#
###############################################################################
function upload_map_file_to_map_server() {
    echo ">> uploading ProGuard map to map server"

    kscp "${LOCAL_RELEASE_DIR}/aerofs.map" $MAP_SERVER_LOGIN:"${MAP_FILES_DIR}/${RELEASE_FILE_NAME}.map"
    scp "${LOCAL_RELEASE_DIR}/aerofs.map" $ROCKLOG_SERVER:"${MAP_FILES_DIR}/${RELEASE_FILE_NAME}.map"
}

###############################################################################
#
# Creates a folder for this release version on the release server.
#
###############################################################################
function create_versioned_installer_directory_on_release_server() {
    echo ">> creating directory for installers"

    kssh $RELEASE_SERVER_LOGIN $RELEASE_SERVER_SHELL << ENDCMDS
        mkdir -p "${INSTALLERS_DOWNLOAD_DIR}/${RELEASE_VERSION}"
ENDCMDS
}

###############################################################################
#
# Uploads the make_deb script and builds a debian package on the release server.
#
###############################################################################
function make_linux_installer_deb_on_release_server() {
    echo ">> make arch independent installer deb on release server"

    # FIXME (AG): I don't want to have to kscp make_deb to the remote machine
    kscp "${BUILD_SCRIPT_DIR}"/make_deb $RELEASE_SERVER_LOGIN:~/
    kssh $RELEASE_SERVER_LOGIN $RELEASE_SERVER_SHELL << ENDCMDS
        sed -i"" -e "s/\[AEROFS_PRODUCT_SPACEFREE\]/${AEROFS_PRODUCT_SPACEFREE}/g" ~/make_deb
        sed -i"" -e "s/\[AEROFS_PRODUCT\]/${AEROFS_PRODUCT}/g" ~/make_deb
        sed -i"" -e "s/\[AEROFS_PRODUCT_UNIX\]/${AEROFS_PRODUCT_UNIX}/g" ~/make_deb
        chmod a+x ~/make_deb
        ~/make_deb $MODE $RELEASE_VERSION "$RELEASE_UNPACK_DIR" "${INSTALLERS_DOWNLOAD_DIR}/${RELEASE_VERSION}/${AEROFS_PRODUCT_UNIX}-installer.deb"
ENDCMDS
}

###############################################################################
#
# Tars and gzips the aerofs resources and moves them to the download directory
# on the release server.
#
###############################################################################
function make_linux_installer_tgz_on_release_server() {
    echo ">> make arch independent installer tgz on release server"

    # Any variables that are defined within the remote shell are referenced via \$ to make sure
    # the variables aren't substituted in the local shell
    local local_LINUX_INSTALLER_TGZ_FILENAME=${AEROFS_PRODUCT_UNIX}-installer.tgz
    kssh $RELEASE_SERVER_LOGIN $RELEASE_SERVER_SHELL << ENDCMDS
        readonly INSTALLER_TGZ_TEMP_DIR="\$( mktemp -d -t temp_tgz_XXXXXX )"
        trap "rm -r \$INSTALLER_TGZ_TEMP_DIR" EXIT

        mkdir -p "\${INSTALLER_TGZ_TEMP_DIR}/aerofs"
        cp -rf "${RELEASE_UNPACK_DIR}/aerofs.linux.inst"/* "\${INSTALLER_TGZ_TEMP_DIR}/aerofs/"
        tar -C "\$INSTALLER_TGZ_TEMP_DIR" -zcf "\${INSTALLER_TGZ_TEMP_DIR}/${local_LINUX_INSTALLER_TGZ_FILENAME}" aerofs
        cp "\${INSTALLER_TGZ_TEMP_DIR}/${local_LINUX_INSTALLER_TGZ_FILENAME}" "${INSTALLERS_DOWNLOAD_DIR}/${RELEASE_VERSION}/"
ENDCMDS
}

###############################################################################
#
# Tars and gzips aerofs resources based on their architecture (32 bit/64 bit)
# and moves them to the download directory on the release server.
#
# @param $1 32|64 (all other values treated as errors)
#
# example:
#   make_linux_arch_dependent_tgz_on_release_server 32
#
###############################################################################
function make_linux_arch_dependent_tgz_on_release_server() {
    if [[ "x$1" != "x32" && "x$1" != "x64" ]]; then
        echo "error: unsupported bits:$1" >&2
        echo "usage: make_linux_arch_dependent_tgz_on_release_server [32|64]" >&2
        exit $ERRBADARGS
    fi

    local local_BITS="$1"
    local local_TGZ_SUFFIX=""
    case "$local_BITS" in
    "32")
        local_TGZ_SUFFIX="x86"
        ;;
    "64")
        local_TGZ_SUFFIX="x86_64"
        ;;
    *)
        echo "error: unsupported bits:$local_BITS" >&2
        ;;
    esac

    echo ">> make arch dependent tgz (${local_BITS}-bit) on release server"

    local local_VERSIONED_ARCH_TGZ_FILENAME=${AEROFS_PRODUCT_UNIX}-${RELEASE_VERSION}-${local_TGZ_SUFFIX}.tgz
    local local_UNVERSIONED_ARCH_TGZ_FILENAME=${AEROFS_PRODUCT_UNIX}-${local_TGZ_SUFFIX}.tgz

    # Any variables that are defined within the remote shell are referenced via \$ to make sure
    # the variables aren't substituted in the local shell
    kssh $RELEASE_SERVER_LOGIN $RELEASE_SERVER_SHELL << ENDCMDS
        readonly ARCH_TGZ_TEMP_DIR="\$( mktemp -d -t temp_arch_tgz_XXXXXX )"
        trap "rm -r \$ARCH_TGZ_TEMP_DIR" EXIT

        mkdir -p "\${ARCH_TGZ_TEMP_DIR}/aerofs"
        cp -rf "${RELEASE_UNPACK_DIR}/aerofs"/* "\${ARCH_TGZ_TEMP_DIR}/aerofs"
        cp -rf "${RELEASE_UNPACK_DIR}/aerofs.linux"/* "\${ARCH_TGZ_TEMP_DIR}/aerofs"
        cp -rf "${RELEASE_UNPACK_DIR}/aerofs.linux${local_BITS}"/* "\${ARCH_TGZ_TEMP_DIR}/aerofs"
        tar -C "\${ARCH_TGZ_TEMP_DIR}" -zcf "\${ARCH_TGZ_TEMP_DIR}/${local_VERSIONED_ARCH_TGZ_FILENAME}" aerofs
        cp -rf "\${ARCH_TGZ_TEMP_DIR}/${local_VERSIONED_ARCH_TGZ_FILENAME}" "${INSTALLERS_DOWNLOAD_DIR}/${RELEASE_VERSION}/"
        cp -rf "\${ARCH_TGZ_TEMP_DIR}/${local_VERSIONED_ARCH_TGZ_FILENAME}" "${INSTALLERS_DOWNLOAD_DIR}/${RELEASE_VERSION}/${local_UNVERSIONED_ARCH_TGZ_FILENAME}"
ENDCMDS
}

###############################################################################
#
# Creates all the linux installer variants
#
###############################################################################
function make_linux_installers() {
    make_linux_installer_deb_on_release_server
    make_linux_installer_tgz_on_release_server
    make_linux_arch_dependent_tgz_on_release_server 32
    make_linux_arch_dependent_tgz_on_release_server 64
}

###############################################################################
#
# Creates the Windows installer on the release server and moves it to the
# download directory. Uploads installer to Kaspersky when deploying PROD mode.
#
###############################################################################
function make_windows_installers() {
    echo ">> make windows installer on release server"

    local local_VERSIONED_INSTALLER_DIR="${INSTALLERS_DOWNLOAD_DIR}/${RELEASE_VERSION}"
    readonly local_VERSIONED_INSTALLER_DIR
    local local_OUT_FILE="${local_VERSIONED_INSTALLER_DIR}/${AEROFS_PRODUCT_SPACEFREE}Install-${RELEASE_VERSION}.exe"
    readonly local_OUT_FILE
    local local_OUT_FILE_VERSIONFREE="${local_VERSIONED_INSTALLER_DIR}/${AEROFS_PRODUCT_SPACEFREE}Install.exe"
    readonly local_OUT_FILE_VERSIONFREE
    local local_EXECUTABLE="${AEROFS_PRODUCT_UNIX}.exe"

    # deploy NSIS scripts
    rsync --archive --compress --rsh kssh "${LOCAL_NSIS_DIR}/" $RELEASE_SERVER_LOGIN:"$RELEASE_NSIS_DIR"

    # now make the installer
    kssh $RELEASE_SERVER_LOGIN $RELEASE_SERVER_SHELL << ENDCMDS

        # Temporary function to exist only in this ssh session
        # This function is used to sign exe files and dll's
        function sign_exe() {
            FILENAME="\$1"

            export PASSPHRASE="$PASSPHRASE"

            printenv PASSPHRASE | signcode -spc ~/.certs/cert.spc -v ~/.certs/privateKey.pvk \
                -a sha1 -$ commercial -t http://timestamp.verisign.com/scripts/timestamp.dll \
                -tr 10 -n "AeroFS" -i "http://www.aerofs.com" "\${FILENAME}" > /dev/null

            rm -f "\${FILENAME}.bak"
        }

        # Create a temporary directory to work in
        NSIS_TEMP_DIR="\$( mktemp -d -t nsis.XXXXXXXX )"

        # Create a subfolder in that directory with the version number
        # Note: we prepend v_ to the version number to make it easy for the NSIS installer
        # to enumerate and delete all previous versions directories
        NSIS_TEMP_DIR_WITH_VERSION="\${NSIS_TEMP_DIR}/v_${RELEASE_VERSION}"
        mkdir "\${NSIS_TEMP_DIR_WITH_VERSION}"

        # Copy the aerofs release files in that directory
        cp -r "${RELEASE_UNPACK_DIR}/aerofs"/* "\${NSIS_TEMP_DIR_WITH_VERSION}/"
        cp -r "${RELEASE_UNPACK_DIR}/aerofs.win"/* "\${NSIS_TEMP_DIR_WITH_VERSION}/"

        # Move the things that need to stay at the top-level folder
        # Also rename aerofs.exe to the appropriate name
        mv "\${NSIS_TEMP_DIR_WITH_VERSION}/aerofs.exe" "\${NSIS_TEMP_DIR}/$local_EXECUTABLE"
        mv "\${NSIS_TEMP_DIR_WITH_VERSION}/aerofsd.exe" "\${NSIS_TEMP_DIR}/"
        echo -n "${RELEASE_VERSION}" > "\${NSIS_TEMP_DIR}/version"
        mkdir "\${NSIS_TEMP_DIR}/icons"
        mv "\${NSIS_TEMP_DIR_WITH_VERSION}/icons"/*.ico "\${NSIS_TEMP_DIR}/icons"

        chmod -R a+rx "\${NSIS_TEMP_DIR}"

        sign_exe "\${NSIS_TEMP_DIR}/$local_EXECUTABLE"
        sign_exe "\${NSIS_TEMP_DIR}/aerofsd.exe"

        makensis -V1 -DAEROFS_IN_FOLDER="\${NSIS_TEMP_DIR}" \
                -DAEROFS_OUT_FILE="$local_OUT_FILE" \
                -DAEROFS_VERSION="$RELEASE_VERSION" \
                -DAEROFS_PRODUCT="$AEROFS_PRODUCT" \
                -DAEROFS_APPROOT="${AEROFS_PRODUCT_SPACEFREE}Exec" \
                -DAEROFS_EXECUTABLE="$local_EXECUTABLE" \
                "${RELEASE_NSIS_DIR}/setup.nsi"

        sign_exe "$local_OUT_FILE"
        cp -r "$local_OUT_FILE" "$local_OUT_FILE_VERSIONFREE"

        # Kaspersky requires us to upload the entire unpacked contents of aerofs into their servers
        # we also upload the install file for whitelisting, as some versions of the antivirus flag the
        # installer as a potential virus
        if [ "$MODE" == "PROD" ]; then
            LFTPSCRIPT="\$( mktemp -t lftp.XXXX )"
            cat << LFTPCMDS >> \${LFTPSCRIPT}
trap "rm \"\$LFTPSCRIPT\"" EXIT
trap "rm -r \"\$NSIS_TEMP_DIR\"" EXIT
lftp -e "mirror -R \${NSIS_TEMP_DIR}/ /aerofs/; bye" -u \`cat ~/.lftp/login.cfg\` whitelist1.kaspersky-labs.com
lftp -e 'put ${local_OUT_FILE_VERSIONFREE}; bye' -u \`cat ~/.lftp/login.cfg\` whitelist1.kaspersky-labs.com
LFTPCMDS
            chmod +x \${LFTPSCRIPT}
            screen -d -m \${LFTPSCRIPT}
        fi

ENDCMDS
}

###############################################################################
#
# Creates the Mac OS X DMG and Zip file and uploads it to the release server.
# Signs the App if deployment mode is PROD
#
###############################################################################
function make_osx_installers() {
    echo ">> make mac osx dmg and zip"

    local local_VERSIONED_MAC_ZIP_FILENAME="${AEROFS_PRODUCT_UNIX}-osx-${RELEASE_VERSION}.zip"
    local local_VERSIONED_MAC_DMG_FILENAME="${AEROFS_PRODUCT_SPACEFREE}Install-${RELEASE_VERSION}.dmg"
    local local_UNVERSIONED_MAC_DMG_FILENAME="${AEROFS_PRODUCT_SPACEFREE}Install.dmg"
    local local_OSX_LOCAL_MAC_APP_DIR=Release/${AEROFS_PRODUCT_SPACEFREE}.app/Contents/Resources/Java
    local local_OSX_INSTALLER_VOLUME_DIR="/Volumes/${AEROFS_PRODUCT_SPACEFREE} Installer"
    local local_OSX_TEMPLATE_APP_FILENAME="osx/${AEROFS_PRODUCT_UNIX}.app.template"
    local local_OSX_TEMPLATE_DMG_FILENAME="osx/${AEROFS_PRODUCT_UNIX}.dmg.template"

    readonly local_VERSIONED_MAC_ZIP_FILENAME
    readonly local_VERSIONED_MAC_DMG_FILENAME
    readonly local_UNVERSIONED_MAC_DMG_FILENAME
    readonly local_OSX_LOCAL_MAC_APP_DIR
    readonly local_OSX_INSTALLER_VOLUME_DIR
    readonly local_OSX_TEMPLATE_APP_FILENAME
    readonly local_OSX_TEMPLATE_DMG_FILENAME

    # Create a temporary directory to work in
    local local_DMG_TEMP_DIR="$( mktemp -d -t dmg )"
    trap "rm -r \"$local_DMG_TEMP_DIR\"" EXIT

    # Create a release folder within the temp directory and copy the template dmg and app folder
    mkdir "${local_DMG_TEMP_DIR}/Release"
    cp -R "${BUILD_SCRIPT_DIR}/${local_OSX_TEMPLATE_APP_FILENAME}" \
        "${local_DMG_TEMP_DIR}/Release/${AEROFS_PRODUCT_SPACEFREE}.app"
    cp "${BUILD_SCRIPT_DIR}/${local_OSX_TEMPLATE_DMG_FILENAME}" \
        "${local_DMG_TEMP_DIR}/${AEROFS_PRODUCT_SPACEFREE}Install-temp.dmg"

    # Copy the aerofs and aerofs.osx files into the Mac App directory within the temp directory created above
    cp -r "${AEROFS_RELEASE_DIR}"/* "${AEROFS_RELEASE_OSX_DIR}"/* "${local_DMG_TEMP_DIR}/${local_OSX_LOCAL_MAC_APP_DIR}/"

    if is_prod ; then
        echo ">> sign app for Mac App Store"
        # see http://developer.apple.com/library/mac/technotes/tn2206/_index.html#//apple_ref/doc/uid/DTS40007919-CH1-SUBSECTION9
        # for information on signing frameworks
        # Note: We avoid re-codesigning AeroFSFinderExtension because every
        # time we do so, it changes the binary, which in turn changes the
        # checksum, so we kill finder on update.  Instead, we have pre-signed
        # the checked-in resource, and must update the signature whenever we
        # modify anything under the .osax folder.
        #codesign -f -s "Air Computing, Inc." "${local_DMG_TEMP_DIR}/Release/${AEROFS_PRODUCT_SPACEFREE}.app/Contents/Resources/Java/AeroFSFinderExtension.osax"
        codesign -f -s "Air Computing, Inc." "${local_DMG_TEMP_DIR}/Release/${AEROFS_PRODUCT_SPACEFREE}.app/Contents/Resources/Java/Growl.framework/Versions/A"
        codesign -f -s "Air Computing, Inc." "${local_DMG_TEMP_DIR}/Release/${AEROFS_PRODUCT_SPACEFREE}.app"
    fi

    # zip the osx client (must go to the directory so that the temp path isn't included in the zip)
    pushd "$local_DMG_TEMP_DIR" > /dev/null
    zip -9rq "$local_VERSIONED_MAC_ZIP_FILENAME" "Release/"
    popd > /dev/null

    hdiutil mount -quiet "${local_DMG_TEMP_DIR}/${AEROFS_PRODUCT_SPACEFREE}Install-temp.dmg"
    rm -rf "${local_OSX_INSTALLER_VOLUME_DIR}/${AEROFS_PRODUCT_SPACEFREE}.app"
    cp -R "${local_DMG_TEMP_DIR}/Release/${AEROFS_PRODUCT_SPACEFREE}.app" "${local_OSX_INSTALLER_VOLUME_DIR}"
    hdiutil eject -quiet "${local_OSX_INSTALLER_VOLUME_DIR}"
    hdiutil convert -quiet -format UDBZ -o "${local_DMG_TEMP_DIR}/${local_VERSIONED_MAC_DMG_FILENAME}" "${local_DMG_TEMP_DIR}/${AEROFS_PRODUCT_SPACEFREE}Install-temp.dmg"

    echo ">> upload mac os x release zip and dmg to release server"
    kscp "${local_DMG_TEMP_DIR}/${local_VERSIONED_MAC_ZIP_FILENAME}" $RELEASE_SERVER_LOGIN:"${INSTALLERS_DOWNLOAD_DIR}/${RELEASE_VERSION}"
    kscp "${local_DMG_TEMP_DIR}/${local_VERSIONED_MAC_DMG_FILENAME}" $RELEASE_SERVER_LOGIN:"${INSTALLERS_DOWNLOAD_DIR}/${RELEASE_VERSION}"
    kssh $RELEASE_SERVER_LOGIN $RELEASE_SERVER_SHELL << ENDCMDS
        cd "${INSTALLERS_DOWNLOAD_DIR}/${RELEASE_VERSION}"
        cp "$local_VERSIONED_MAC_DMG_FILENAME" "$local_UNVERSIONED_MAC_DMG_FILENAME"
ENDCMDS
}

###############################################################################
#
# Creates the current.ver file in the release folder to specify the version of
# the release to clients when this release is published. This file's presence
# also marks the packaging process as complete.
# This file should be checked by the publisher to ensure that this release is ready.
#
###############################################################################
function create_release_version_file_on_server() {
    echo ">> create current.ver for this release"

    local local_VERSION_FILE="${INSTALLERS_DOWNLOAD_DIR}/${RELEASE_VERSION}/${RELEASE_SERVER_VERSION_FILE}"
    kssh $RELEASE_SERVER_LOGIN $RELEASE_SERVER_SHELL << ENDCMDS
        echo Version=$RELEASE_VERSION > "$local_VERSION_FILE"
        chmod a+r "$local_VERSION_FILE"
ENDCMDS
}

#****************************************
#****************************************
#**
#** Run the actual installer build steps
#**
#****************************************
#****************************************
echo ">> make client installers and packages on release server"

compute_product_names
upload_release_files_to_release_server
upload_map_file_to_map_server
create_versioned_installer_directory_on_release_server
make_linux_installers
make_windows_installers
make_osx_installers
create_release_version_file_on_server

exit 0
