#!/bin/bash
set -e -u

###############################################################################
#
# General includes
#
###############################################################################
include include/common ${1:-}

###############################################################################
#
# usage and parameters
#
###############################################################################
if [[ $# -ne 1 ]]; then
    echo "usage: $0 [build mode]" >&2
    echo " " >&2
    echo "[build mode]: PUBLIC|PRIVATE" >&2
    echo " " >&2
    echo "example: $0 PUBLIC" >&2
    exit $ERRBADARGS
fi

# single-quoted - we want $HOME expanded serverside
DEPLOY_LOCKFILE='$HOME/deploy.lock'

# The version file should have been produced by the packaging scripts.
VERSION_FILE="$PACKAGE_DIR/$CURRENT_VER"
if [[ ! -r "$VERSION_FILE" ]]; then
    echo "Expected to find a version file at $VERSION_FILE but I couldn't read the version number"
    exit $ERRBADVERSION
fi
RELEASE_VERSION=$(cat "$VERSION_FILE" | cut -d = -f 2)
# Check that the version string has the right format.
if [[ ! $RELEASE_VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    echo "Expected version string matching <major>.<minor>.<build>, got '$RELEASE_VERSION'"
    exit $ERRBADVERSION
fi

function lock_release_server() {
    echo "establishing deploy lock..."
    kssh $RELEASE_SERVER_LOGIN $RELEASE_SERVER_SHELL << ENDCMDS
        if [ -f $DEPLOY_LOCKFILE ] ; then
            echo "A deploy appears to be in progress already:"
            cat $DEPLOY_LOCKFILE
            echo "If you're sure that deploy has indeed been terminated:"
            echo "    ssh $RELEASE_SERVER_LOGIN rm $DEPLOY_LOCKFILE"
            exit 1
        fi
        lockfile-create --retry 1 --lock-name $DEPLOY_LOCKFILE && echo "Deploy started by $USER at:" >> $DEPLOY_LOCKFILE && date >> $DEPLOY_LOCKFILE && echo "for version $RELEASE_VERSION" >> $DEPLOY_LOCKFILE
ENDCMDS
    echo "locked $RELEASE_SERVER for deploy"
}

function unlock_release_server() {
    echo "releasing deploy lock..."
    kssh $RELEASE_SERVER_LOGIN "rm -f $DEPLOY_LOCKFILE"
    echo "done"
}

# Uploads proguard map file to the servers that need it.
function upload_map() {
    declare MAP_FILE_NAME="aerofs-${RELEASE_VERSION}-${LOWERCASE_MODE}.map"
    echo "uploading proguard map file to $MAP_SERVER..."
    scp "${LOCAL_RELEASE_DIR}/aerofs.map" $MAP_SERVER_LOGIN:"${MAP_FILES_DIR}/${MAP_FILE_NAME}"
    echo "uploading proguard map file to $ROCKLOG_SERVER"
    scp "${LOCAL_RELEASE_DIR}/aerofs.map" $ROCKLOG_SERVER:"${MAP_FILES_DIR}/${MAP_FILE_NAME}"
}

function upload_packages_to_release_server() {
    # Upload the immutable artifacts (versioned installers) first, so
    # incrementing the version moves atomically between consistent states
    echo ">>> rsyncing packages to $RELEASE_SERVER:$INSTALLERS_DOWNLOAD_DIR/$RELEASE_VERSION/"
    rsync --archive --verbose "$PACKAGE_DIR"/* $RELEASE_SERVER_LOGIN:$INSTALLERS_DOWNLOAD_DIR/$RELEASE_VERSION/
    echo ">>> rsyncing version to $RELEASE_SERVER:$INSTALLERS_DOWNLOAD_DIR/release-versions/$CANARY_VER"
    rsync --archive --verbose "$PACKAGE_DIR"/$CURRENT_VER $RELEASE_SERVER_LOGIN:$INSTALLERS_DOWNLOAD_DIR/release-versions/$CANARY_VER
}

function upload_packages_to_antivirus_firms() {
    # Upload latest version of script
    kscp $BUILD_SCRIPT_DIR/send_package_to_antivirus_firms.sh $RELEASE_SERVER_LOGIN:
    # Spawn script in background - script will delete self on completion.
    kssh $RELEASE_SERVER_LOGIN $RELEASE_SERVER_SHELL << ENDCMDS
        chmod a+x \$HOME/send_package_to_antivirus_firms.sh
        screen -d -m \$HOME/send_package_to_antivirus_firms.sh $INSTALLERS_DOWNLOAD_DIR/$RELEASE_VERSION/AeroFSInstall-$RELEASE_VERSION.exe
ENDCMDS
}

# Using the version files in $PREFIX/release-versions/,
# copy exactly the set of things that should exist on S3 into deploy-stage
# and then use s3cmd to sync them to the bucket
function publish_public_to_s3() {
    declare DEPLOY_STAGE=$INSTALLERS_DOWNLOAD_DIR/deploy-stage/
    ssh $RELEASE_SERVER_LOGIN $RELEASE_SERVER_SHELL << ENDCMDS
        rm -rf $DEPLOY_STAGE
        mkdir -p $DEPLOY_STAGE
        for version_file in $INSTALLERS_DOWNLOAD_DIR/release-versions/* ; do
            foldername=\$(cat \$version_file | cut -d = -f 2)
            cp -av $INSTALLERS_DOWNLOAD_DIR/\$foldername/* $DEPLOY_STAGE/
        done
        # Copy versions in last, since the versioned client folders may have
        # current.ver and canary.ver files inside
        for version_file in $INSTALLERS_DOWNLOAD_DIR/release-versions/* ; do
            cp \$version_file $DEPLOY_STAGE/
        done
        s3cmd --follow-symlinks --acl-public --delete-removed --cf-invalidate sync "$DEPLOY_STAGE"/* $1
ENDCMDS
}

###############################################################################
#
# Synchronizes a release directory on the release server with an S3 bucket and
# invalidates the CloudFront cache.
#
# The release directory must contain the AeroFS installers for all platforms
# and a version file specifying the version of the release.
#
# NOTE: to rollback a production release to version 1.2.3 for any reason:
#       - log into release-prod@b.arrowfs.org
#       - echo Version=1.2.3 > current.ver
#       - s3cmd sync --acl-public --cf-invalidate current.ver s3://nocache.client.aerofs.com
#
# @param $1 The version to publish
# @param $2 The S3 bucket to which the release version will be pushed
#
###############################################################################
function publish_private_version_file_to_s3() {
    echo ">> publishing to s3 bucket ${2}"

    local local_DIR="${INSTALLERS_DOWNLOAD_DIR}/${1}"

    kssh $RELEASE_SERVER_LOGIN $RELEASE_SERVER_SHELL << ENDCMDS
        # Check to see that a version file exists in the specified version directory and is
        # non-empty.
        if [ ! -s "${INSTALLERS_DOWNLOAD_DIR}/${1}/${CURRENT_VER}" ]; then
            exit $ERRS3
        fi

        s3cmd --follow-symlinks --acl-public --delete-removed \$EXTRA_OPTS sync "${local_DIR}"/* $2
ENDCMDS
}

# Emails team@aerofs.com about this deployment and sends message to Dev Team
# channel on Hipchat.
function notify_successful_deployment() {
    echo ">> notifying team of successful deployment via email"
    kssh $RELEASE_SERVER_LOGIN $RELEASE_SERVER_SHELL << ENDCMDS
        echo ' ' | mail -s "[$MODE] $RELEASE_VERSION deployed by $USER" team@aerofs.com
ENDCMDS
    echo ">> notifying team of successful deployment via HipChat"
    echo "$(whoami) pushed $MODE $RELEASE_VERSION" |
        $(git rev-parse --show-cdup)puppetmaster/modules/hipchat/files/hipchat_room_message -c green -t 6124360a8cd9355ff9b9927b51cea4 -r 93246 -f "Deploy" > /dev/null
}

# Tags this release with an annotated tag so it is easy to checkout a deployed
# build for debugging.
function tag_release() {
    if is_public ; then
        echo ">> tagging git release"
        git tag -a "public-$RELEASE_VERSION" -m "public-$RELEASE_VERSION"
        git push --tags
    fi

    if is_private ; then
        echo ">> tagging git release"
        git tag -a "private-$RELEASE_VERSION" -m "private-$RELEASE_VERSION"
        git push --tags
    fi
}

# main: Run all of the deployment steps
if is_public ; then
    echo
    echo "!!!!!!!!!!!!!!!!!!!!!!!"
    echo "!! DEPLOY PRODUCTION !!"
    echo "!!!!!!!!!!!!!!!!!!!!!!!"
    echo
fi

echo '+--------------------------'
echo '| ' $RELEASE_VERSION $MODE
echo '+--------------------------'

upload_map
call exec_prepublish_checks $MODE $RELEASE_VERSION
lock_release_server
if is_public ; then
    upload_packages_to_release_server
    upload_packages_to_antivirus_firms
    publish_public_to_s3 $INSTALLER_DOWNLOAD_BUCKET
else
    # PRIVATE only deploys just a single current.ver
    publish_private_version_file_to_s3 $RELEASE_VERSION $INSTALLER_DOWNLOAD_BUCKET
fi
unlock_release_server
tag_release
notify_successful_deployment

echo ">> successfully deployed $MODE release version $RELEASE_VERSION"
exit 0
