#!/bin/bash -e -u

###############################################################################
#
# This include file contains all important constants for use with building
# and uploading release files to the release server.
#
# This file should be included with the following syntax:
#
# include include/common $MODE $PRODUCT
#
###############################################################################

# Similar to an ifndef in the C preprocessor. Only includes the contents of this
# file if they weren't imported before.
if [ x"${__COMMON_INCLUDE__:-}" == x ] ; then readonly __COMMON_INCLUDE__=true

###############################################################################
#
# Error codes
#
###############################################################################
readonly ERRNOINTERNET=16
readonly ERRBADARGS=17
readonly ERRBADMODE=18
readonly ERRBADPASS=19
readonly ERRS3=20
readonly ERRBADPRODUCT=21

###############################################################################
#
# Local path constants
#
###############################################################################
GIT_ROOT="$(git rev-parse --show-cdup)"
if [ -z "$GIT_ROOT" ]; then
    GIT_ROOT="."
fi
readonly GIT_ROOT="$(cd "$GIT_ROOT" && pwd)"
readonly TOOLS_ROOT="${GIT_ROOT}/tools"
readonly BUILD_SCRIPT_DIR="${TOOLS_ROOT}/build"
readonly PROGUARD_HOME="${TOOLS_ROOT}/proguard"
readonly LOCAL_NSIS_DIR="${TOOLS_ROOT}/win_installer"

# Local resources directories
readonly BASE_RESOURCES_DIR="${GIT_ROOT}/resource"
readonly COMMON_RESOURCES_DIR="${BASE_RESOURCES_DIR}/common"
readonly MODE_RESOURCES_DIR="${COMMON_RESOURCES_DIR}/mode"
readonly LABELING_RESOURCES_DIR="${COMMON_RESOURCES_DIR}/labeling"
readonly OTHER_RESOURCES_DIR="${COMMON_RESOURCES_DIR}/other"
readonly CLIENT_RESOURCES_DIR="${BASE_RESOURCES_DIR}/client"
readonly CLIENT_ALL_PLATFORMS_RESOURCES_DIR="${CLIENT_RESOURCES_DIR}/all"
readonly CLIENT_LINUX_COMMON_RESOURCES_DIR="${CLIENT_RESOURCES_DIR}/linux"
readonly CLIENT_LINUX32_RESOURCES_DIR="${CLIENT_RESOURCES_DIR}/linux32"
readonly CLIENT_LINUX64_RESOURCES_DIR="${CLIENT_RESOURCES_DIR}/linux64"
readonly CLIENT_OSX_RESOURCES_DIR="${CLIENT_RESOURCES_DIR}/osx"
readonly CLIENT_WIN_RESOURCES_DIR="${CLIENT_RESOURCES_DIR}/win"
readonly CLIENT_LINUX_INSTALLER_RESOURCES_DIR="${CLIENT_RESOURCES_DIR}/linux.inst"

# local build directory (where ant will put stuff)
readonly BUILD_OUTPUT_DIR="${GIT_ROOT}/out.ant"

# local root release directory and release dirs for each platform
# avoid putting scratch stuff in any of these directories because they are packaged into the installer
readonly LOCAL_RELEASE_DIR="${BUILD_OUTPUT_DIR}/release"
readonly AEROFS_RELEASE_DIR="${LOCAL_RELEASE_DIR}/aerofs"
readonly AEROFS_RELEASE_WIN_DIR="${LOCAL_RELEASE_DIR}/aerofs.win"
readonly AEROFS_RELEASE_OSX_DIR="${LOCAL_RELEASE_DIR}/aerofs.osx"
readonly AEROFS_RELEASE_LINUX_DIR="${LOCAL_RELEASE_DIR}/aerofs.linux"
readonly AEROFS_RELEASE_LINUX32_DIR="${LOCAL_RELEASE_DIR}/aerofs.linux32"
readonly AEROFS_RELEASE_LINUX64_DIR="${LOCAL_RELEASE_DIR}/aerofs.linux64"
readonly AEROFS_RELEASE_INST_DIR="${LOCAL_RELEASE_DIR}/aerofs.linux.inst"

# Some OSX specific constants
readonly OSX_TEMPLATE_DMG_FILENAME="osx.dmg.template"
readonly OSX_TEMPLATE_APP_FILENAME="osx.app.template"

# Proguard maps server credentials and paths
readonly MAP_SERVER="sv.aerofs.com"
readonly MAP_SERVER_LOGIN=${MAP_SERVER}
readonly ROCKLOG_SERVER="rocklog.aerofs.com"
readonly MAP_FILES_DIR="/maps"

###############################################################################
#
# Constants relating to the product to be built (CLIENT/TEAM_SERVER)
#
###############################################################################

###############################################################################
#
# Returns 0 if the product is one that's recognized, or $ERRBADPRODUCT
# otherwise
#
# Args:
#    1: product to check
#
###############################################################################
function is_valid_product() {
    if [[ "$1" != "CLIENT" && "$1" != "TEAM_SERVER" ]]; then
        return $ERRBADPRODUCT
    fi
    return 0
}

# check that a valid product was specified
readonly PRODUCT="${2:-CLIENT}" # FIXME (AG): This should not be specified in here since deploy doesn't need this
if ! is_valid_product "$PRODUCT" ; then
    echo "error: invalid build product $PRODUCT. Expected CLIENT|TEAM_SERVER." >&2
    exit $ERRBADPRODUCT
fi
readonly LOWERCASE_PRODUCT="$(echo $PRODUCT | tr '[A-Z]' '[a-z]')"
readonly LABELING_FILE="$LABELING_RESOURCES_DIR/labeling-$LOWERCASE_PRODUCT.properties"

###############################################################################
#
# Constants relating to the deploy mode (PROD/CI/STAGING/ENTERPRISE)
#
###############################################################################

###############################################################################
#
# Returns 0 if the deployment mode is one that is recognized, or ERRBADMODE
# otherwise
#
# Args:
#    1: mode to check
#
###############################################################################
function is_valid_mode() {
    if [[ "$1" != "PROD" && "$1" != "STAGING" && "$1" != "ENTERPRISE" ]]; then
        return $ERRBADMODE
    fi
    return 0
}

# check that a valid mode was specified
readonly MODE="${1:-}"
if ! is_valid_mode $MODE ; then
    echo "error: invalid build mode $MODE. Expected PROD|STAGING|ENTERPRISE." >&2
    exit $ERRBADMODE
fi
readonly LOWERCASE_MODE="$(echo $MODE | tr '[A-Z]' '[a-z]')"

###############################################################################
#
# Release server constants
#
###############################################################################

# We use the same user account when deploying to prod/enterprise.
# TODO (MP) use a more reasonable username. Maybe drew's changes to the build will make this better?
case ${LOWERCASE_MODE} in
prod)
    readonly RELEASE_SERVER_USERNAME=release-prod
    ;;
enterprise)
    readonly RELEASE_SERVER_USERNAME=release-prod
    ;;
*)
    readonly RELEASE_SERVER_USERNAME=release-${LOWERCASE_MODE}
    ;;
esac

readonly RELEASE_SERVER="b.arrowfs.org"
readonly RELEASE_SERVER_LOGIN="${RELEASE_SERVER_USERNAME}@${RELEASE_SERVER}"
readonly RELEASE_SERVER_SHELL="bash -s -e -u"

###############################################################################
#
# Release server paths
#
###############################################################################
readonly RELEASE_FILES_DIR="/home/${RELEASE_SERVER_USERNAME}"
readonly RELEASE_UNPACK_DIR="${RELEASE_FILES_DIR}/unpack"
readonly INSTALLERS_DOWNLOAD_DIR="/data/${LOWERCASE_MODE}-downloads"
readonly RELEASE_SERVER_VERSION_FILE="current.ver"
readonly RELEASE_NSIS_DIR="${RELEASE_FILES_DIR}/win_installer"

###############################################################################
#
# Cloudfront/S3 constants
#
###############################################################################
if [ "$MODE" == "PROD" ]; then
    readonly RELEASE_DOMAIN="nocache.client.aerofs.com"
elif [ "$MODE" == "STAGING" ]; then
    readonly RELEASE_DOMAIN="nocache.client.stg.aerofs.com"
elif [ "$MODE" == "ENTERPRISE" ]; then
    # N.B. no need to create a cache/nocache variant for this since the
    # installers are packaged into openstack images anyway.
    readonly RELEASE_DOMAIN="nocache.client.enterprise.aerofs.com"
fi
readonly INSTALLER_DOWNLOAD_BUCKET="s3://${RELEASE_DOMAIN}"
readonly RELEASE_VERSION_URL="https://${RELEASE_DOMAIN}/${RELEASE_SERVER_VERSION_FILE}"
readonly UNSECURED_PASSPHRASE=temp123

###############################################################################
#
# Returns 0 if the product is CLIENT, 1 otherwise
#
###############################################################################
function is_client() {
    if [ "$PRODUCT" == "CLIENT" ]; then
        return 0
    fi
    return 1
}

###############################################################################
#
# Returns 0 if the deployment mode is CI, 1 otherwise
#
###############################################################################
function is_team_server() {
    if [ "$PRODUCT" == "TEAM_SERVER" ]; then
        return 0
    fi
    return 1
}

###############################################################################
#
# Returns 0 if the deployment mode is PROD, 1 otherwise
#
###############################################################################
function is_prod() {
    if [ "$MODE" == "PROD" ]; then
        return 0
    fi
    return 1
}

###############################################################################
#
# Returns 0 if the deployment mode is CI, 1 otherwise
#
###############################################################################
function is_ci() {
    if [ "$MODE" == "CI" ]; then
        return 0
    fi
    return 1
}

###############################################################################
#
# Returns 0 if the deployment mode is STAGING, 1 otherwise
#
###############################################################################
function is_staging() {
    if [ "$MODE" == "STAGING" ]; then
        return 0
    fi
    return 1
}

###############################################################################
#
# Gets the current active version on S3, like "0.4.98"
#
###############################################################################
function current_release_version() {
    local local_CURRENT_RELEASE_VERSION_STRING="$( wget --no-check-certificate --no-cache -q -O- $RELEASE_VERSION_URL )"
    echo "$( echo $local_CURRENT_RELEASE_VERSION_STRING | sed -e 's/.*=//' )"
}

###############################################################################
#
# Checks the current active version on S3 and computes the next logical version.
#
###############################################################################
function compute_next_release_version() {
    local local_CURRENT_RELEASE_VERSION="$( current_release_version $RELEASE_VERSION_URL )"
    if [ "$local_CURRENT_RELEASE_VERSION" == "" ]; then
        echo "error: can't get current release version" >&2
        exit $ERRNOINTERNET
    fi

    local local_CURRENT_RELEASE_VERSION_MAJOR_MINOR="$( echo $local_CURRENT_RELEASE_VERSION | sed -e 's/\.[0-9]*$//' )"
    local local_CURRENT_RELEASE_VERSION_BUILD_NUMBR="$( echo $local_CURRENT_RELEASE_VERSION | sed -e 's/.*\.//' )"
    local local_LOCAL_VERSION_MAJOR_MINOR="$( head -1 ${BUILD_SCRIPT_DIR}/version )"

    readonly local_CURRENT_RELEASE_VERSION_STRING
    readonly local_CURRENT_RELEASE_VERSION
    readonly local_CURRENT_RELEASE_VERSION_MAJOR_MINOR
    readonly local_CURRENT_RELEASE_VERSION_BUILD_NUMBR
    readonly local_LOCAL_VERSION_MAJOR_MINOR

    local local_BUILD_NUMBER=""
    if [ $local_CURRENT_RELEASE_VERSION_MAJOR_MINOR == $local_LOCAL_VERSION_MAJOR_MINOR ]; then  #FIXME (AG): verify they've actually bumped the number
        local_BUILD_NUMBER="$( expr $local_CURRENT_RELEASE_VERSION_BUILD_NUMBR \+ 1 )"
    else
        local_BUILD_NUMBER=1 # reset build number to 1
    fi

    readonly RELEASE_VERSION="$local_LOCAL_VERSION_MAJOR_MINOR.$local_BUILD_NUMBER"
    echo "version: current => [major.minor.build:$local_CURRENT_RELEASE_VERSION] next => [major.minor.build:$RELEASE_VERSION]"
}

######################################################################
#
# Gets the product names from the unobfuscated class files.
#
######################################################################

function compute_product_names() {
    echo ">> computing product name"

    ${BUILD_SCRIPT_DIR}/dynamic-config/dependencies.groovy

    readonly GET_PROPERTY_SCRIPT="groovy -Dlogback.configurationFile=${BUILD_SCRIPT_DIR}/dynamic-config/logback.xml ${BUILD_SCRIPT_DIR}/dynamic-config/get_property.groovy"
    readonly AEROFS_PRODUCT=$($GET_PROPERTY_SCRIPT $LABELING_FILE labeling.product)
    readonly AEROFS_PRODUCT_SPACEFREE=$($GET_PROPERTY_SCRIPT $LABELING_FILE labeling.productSpaceFreeName)
    readonly AEROFS_PRODUCT_UNIX=$($GET_PROPERTY_SCRIPT $LABELING_FILE labeling.productUnixName)
}

###############################################################################
#
# Synchronizes a release directory on the release server with an S3 bucket and
# invalidates the CloudFront cache.
#
# The release directory must contain the AeroFS installers for all platforms
# and a version file specifying the version of the release.
#
# NOTE: to rollback a production release for any reason:
#       - log into release-prod@b.arrowfs.org
#       - s3cmd sync -P --cf-invalidate --delete-removed /data/prod-downloads/[version]/* s3://nocache.client.aerofs.com
#
# @param $1 The version to publish
# @param $2 The S3 bucket to which the release version will be pushed
#
###############################################################################
function publish_to_s3() {
    echo ">> publishing to s3 bucket ${2}"

    kssh $RELEASE_SERVER_LOGIN $RELEASE_SERVER_SHELL << ENDCMDS
        # Check to see that a version file exists in the specified version directory and is
        # non-empty.
        if [ ! -s "${INSTALLERS_DOWNLOAD_DIR}/${1}/${RELEASE_SERVER_VERSION_FILE}" ]; then
            exit $ERRS3
        fi

        s3cmd sync -P --cf-invalidate --delete-removed "${INSTALLERS_DOWNLOAD_DIR}/${1}"/* $2 > /dev/null
ENDCMDS
}

fi # endif
