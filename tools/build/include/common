#!/bin/bash
set -e -u

###############################################################################
#
# This include file contains all important constants for use with building
# and uploading release files to the release server.
#
# This file should be included with the following syntax:
#
# include include/common $MODE $PRODUCT
#
###############################################################################

# Similar to an ifndef in the C preprocessor. Only includes the contents of this
# file if they weren't imported before.
if [ x"${__COMMON_INCLUDE__:-}" == x ] ; then readonly __COMMON_INCLUDE__=true

###############################################################################
#
# Error codes
#
###############################################################################
readonly ERRNOINTERNET=16
readonly ERRBADARGS=17
readonly ERRBADMODE=18
readonly ERRBADPASS=19
readonly ERRS3=20
readonly ERRBADPRODUCT=21
readonly ERRBADVERSION=22
readonly ERRTESTFAIL=23

###############################################################################
#
# Local path constants
#
###############################################################################
GIT_ROOT="$(git rev-parse --show-cdup)"
if [ -z "$GIT_ROOT" ]; then
    GIT_ROOT="."
fi
readonly GIT_ROOT="$(cd "$GIT_ROOT" && pwd)"
readonly TOOLS_ROOT="${GIT_ROOT}/tools"
readonly DAMAGE_PY="${GIT_ROOT}/packaging/repackaging/opt/repackaging/tools/osx/damage.py"
readonly BUILD_SCRIPT_DIR="${TOOLS_ROOT}/build"
readonly PROGUARD_HOME="${TOOLS_ROOT}/proguard"
readonly LOCAL_NSIS_DIR="${TOOLS_ROOT}/win_installer"

# Local resources directories
readonly BASE_RESOURCES_DIR="${GIT_ROOT}/resource"
readonly COMMON_RESOURCES_DIR="${BASE_RESOURCES_DIR}/common"
readonly MODE_RESOURCES_DIR="${COMMON_RESOURCES_DIR}/mode"
readonly OTHER_RESOURCES_DIR="${COMMON_RESOURCES_DIR}/other"
readonly CLIENT_RESOURCES_DIR="${BASE_RESOURCES_DIR}/client"
readonly CLIENT_ALL_PLATFORMS_RESOURCES_DIR="${CLIENT_RESOURCES_DIR}/all"
readonly LABELING_RESOURCES_DIR="${CLIENT_ALL_PLATFORMS_RESOURCES_DIR}/labeling"
readonly CLIENT_LINUX_RESOURCES_DIR="${CLIENT_RESOURCES_DIR}/linux"
readonly CLIENT_LINUX_SHARED_RESOURCES_DIR="${CLIENT_RESOURCES_DIR}/linux/shared"
readonly CLIENT_LINUX32_RESOURCES_DIR="${CLIENT_RESOURCES_DIR}/linux/i386"
readonly CLIENT_LINUX64_RESOURCES_DIR="${CLIENT_RESOURCES_DIR}/linux/amd64"
readonly CLIENT_OSX_RESOURCES_DIR="${CLIENT_RESOURCES_DIR}/osx"
readonly CLIENT_WIN_RESOURCES_DIR="${CLIENT_RESOURCES_DIR}/win"
readonly CLIENT_BASE_SHELLEXT_DIR="${CLIENT_RESOURCES_DIR}/shellext"
readonly CLIENT_OSX_SHELLEXT_DIR="${CLIENT_BASE_SHELLEXT_DIR}/osx"
readonly CLIENT_WIN_SHELLEXT_DIR="${CLIENT_BASE_SHELLEXT_DIR}/win"

# Local resource template directories
readonly BASE_TEMPLATES_DIR="${BASE_RESOURCES_DIR}/templates"
readonly CLIENT_TEMPLATES_DIR="${BASE_TEMPLATES_DIR}/client"
readonly CLIENT_LINUX_TEMPLATES_DIR="${CLIENT_TEMPLATES_DIR}/linux"
readonly CLIENT_OSX_TEMPLATES_DIR="${CLIENT_TEMPLATES_DIR}/osx"
readonly CLIENT_LINUX_SHARED_TEMPLATES_DIR="${CLIENT_LINUX_TEMPLATES_DIR}/shared"

# local build directory (where ant will put stuff)
readonly BUILD_OUTPUT_DIR="${GIT_ROOT}/out.ant"

# local root release directory and release dirs for each platform
# avoid putting scratch stuff in any of these directories because they are packaged into the installer
readonly LOCAL_RELEASE_DIR="${BUILD_OUTPUT_DIR}/release"
readonly AEROFS_RELEASE_DIR="${LOCAL_RELEASE_DIR}/aerofs"
readonly AEROFS_RELEASE_WIN_DIR="${LOCAL_RELEASE_DIR}/aerofs.win"
readonly AEROFS_RELEASE_OSX_DIR="${LOCAL_RELEASE_DIR}/aerofs.osx"
readonly AEROFS_RELEASE_LINUX_DIR="${LOCAL_RELEASE_DIR}/aerofs.linux"
readonly AEROFS_RELEASE_LINUX_SHARED_DIR="${AEROFS_RELEASE_LINUX_DIR}/shared"
readonly AEROFS_RELEASE_LINUX_I386_DIR="${AEROFS_RELEASE_LINUX_DIR}/i386"
readonly AEROFS_RELEASE_LINUX_AMD64_DIR="${AEROFS_RELEASE_LINUX_DIR}/amd64"

# Package temp folder
readonly PACKAGE_BUILD_DIR="$LOCAL_RELEASE_DIR/expandedpackages"
# Package output folder (final deployable artifacts go here)
readonly PACKAGE_DIR="$BUILD_OUTPUT_DIR/packages"

# Some OSX specific constants
readonly OSX_TEMPLATE_DMG_FILENAME="osx.dmg.template"
readonly OSX_TEMPLATE_APP_FILENAME="osx.app.template"

# Proguard maps server credentials and paths
readonly MAP_SERVER="sv.aerofs.com"
readonly MAP_SERVER_LOGIN=${MAP_SERVER}
readonly ROCKLOG_SERVER="rocklog.aerofs.com"
readonly MAP_FILES_DIR="/maps"

###############################################################################
#
# Constants relating to the product to be built (CLIENT/TEAM_SERVER)
#
###############################################################################

###############################################################################
#
# Returns 0 if the product is one that's recognized, or $ERRBADPRODUCT
# otherwise
#
# Args:
#    1: product to check
#
###############################################################################
function is_valid_product() {
    if [[ "$1" != "CLIENT" && "$1" != "TEAM_SERVER" ]]; then
        return $ERRBADPRODUCT
    fi
    return 0
}

# check that a valid product was specified
readonly PRODUCT="${2:-CLIENT}" # FIXME (AG): This should not be specified in here since deploy doesn't need this
if ! is_valid_product "$PRODUCT" ; then
    echo "error: invalid build product $PRODUCT. Expected CLIENT|TEAM_SERVER." >&2
    exit $ERRBADPRODUCT
fi
readonly LOWERCASE_PRODUCT="$(echo $PRODUCT | tr '[A-Z]' '[a-z]')"
readonly LABELING_FILE="$LABELING_RESOURCES_DIR/labeling-$LOWERCASE_PRODUCT.properties"

###############################################################################
#
# Constants relating to the deploy mode (PUBLIC|PRIVATE|CI)
#
###############################################################################

###############################################################################
#
# Returns 0 if the deployment mode is one that is recognized, or ERRBADMODE
# otherwise
#
# Args:
#    1: mode to check
#
###############################################################################
function is_valid_mode() {
    if [[ "$1" != "PUBLIC" && "$1" != "PRIVATE" ]]; then
        return $ERRBADMODE
    fi
    return 0
}

# check that a valid mode was specified
readonly MODE="${1:-}"
if ! is_valid_mode $MODE ; then
    echo "error: invalid build mode $MODE. Expected PUBLIC|PRIVATE." >&2
    exit $ERRBADMODE
fi
readonly LOWERCASE_MODE="$(echo $MODE | tr '[A-Z]' '[a-z]')"

###############################################################################
#
# Release server constants
#
###############################################################################

# We use the same user account when deploying to public/private.
# TODO (MP) use a more reasonable username.
case ${LOWERCASE_MODE} in
public)
    readonly RELEASE_SERVER_USERNAME=release-prod
    ;;
private)
    readonly RELEASE_SERVER_USERNAME=release-prod
    ;;
*)
    readonly RELEASE_SERVER_USERNAME=release-${LOWERCASE_MODE}
    ;;
esac

readonly RELEASE_SERVER="b.arrowfs.org"
readonly RELEASE_SERVER_LOGIN="${RELEASE_SERVER_USERNAME}@${RELEASE_SERVER}"
readonly RELEASE_SERVER_SHELL="bash -s -e -u"

###############################################################################
#
# Release server paths
#
###############################################################################
readonly RELEASE_FILES_DIR="/home/${RELEASE_SERVER_USERNAME}"
readonly RELEASE_UNPACK_DIR="${RELEASE_FILES_DIR}/unpack"
readonly INSTALLERS_DOWNLOAD_DIR="/data/${LOWERCASE_MODE}-downloads"
readonly CURRENT_VER="current.ver"
readonly CANARY_VER="canary.ver"
readonly RELEASE_NSIS_DIR="${RELEASE_FILES_DIR}/win_installer"

###############################################################################
#
# Cloudfront/S3 constants
#
###############################################################################
# N.B. no need to create a cache/nocache variant for PRIVATE since the
# installers are packaged into openstack images anyway.
# TODO (MP) rename the release domain.
readonly RELEASE_DOMAIN_PRIVATE="nocache.client.enterprise.aerofs.com"
readonly RELEASE_DOMAIN_PUBLIC="nocache.client.aerofs.com"
case "$MODE" in
    "PUBLIC") readonly RELEASE_DOMAIN=$RELEASE_DOMAIN_PUBLIC ;;
    "PRIVATE") readonly RELEASE_DOMAIN=$RELEASE_DOMAIN_PRIVATE ;;
esac
readonly INSTALLER_DOWNLOAD_BUCKET="s3://${RELEASE_DOMAIN}"
readonly UNSECURED_PASSPHRASE=temp123

###############################################################################
#
# Returns 0 if the product is CLIENT, 1 otherwise
#
###############################################################################
function is_client() {
    if [ "$PRODUCT" == "CLIENT" ]; then
        return 0
    fi
    return 1
}

###############################################################################
#
# Returns 0 if the product is TEAM_SERVER, 1 otherwise
#
###############################################################################
function is_team_server() {
    if [ "$PRODUCT" == "TEAM_SERVER" ]; then
        return 0
    fi
    return 1
}

###############################################################################
#
# Returns 0 if the deployment mode is PRIVATE, 1 otherwise
#
###############################################################################
function is_private() {
    if [ "$MODE" == "PRIVATE" ]; then
        return 0
    fi
    return 1
}

###############################################################################
#
# Returns 0 if the deployment mode is PUBLIC, 1 otherwise
#
###############################################################################
function is_public() {
    if [ "$MODE" == "PUBLIC" ]; then
        return 0
    fi
    return 1
}

###############################################################################
#
# Returns 0 if the deployment mode is PUBLIC or PRIVATE, 1 otherwise
#
###############################################################################
function is_public_or_private() {
    if [ "$MODE" == "PUBLIC" ] || [ "$MODE" == "PRIVATE" ]; then
        return 0
    fi
    return 1
}

###############################################################################
#
# Returns 0 if the deployment mode is CI, 1 otherwise
#
###############################################################################
function is_ci() {
    if [ "$MODE" == "CI" ]; then
        return 0
    fi
    return 1
}
###############################################################################
#
# Echo the PUBLIC version string in the format of "Version=1.2.3"
#
###############################################################################
function public_version_file_content() {
    wget --no-check-certificate --no-cache -q -O- https://${RELEASE_DOMAIN_PUBLIC}/${CANARY_VER}
}

###############################################################################
#
# Echo the PRIVATE version string in the format of "Version=1.2.3"
#
###############################################################################
function private_version_file_content() {
    wget --no-check-certificate --no-cache -q -O- https://${RELEASE_DOMAIN_PRIVATE}/${CURRENT_VER}
}

###############################################################################
#
# Gets the current active version on S3, like "0.4.98"
#
# Return the larger of the PUBLIC and PRIVATE version numbers
#
###############################################################################
function current_release_version() {
    local local_PUBLIC_VERSION_FILE_CONTENT="$( public_version_file_content )"
    local local_PRIVATE_VERSION_FILE_CONTENT="$( private_version_file_content )"
    local local_PUBLIC_VERSION="$( echo $local_PUBLIC_VERSION_FILE_CONTENT | sed -e 's/.*=//' )"
    local local_PRIVATE_VERSION="$( echo $local_PRIVATE_VERSION_FILE_CONTENT | sed -e 's/.*=//' )"
    if [[ ! $local_PUBLIC_VERSION =~ [0-9]+\.[0-9]+\.[0-9]+ ||
          ! $local_PRIVATE_VERSION =~ [0-9]+\.[0-9]+\.[0-9]+ ]];
    then
        echo ""
        exit $ERRBADVERSION
    fi

    # before calculating the max of the public and private versions, run a few
    # sanity checks on the max_version function
    [ "$(max_version 1.2.3 1.2.34)" = "1.2.34" ] || exit $ERRTESTFAIL
    [ "$(max_version 1.2.3 1.2.234)" = "1.2.234" ] || exit $ERRTESTFAIL
    [ "$(max_version 1.2.3 1.23.3)" = "1.23.3" ] || exit $ERRTESTFAIL
    [ "$(max_version 1.2.3 1.123.3)" = "1.123.3" ] || exit $ERRTESTFAIL
    [ "$(max_version 1.2.3 1.1.3)" = "1.2.3" ] || exit $ERRTESTFAIL
    [ "$(max_version 1.2.3 1.3.3)" = "1.3.3" ] || exit $ERRTESTFAIL
    [ "$(max_version 1.2.3 0.2.3)" = "1.2.3" ] || exit $ERRTESTFAIL
    [ "$(max_version 1.2.3 2.2.3)" = "2.2.3" ] || exit $ERRTESTFAIL
    [ "$(max_version 1.2.3 10.2.3)" = "10.2.3" ] || exit $ERRTESTFAIL
    max_version $local_PUBLIC_VERSION $local_PRIVATE_VERSION
}

function max_version() {
    [[ $# -ge 0 ]] || exit 1
    python -c "import sys; print max(sys.argv[1:], key=lambda v: map(int, v.split('.')))" $@
}


###############################################################################
#
# Checks the current active version on S3 and computes the next logical version.
#
###############################################################################
function compute_next_release_version() {
    local local_CURRENT_RELEASE_VERSION="$( current_release_version )"
    [[ $local_CURRENT_RELEASE_VERSION != "" ]] || exit $ERRBADVERSION
    local local_CURRENT_RELEASE_VERSION_MAJOR_MINOR="$( echo $local_CURRENT_RELEASE_VERSION | sed -e 's/\.[0-9]*$//' )"
    local local_CURRENT_RELEASE_VERSION_BUILD_NUMBR="$( echo $local_CURRENT_RELEASE_VERSION | sed -e 's/.*\.//' )"
    local local_LOCAL_VERSION_MAJOR_MINOR="$( head -1 ${BUILD_SCRIPT_DIR}/version )"

    readonly local_CURRENT_RELEASE_VERSION_STRING
    readonly local_CURRENT_RELEASE_VERSION
    readonly local_CURRENT_RELEASE_VERSION_MAJOR_MINOR
    readonly local_CURRENT_RELEASE_VERSION_BUILD_NUMBR
    readonly local_LOCAL_VERSION_MAJOR_MINOR

    local local_BUILD_NUMBER=""
    if [ $local_CURRENT_RELEASE_VERSION_MAJOR_MINOR == $local_LOCAL_VERSION_MAJOR_MINOR ]; then  #FIXME (AG): verify they've actually bumped the number
        local_BUILD_NUMBER="$( expr $local_CURRENT_RELEASE_VERSION_BUILD_NUMBR \+ 1 )"
    else
        local_BUILD_NUMBER=1 # reset build number to 1
    fi

    readonly RELEASE_VERSION="$local_LOCAL_VERSION_MAJOR_MINOR.$local_BUILD_NUMBER"
    echo "version: current => [major.minor.build:$local_CURRENT_RELEASE_VERSION] next => [major.minor.build:$RELEASE_VERSION]"
}


# Gets the product names from the labeling file.
function compute_product_names() {
    echo ">> computing product name"
    function get_property() {
        local local_PROPERTY="$1"
        # Note the equals.
        local local_KEY_VALUE_PAIR=$(grep ^"$local_PROPERTY"= $LABELING_FILE)
        if [[ $? -ne 0 ]] ; then
            echo "Couldn't retrieve property $local_PROPERTY from $LABELING_FILE"
            exit 1
        fi
        local local_VALUE=$(echo "$local_KEY_VALUE_PAIR" | cut -d = -f 2)
        if [[ -z "$local_VALUE" ]] ; then
            echo "Couldn't retrieve property $local_PROPERTY from $LABELING_FILE"
            exit 1
        fi
        echo "$local_VALUE"
    }

    readonly AEROFS_PRODUCT=$(get_property "labeling.product")
    readonly AEROFS_PRODUCT_SPACEFREE=$(get_property "labeling.productSpaceFreeName")
    readonly AEROFS_PRODUCT_UNIX=$(get_property "labeling.productUnixName")
    echo "PRODUCT = $AEROFS_PRODUCT"
    echo "PRODUCT_SPACEFREE = $AEROFS_PRODUCT_SPACEFREE"
    echo "PRODUCT_UNIX = $AEROFS_PRODUCT_UNIX"
}

# replaces the values AEROFS_PRODUCT_SPACEFREE, AEROFS_PRODUCT_UNIX, and
# AEROFS_PRODUCT in a file with the appropriate set from the environment, given
# the current labeling
function render_template() {
    if [ -z "$AEROFS_PRODUCT_SPACEFREE" -o -z "$AEROFS_PRODUCT_UNIX" -o -z "$AEROFS_PRODUCT" ] ; then
        echo "Can't render template: one of the following is empty or unset:"
        echo "\$AEROFS_PRODUCT           = $AEROFS_PRODUCT"
        echo "\$AEROFS_PRODUCT_UNIX      = $AEROFS_PRODUCT_UNIX"
        echo "\$AEROFS_PRODUCT_SPACEFREE = $AEROFS_PRODUCT_SPACEFREE"
        exit 1
    fi

    if [ $# -ne 2 ]; then
        echo "You invoked: $0 $@"
        echo "Usage: $0 <template_file> <output_file>"
        exit 1
    fi

    if [ ! -f "$1" ]; then
        echo "Template file does not exist: $1"
        exit 1
    fi

    if [ -f "$2" ]; then
        echo "Tried to render to existing file: $2"
        exit 1
    fi

    # render from template file to output file
    # we cp -a first to make sure the rendered file keeps the same permissions
    # as its source file, which is important for things like the Linux launcher
    # and copier scripts, as well as the Linux and OSX updaters.  > will
    # truncate the file before writing output without changing permissions.
    cp -a "$1" "$2"
    sed -e "s/\[AEROFS_PRODUCT_SPACEFREE\]/${AEROFS_PRODUCT_SPACEFREE}/g" \
        -e "s/\[AEROFS_PRODUCT_UNIX\]/${AEROFS_PRODUCT_UNIX}/g" \
        -e "s/\[AEROFS_PRODUCT\]/${AEROFS_PRODUCT}/g" \
        "$1" > "$2"
}


###############################################################################
#
# Synchronizes a release directory on the release server with an S3 bucket and
# invalidates the CloudFront cache.
#
# The release directory must contain the AeroFS installers for all platforms
# and a version file specifying the version of the release.
#
# NOTE: to rollback a production release to version 1.2.3 for any reason:
#       - log into release-prod@b.arrowfs.org
#       - echo Version=1.2.3 > current.ver
#       - s3cmd sync --acl-public --cf-invalidate current.ver s3://nocache.client.aerofs.com
#
# @param $1 The version to publish
# @param $2 The S3 bucket to which the release version will be pushed
#
###############################################################################
function publish_to_s3() {
    echo ">> publishing to s3 bucket ${2}"

    local local_DIR="${INSTALLERS_DOWNLOAD_DIR}/${1}"
    local local_PUBLIC_VERSION_FILE_CONTENT="$( public_version_file_content )"

    kssh $RELEASE_SERVER_LOGIN $RELEASE_SERVER_SHELL << ENDCMDS
        # Check to see that a version file exists in the specified version directory and is
        # non-empty.
        if [ ! -s "${INSTALLERS_DOWNLOAD_DIR}/${1}/${CURRENT_VER}" ]; then
            exit $ERRS3
        fi

        if [ "$MODE" = "PUBLIC" ] ; then
            # For public deployment, move current.ver to canary.ver, and use the old current.ver as the new one.
            mv "${local_DIR}/${CURRENT_VER}" "${local_DIR}/${CANARY_VER}"
            echo "${local_PUBLIC_VERSION_FILE_CONTENT}" > "${local_DIR}/${CURRENT_VER}"

            EXTRA_OPTS="--cf-invalidate"
        fi

        s3cmd --follow-symlinks --acl-public --delete-removed \$EXTRA_OPTS sync "${local_DIR}"/* $2 > /dev/null
ENDCMDS
}

fi # endif
