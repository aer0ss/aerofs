#!/bin/bash

# A script which:
# 1) copies the appropriate architecture's program binaries from
#    the system-global location (usually /usr/share/) to the user-writable
#    location under $HOME, if the ones in $HOME are either missing or more
#    out-of-date than the system ones, then
# 2) chainloads the launcher script from the user-writable app root

PRODUCT="[AEROFS_PRODUCT_UNIX]"
USER_APP_ROOT="$HOME/.${PRODUCT}-bin"

# this file (once you dereference all the symlinks) lives in shared/, under the
# system install root.  This is true for both packaged and unpackaged setups.
SYSTEM_INSTALL_ROOT=$(dirname $(dirname $(readlink -f "${BASH_SOURCE[0]}")))
SYSTEM_SHARED_FOLDER="$SYSTEM_INSTALL_ROOT/shared"

EXECUTABLE=$(basename $0)

# Architecture detection without dependencies beyond coreutils.
# ELF files start out "\x7fELF", and the following byte is
#   0x01 for 32-bit and
#   0x02 for 64-bit.
CURRENT_EXE_HEAD=$(head -c 5 /proc/self/exe )
case "$CURRENT_EXE_HEAD" in
    "$(printf '\x7fELF\x01')")
        ARCH="i386"
        ;;
    "$(printf '\x7fELF\x02')")
        ARCH="amd64"
        ;;
    *)
        echo "I don't recognize your userspace executable format, so I can't launch."
        echo "Sorry about that."
        exit 1
esac

function cleanup_on_copy_failure()
{
    rm -rf "$USER_APP_ROOT"
    echo "Failed to copy installation to $USER_APP_ROOT"
    echo "Suggestion: check the permissions on $(dirname $USER_APP_ROOT)"
    echo "Perhaps your disk is full?"
}

function copy_program_to_user_home()
{
    # Clean out the existing app root.
    rm -rf "$USER_APP_ROOT"
    # Create app root folder
    mkdir -p "$USER_APP_ROOT"
    # arch-specific files
    cp -a "$SYSTEM_INSTALL_ROOT/$ARCH"/* "$USER_APP_ROOT/"
    if [ $? -ne 0 ]; then
        cleanup_on_copy_failure
        exit 1
    fi
    # arch-independent files (including version)
    cp -a "$SYSTEM_SHARED_FOLDER"/* "$USER_APP_ROOT"/
    if [ $? -ne 0 ]; then
        cleanup_on_copy_failure
        exit 1
    fi
}

function compare_versions()
{
    # returns 5 if versions are equal,
    #         4 if $1 is newer than $2,
    #         6 if $2 is newer than $1.
    [ "$1" == "$2" ] && return 5

    ver1head=$(echo $1 | cut -d "." -f -1)
    ver1tail=$(echo $1 | cut -d "." -f 2-)
    ver2head=$(echo $2 | cut -d "." -f -1)
    ver2tail=$(echo $2 | cut -d "." -f 2-)

    if [ "$ver1head" != "$1" ] || [ "$ver2head" != "$2" ]; then
        [ "$ver1head" -gt "$ver2head" ] && return 6
        [ "$ver1head" -lt "$ver2head" ] && return 4

        # handle empty field
        [ "$ver1head" == "$1" ] || [ -z "$ver1tail" ] && ver1tail=0
        [ "$ver2head" == "$2" ] || [ -z "$ver2tail" ] && ver2tail=0
        compare_versions "$ver1tail" "$ver2tail"
        return $?
    else
        [ "$1" -gt "$2" ] && return 6 || return 4
    fi
}

function app_root_needs_update()
{
    # Returns 0 if USER_APP_ROOT needs to be updated,
    #         1 otherwise.
    if [ ! -r "$USER_APP_ROOT/version" ] ; then
        # no version file, app root update needed
        return 0
    fi
    USER_VERSION_STRING=$(head -n 1 "$USER_APP_ROOT/version")
    if [ $? -ne 0 ] ; then
        # couldn't read user version file, app root update needed
        return 0
    fi
    SYSTEM_VERSION_STRING=$(head -n 1 "$SYSTEM_SHARED_FOLDER/version")
    if [ $? -ne 0 ] ; then
        # couldn't read user version file, app root update needed
        return 0
    fi
    compare_versions "$USER_VERSION_STRING" "$SYSTEM_VERSION_STRING"
    declare -i RES=$?
    if [ $RES -eq 5 ] ; then 
        # versions match, no update needed
        return 1
    fi
    if [ $RES -eq 4 ] ; then
        # system version newer, do update
        return 0
    fi
    # user version newer, no update needed
    return 1
}

if app_root_needs_update ; then
    copy_program_to_user_home
fi

# Unity 7.3, the default desktop manager for Ubuntu 15.04, ships with
# jayatanaag and sets JAVA_TOOL_OPTIONS by default. This causes our JVM to
# crash when processing environment variables because we've stripped out
# java.lang.instrument.*.
unset JAVA_TOOL_OPTIONS

# Launch program from user app root.  We reuse the executable name used to
# invoke this script, since it encodes which UI the user is expecting.
exec $USER_APP_ROOT/$EXECUTABLE "$@"
