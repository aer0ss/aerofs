# Ship Enterprise

_It's a ship to carry enterprise-grade containers_<br />
_It's to ship apps to enterprises_<br />
_It's the starship Enterprise for fearless engineers_

Ship is a tool that automates delivery and self-managing of a multi-container
app on various cloud platforms. It takes the following as input:

1. The app's Docker images.
2. A crane.yml file that describes the structure of the app using the
[crane](https://github.com/michaelsauter/crane) format.
3. A yaml file that defines a handful of paramters for Ship.

It generates one or more output formats as follows:

## Output format

- `vm`: A single appliance VM that contains all the app containers. It provides various
deployment options:
    - `preloaded` delivers a standalone VM image with all the containers preloaded.
    - `bare` delivers a minimum image to launch the VM. Containers will be pulled at
    first run from the registry defined at build time.
    - `cloud-init` delivers a cloud-config file only for any clouds that support
    CoreOS base images.
- `vm-cluster`: Configuration data to run the app on a cluster of self-hosted VMs *
- `gke`: Configuration data for Google Container Engine *
- `ecs`: Configuration data for Amazon EC2 Container Service *

\*: Future implementations

## Usage

Note: currently Ship only supports OSX with boot2docker. See
build.sh:setup_preload_registry().

Prepare the deliverables to your customers is a 3-step process: 0: create crane.yml. 1: build the Loader. 2:
generate one or more appropriate output formats (3. push through your CI).

### 0. Create crane.yml

Create a standard [crane](https://github.com/michaelsauter/crane) yaml file to describe your
app. The same file can and should be used for development and testing of your apps as well.

The file must include one and only one container with the image name identical to the Loader image
defined in ship.yml (see Step 2). Otherwise the system will fail when building the preloaded VM image or
on the first run. Using the Loader's API from other containers is optional.

### 1. Build the Loader

Loader is a meta-container that loads and upgrades your app's other containers.
Optionally, the other containers may use an [API](#Loader API) to control and monitor Loader.
You need to build a Loader specifically for your app.

To build the Loader image, simply inherit it from "shipenterprise/loader", add the following files:

- /crane.yml: A [crane-format](https://github.com/michaelsauter/crane) file to define your app's structure. 
It should define at least one container that uses the Loader image.
- /tag: only contains your app's version string such as "v1.2.3nightly".
- /banner: Optional. An ASCII art file shown on the VM virtual console's welcome screen.

Here is an example Dockerfile:

    FROM shipenterprise/vm-loader
    COPY crane.yml /crane.yml
    COPY version /tag

You may run the `verify` command to verify the two files are correctly installed:

    $ docker build -t coolapp/loader .
    $ docker run --rm coolapp/loader verify

### 2. Generate outputs

First, make sure that all the Docker images required by your app are locally accessible,
i.e. `docker run <image>:latest` should work for all the images.

Then, define a "ship.yml" file with the following content:

    repo: registry.coolapp.com
    loader-image: coolapp/loader
    vm-image-name: coolapp-appliance
    vm-host-name: coolapp
    vm-disk-size: 102400
    vm-ram-size: 3072
    vm-cpus: 2

- repo: URL to your app repository.
- loader-image: your Loader's image name.
- vm-image-name: the file name prefix of VM images. If it's "foo", the images
will be named "foo.ova", "foo.qcow2", and so on.
- vm-host-name: the hostname of the VM. It will be visible to the end user as part of
the bash command-line prompt.
- vm-disk-size, vm-ram-size: sizes are in MB.

Lastly, call "vm/builder/build.sh" to generate VM images to folder "out":

    $ <path_to_ship>/vm/builder/build.sh ship.yml out

## Testing

You may test the Loader and console service in your development environment in addition to in the VM image
generated by the build command.

Assuming all the container images defined in crane.yml are available on the local host with the "latest" tag,
you may use this command to launch your app.

    $ docker run --rm  --name loader-test -v /var/run/docker.sock:/var/run/docker.sock aerofs/loader load latest

`POST /boot` on the Loader API only shuts down the app and quits from the above command.
It does not restart the app. To manually restart, run the above command again.

You may also run Loader's `test-getty` command to simulate the console and to test
your banner:

    $ docker run --rm -it coolapp/loader test-getty

Because the simulation has no privileges to modify the host OS, menu options that require root
privilege will not succeed. Press [^C] and enter "Y" to exit simulation.


## Loader API

Your app's containers may optionally use the Loader's REST API to control Loader and
monitor its state:

- `GET /boot`: get boot ID. The ID is a string that changes every time the Loader container restarts.
- `POST /boot`: equivalent to /boot/current/default
- `POST /boot/{version}`: equivalent to /boot/{version}/default
- `POST /boot/{version}/{group}`: reboot to a specific version and container group. The group
name must be defined in crane.yml. Use 'current' to refer to the current version.

## Internal design notes

### Assumptions

To enable live upgraeds, we use tags as part of container names. Hence, we assume legal tag names are legal
container names as well.

### Q: Why separate Loader and the console service (getty) processes?

A: The getty process is launched only for VMs with console access. The Loader process doesn't depend on the
getty process. Additionally, there may be needs for multiple getty instances (multiple virtual terminals
and series console). However there should be only one Loader instance at a time.
