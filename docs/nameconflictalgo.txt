//=============================================================================
// Pseudo-code algorithm for resolving name-merge conflicts
// Author: Mark Jeffrey
// Date: Dec 16, 2011
// Two types of remote messages are handled:
//  1) (o, v(o), n(o), ...) an object, its version, its name, and other meta
//  2) (o_a, o_t, v(o_a)) an alias message stating that o_a aliases to o_t
// Noteworth definitions:
//  vr(o) = version of object o, received remotely
//  vl(o) = version of object o, lookedup locally
//  nr(o) = name of object o, received remotely
//  nl(o) = name of object o, lookedup locally
//=============================================================================


// Helper method used by both message handlers
mergeObjects(o_a, o_t)
    vl(o_t) = vl(o_t) U vl(o_a);
    vkml(o_t) = (vkml(o_a) U vkml(o_t)) - vl(o_t)
    mark o_a -> o_t;
    vl(o_a) = nil;
    vkml(o_a) = nil;


// Method to handle the first type of message, 
// an object, its version, and name
hdObjectReceiveMsg(o, vr(o), nr(o))
    lookup o in m table
    if found o non-aliasing
        if nl(o) != nr(o):
            // Deal with different name, same oid
        elif vl(o) != vr(o):
            // Deal with different versions, same n,oid

    elif found o -> o_t:  // any o_t
        // No action required, because anti-entropy will 
        // ensure that the remote updates on o
        // are sent via o_t later, when the sender knows
        // o -> o_t
    else: // o is not found on this device
        create a table entry for o; // implicitly vl(o) = vr(o);

        // Determine if some other OID shares the same name
        o_nr = lookup nr(o) in some name->oid table
        if some o_nr is found:  // note: o_nr != o
            // There exists some object o_nr with name conflict
            if (o_nr != winner(o, o_nr):
                swap(o, o_nr);
            mergeObjects(o, o_nr);
            vl(o) = new_version; // implicit anti-entropy
        else:
            // No problem, unique oid for unique name
            // Do something normal
        


// Method to handle the second type of message, 
// an alias message 
hdAliasMsg(o_a, o_t, vr(o_a), sender)

    lookup o_t in m table
    if found o_t non-aliasing:
        // Nothing special required here
    elif found o_t -> o_e: 
        // If the target has already been aliased,
        // our new target of interest is its target
        o_t = o_e; 
    else: // o_t not found:
        request (o_t, v(o_t), n(o_t)) from sender;

    // At this point o_t represents some non-aliasing object

    lookup o_a in m table
    if found o_a non-alasing:
        // i.e., we already had an object, (o_a, n(o_a), vl(o_a))
        mergeObjects(o_a, o_t);

    elif found o_a -> o_e AND o_e != o_t:
        // this is a new alias
        // need to merge o_e and o_t
        o_tnew = winner(o_e, o_t);
        if (o_t != o_tnew):
            swap(o_t, o_e);

        // Now that we know the winner and loser,
        // merge the version vectors of the two
        // (previously) targets
        mergeObjects(o_e, o_t);
    else // o_a not found or o_a -> o_t found
        record o_a -> o_t

    // Merge local alias version with received remote;
    // if the alias previously had no version, treat as empty set.
    // Following this is an implicit anti-entropy push of the version
    vl(o_a) = vl(o_a) U vr(o_a); 

