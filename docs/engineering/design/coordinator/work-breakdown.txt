# Work Breakdown and Sequencing

A small step towards estimating the work and resources required.

# Meta: Sequencing And Milestones

	Finalize designs
		- some user-invisible details can be TBD
		- overall complexity should be estimated
		- choose a name and target dates for the rest of the milestones

	Metadata server prototype
		- basic notification logic exists
		- Core api implementation
		- non-persistent/prototype data layer ok for developers

	Availability of prototype metadata interfaces unblocks parallel development:
		- daemon integration
		- content server
		- API integration
		- high-performance metadata server
		- packaging for private cloud

Milestones:
	- prototype metadata server available for developers
		- unblocks parallel development towards end-to-end testing
		- unblocks performance testing and tuning

	- Daemon capable of syncing via Metadata server
	
	- metadata server available for Hybrid cloud
		- convert internal stores for testing

	- API integration w/ metadata server available

	- metadata server receiving production version updates in hybrid cloud

	- centralized metadata as primary source

	- metadata server packaged for private cloud
		- requires configuration
		- requires storage integration? database/mounted disk?
		- requires Store conversion plan for private deployments

	- content server available for private cloud


# Work Breakdown

Metadata server

  Non-Functional
	Legal : Hybrid only
		Update terms of service (gates deployment of advisory metadata service)
		
	Packaging
		Private Cloud
			Backing Database
				address/credential configuration
				documentation
				backup & upgrade instructions
			
		Performance testing
			
  Functional
	Core logic
		Device authentication
		ACL checks per Store
		Immediate notification mechanism for clients
		
	Protocol
		Design
			Publish and review protocol spec
			Authentication mechanism			
		Implementation
			
	Data layer
		publish/review schema for versions/metadata
		database schema setup
		implement mapping to persistent data store
		performance tests

	ACL mechanism
		define internal interface
		receive ACL updates
		Implementation

	Core API
		Publish and Review detailed API
		
		Implementation		
			"Convert from distributed tick"
				new tick
				already-received tick
				conflict tick (newer than the one used to generate a centralized version)

			"Get all updates for Store"
			
			"Get all devices holding object/version"
		
			"Update object version"
				handle notification of conflicts (previous-version mismatch)
				handle path conflicts
				handle 'override'
		
			"Version is present on device"
			
			"Get history for version"
				ACL check per store


Storage Agent
	Initial build
		Start with stripped-down Team Server?
		Reuse storage code, metadata sync code, etc.
		
	Implement supported storage types (or reuse existing)

	Setup mechanism
		Design (re-use CLI setup?)
		Implementation
	

TCP-WAN Transport
	Define new transport type
	Configure explicit listening port
	Build DERP-Lite(TM) (on top of Verkehr? persistent configuration?)
	Testing


Daemon implementation
	Implement metadata client

	Store Conversion
		Design Daemon signalling mechanism (command queue? other?)
		Implementation: convert a store
		
	Syncing
		Refactor core code
		content hash allthethings (?)
		Accept version notifications from Metadata server
		Generate version notifications from filesystem notifier
		Local conflict detection

UI updates
	Conflict detection
		Updates to conflict dialog
	
	Network diagnostics page


API server integration
	Design

	Implementation	
		Upload content
			Content upload
			Metadata upload
		
		Download content
			Get version from metadata server
			Get content
